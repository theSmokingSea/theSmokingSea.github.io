<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>3. 堆栈 | 漫艺海的blog</title><meta name="author" content="漫艺海"><meta name="copyright" content="漫艺海"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="3. 堆栈 栈是我们将设计和实现的计算器的第一个模块。尽管我在第 2 章中定义了模块的公共接口，但关于其实现我说得很少。在 C++ 中，模块不是定义的语言概念。因此，我们实际上要将栈分解为一组逻辑分组的函数和类，并将其称为我们的模块。因此，这就是我们开始的地方。如果你对栈数据结构的机制有点生疏，现在是时候参考你最喜欢的数据结构和算法书了。我个人最喜欢的是Cormen等人的书[5]。 3.1 栈模块">
<meta property="og:type" content="article">
<meta property="og:title" content="3. 堆栈">
<meta property="og:url" content="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/index.html">
<meta property="og:site_name" content="漫艺海的blog">
<meta property="og:description" content="3. 堆栈 栈是我们将设计和实现的计算器的第一个模块。尽管我在第 2 章中定义了模块的公共接口，但关于其实现我说得很少。在 C++ 中，模块不是定义的语言概念。因此，我们实际上要将栈分解为一组逻辑分组的函数和类，并将其称为我们的模块。因此，这就是我们开始的地方。如果你对栈数据结构的机制有点生疏，现在是时候参考你最喜欢的数据结构和算法书了。我个人最喜欢的是Cormen等人的书[5]。 3.1 栈模块">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/logo.png">
<meta property="article:published_time" content="2023-03-26T12:29:12.423Z">
<meta property="article:modified_time" content="2023-03-26T12:29:12.424Z">
<meta property="article:author" content="漫艺海">
<meta property="article:tag" content="Practical C++ Design From Programming to Architecture 1ed">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/logo.png"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '3. 堆栈',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-26 20:29:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="漫艺海的blog"><span class="site-name">漫艺海的blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">3. 堆栈</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-26T12:29:12.423Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-26T12:29:12.424Z" title="更新于 2023-03-26 20:29:12">2023-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Qt/">Qt</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="3. 堆栈"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>3. 堆栈</h1>
<p>栈是我们将设计和实现的计算器的第一个模块。尽管我在第 2 章中定义了模块的公共接口，但关于其实现我说得很少。在 C++ 中，模块不是定义的语言概念。因此，我们实际上要将栈分解为一组逻辑分组的函数和类，并将其称为我们的模块。因此，这就是我们开始的地方。如果你对栈数据结构的机制有点生疏，现在是时候参考你最喜欢的数据结构和算法书了。我个人最喜欢的是Cormen等人的书[5]。</p>
<h2 id="3-1-栈模块的分解">3.1 栈模块的分解</h2>
<p>在分解栈模块时要问的第一个问题是：“栈应该被划分成多少部分？”用面向对象的说法，我们问：“我们需要多少对象，它们是什么？”在这种情况下，答案相当明显：一个，栈本身。本质上，整个栈模块是单个数据结构的体现，可以很容易地由单个类封装。这个类的公共接口已经在第 2 章中描述过。</p>
<p>第二个问题可能是：“我是否需要构建一个类，还是只需要直接使用标准模板库(STL)中的栈类？”这实际上是一个非常好的问题。所有的设计书籍都宣扬，当你可以使用库中的数据结构时，永远不要编写自己的数据结构，尤其是当数据结构可以在 STL 中找到时，因为 STL 保证是 C++ 标准分发的一部分。确实，这是明智的建议，我们不应该重写栈数据结构的机制。然而，我们也不应该直接使用 STL 栈作为我们系统中的栈。相反，我们将编写我们自己的栈类，将一个 STL 容器作为私有成员封装。</p>
<p>如果我们选择使用 STL 栈来实现我们的栈模块，有几个原因可以解释为什么封装一个 STL 容器（或任何供应商的数据结构）比直接使用更好。首先，通过包装 STL 栈，我们为计算器的其他部分设置了一个接口保护。也就是说，我们通过将栈的接口与其实现分离（记得封装吗？）来保护其他计算器模块免受潜在的栈实现更改的影响。当使用供应商软件时，这种预防措施尤为重要，因为这种设计决策使更改局限于包装器的实现，而不是栈模块的接口。如果供应商修改其产品的接口（供应商就是这么狡猾）或者你决定将一个供应商的产品换成另一个供应商的产品，这些更改只会在局部影响你的栈模块的实现，而不会影响栈模块的调用者。即使底层实现是标准化的，如 ISO 标准化的 STL 栈，接口保护也使您可以更改底层实现而不影响依赖模块。例如，如果您改变主意，后来决定用向量而不是栈重新实现栈模块怎么办。</p>
<p>将 STL 容器封装而不是直接使用的第二个原因是，这样可以让我们限制接口以精确符合我们的需求。在第 2 章中，我们花费了大量的精力设计一个有限的、最小的栈模块接口，能够满足所有 pdCalc 的用例。通常情况下，底层实现可能提供的功能比你实际希望暴露的要多。如果我们选择直接将 STL 栈作为我们的栈模块，这个问题不会很严重，因为 STL 栈的接口，不出所料，与我们为计算器的栈定义的接口非常相似。然而，假设我们选择了 Acme 公司的 RichStack 类，它有 67 个公共成员函数，作为我们的栈模块不加包装地使用。一个没有仔细阅读设计规范的初级开发人员可能在应用程序的上下文中无意中调用了一个不应该公开的 RichStack 函数，从而违反了我们的栈模块的一些隐含的设计约定。尽管这种滥用可能与模块的文档接口不一致，但不应该依赖其他开发人员实际阅读或遵守文档（令人遗憾，但事实就是如此）。</p>
<p>将 STL 容器封装的第三个原因是扩展或修改底层数据结构的功能。例如，对于 pdCalc，我们需要添加两个在 STL 栈类中不存在的函数（getElements() 和 swapTop()），并将错误处理从标准异常转换为我们自定义的错误事件。因此，包装器类使我们能够修改 STL 的标准容器接口，使其符合我们自己的内部设计的接口，而不是受到 STL 提供给我们的功能的限制。</p>
<p>正如人们所预料的那样，上述封装场景非常常见，因此已经被编码为一种设计模式，即适配器（包装器）模式[6]。正如 Gamma 等人所描述的，适配器模式用于将一个类的接口转换为客户端期望的另一个接口。通常情况下，适配器提供了某种形式的转换能力，从而也充当了不兼容类之间的代理。</p>
<p>在该模式的原始描述中，适配器被抽象出来，允许单个消息通过使用适配器类层次结构通过多态性包装多个不同的被适配者。对于 pdCalc 的栈模块的需求，一个简单的具体适配器类就足够了。</p>
<p>请记住，设计模式的存在是为了帮助设计和沟通。尽量不要陷入按照教材中规定的方式完全实现模式的陷阱。使用文献作为指南来帮助澄清您的设计，但最终，选择适合您的应用的最简单的解决方案，而不是最接近学术理想的解决方案。</p>
<p>最后一个问题是：“我的栈应该是泛型（即模板化）的吗？”这里的答案是一个响亮的也许。从理论上讲，设计一个抽象数据结构来封装任何数据类型是合理的做法。如果数据结构的最终目标是出现在库中或被多个项目共享，那么数据结构应该是通用的。然而，在单个项目的背景下，我不建议将数据结构设为泛型，至少一开始不要这样做。泛型代码更难编写，更难维护，更难测试。除非一开始就存在多种类型的使用场景，否则我发现编写泛型代码并不值得费心。我已经完成了太多的项目，在这些项目中，我花了额外的时间设计、实现和测试一个泛型数据结构，但只是用它来处理一种类型。实际上，如果您有一个非泛型数据结构，突然发现您确实需要将其用于不同的类型，那么所需的重构通常不会比从一开始就设计为泛型的类更难。此外，现有的测试将很容易适应泛型接口，通过单一类型建立正确性的基线。因此，我们将设计我们的栈为特定于 double 类型。</p>
<h2 id="3-2-Stack类">3.2 Stack类</h2>
<p>现在我们已经确定了我们的模块将由一个类组成，一个用于底层栈数据结构的适配器，让我们设计它。设计一个类时首先要问的问题之一是：“这个类将如何被使用？”例如，您是否正在设计一个抽象基类以被继承并因此被多态地使用？您是否主要将一个类设计为纯粹的旧数据（POD）存储库？在任何给定时间，这个类的许多不同实例是否存在？任何给定实例的生命周期是多少？谁通常拥有这个类的实例？实例是否共享？这个类是否并发使用？通过询问这些和其他类似的问题，我们发现以下关于我们的栈的功能需求列表：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>系统中应该只有一个栈存在。</p>
</li>
<li class="lvl-2">
<p>栈的生命周期是应用程序的生命周期。</p>
</li>
<li class="lvl-2">
<p>UI 和命令调度器都需要访问栈；两者都不应拥有栈。</p>
</li>
<li class="lvl-2">
<p>栈访问不是并发的。</p>
</li>
</ul>
<p>任何时候满足上述前三个条件，该类都是单例模式 [6] 的绝佳候选者。</p>
<h3 id="3-2-1-单例模式">3.2.1 单例模式</h3>
<p>单例模式用于创建一个在系统中只应该存在一个实例的类。单例类不由其任何消费者拥有，但类的单个实例也不是全局变量（然而，有些人认为单例模式实际上是伪装的全局数据）。为了不依赖荣誉制度，我们使用语言机制来确保只能存在一个实例。</p>
<p>此外，在单例模式中，实例的生命周期通常从第一次实例化到程序终止。根据实现情况，单例可以被创建为线程安全的，也可以仅适用于单线程应用程序。关于不同 C++ 单例实现的优秀讨论可以在 Alexandrescu [2] 中找到。对于我们的计算器，我们将使用满足我们目标的最简单的实现。</p>
<p>为了得出一个简单的单例实现，我们参考 C++ 语言的知识。首先，如前所述，没有其他类拥有单例实例，也不是单例的实例是全局对象。这意味着单例类需要拥有它的单一实例，所有权访问应该是私有的。为了防止其他类实例化我们的单例，我们还需要使其构造函数和赋值运算符私有或删除。其次，知道系统中只有一个单例实例存在，立即意味着我们的类应该静态地持有它的实例。最后，其他类将需要访问这个单一实例，我们可以通过一个公共静态函数提供。将上述要点结合起来，我们构建了如清单 3-1 所示的单例类的框架。</p>
<p>清单 3-1 单例类的框架</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> Singleton&amp; Instance</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123; <span class="comment">/* does foo things */</span> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// prevent public instantiation, copying, assignment, movement,</span></span><br><span class="line">  <span class="comment">// &amp; destruction</span></span><br><span class="line">  <span class="built_in">Singleton</span>() &#123; <span class="comment">/* constructor */</span> &#125;</span><br><span class="line">  <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">Singleton</span>(Singleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Singleton&amp;&amp; <span class="keyword">operator</span>=(Singleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  ~<span class="built_in">Singleton</span>() &#123; <span class="comment">/* destructor */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Singleton 类的静态实例以函数作用域而不是类作用域来保存，以防止在一个单例类的构造函数依赖于另一个单例时出现不可控的实例化顺序冲突。C++ 的实例化顺序规则的细节超出了本书的范围，但在 Alexandrescu [2] 中可以找到关于单例的详细讨论。</p>
<p>请注意，由于缺少对一个实例访问的锁定，我们的模型单例目前仅适用于单线程环境。在多核处理器的时代，这种限制明智吗？对于 pdCalc，绝对是！我们的简单计算器不需要多线程。编程是困难的。多线程编程要困难得多。除非绝对必要，永远不要把一个简单的设计问题变成一个更难的问题。</p>
<p>现在我们有了 Singleton 类的框架，让我们看看如何使用它。为了访问实例并调用 foo() 函数，我们只需使用以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton::<span class="built_in">Instance</span>().<span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure>
<p>在第一次调用 Instance() 函数时，实例变量被静态实例化，并返回对该对象的引用。由于在函数作用域静态分配的对象在内存中保持到程序终止，因此在 Instance() 函数作用域结束时，实例对象不会被析构。在后续对 Instance() 的调用中，跳过实例变量的实例化（它已经从之前的函数调用中构造并存储在内存中），并简单地返回对实例变量的引用。请注意，虽然底层单例实例是静态持有的，但 foo() 函数本身不是静态的。</p>
<p>好奇的读者现在可能会问：“为什么要费心持有一个类的实例？为什么不干脆把 Singleton 类的所有数据和所有函数都设为静态？”原因是因为单例模式允许我们在需要实例语义的地方使用 Singleton 类。这些语义的一个特别重要的用途是在回调的实现中。例如，考虑 Qt 的信号和插槽机制（在第 6 章中你会遇到信号和插槽），它可以被大致理解为一个强大的回调系统。为了将一个类中的信号连接到另一个类中的插槽，我们必须为这两个类实例提供指针。如果我们在没有私有实例化 Singleton 类的情况下实现了我们的单例（即，仅使用静态数据和静态函数），那么在 Qt 的信号和插槽中使用我们的 Singleton 类将是不可能的。</p>
<h3 id="3-2-2-堆栈模块作为单例类">3.2.2 堆栈模块作为单例类</h3>
<p>我们现在拥有了堆栈模块的基本设计。我们已经决定整个模块将被封装在一个类中，这个类实际上充当一个STL容器的适配器。我们已经决定，我们的这个类符合单例模式的模型标准，这个单例类将拥有第2章设计的公共接口。将这些设计元素结合起来，我们得到了类的初始声明，如Listing 3-2所示。</p>
<p>Listing 3-2 堆栈作为单例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">StackImpl</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Stack&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getElements</span><span class="params">(<span class="type">int</span>, vector&lt;<span class="type">double</span>&gt;&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swapTop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Stack</span>();</span><br><span class="line">  ~<span class="built_in">Stack</span>();</span><br><span class="line">  <span class="comment">// appropriate blocking of copying, assigning, moving...</span></span><br><span class="line">  unique_ptr&lt;StackImpl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于本书的重点是设计，除非细节特别有启发性或者突显设计的关键元素，否则文本中不会提供每个成员函数的实现。请记住，pdCalc的完整实现可以从GitHub仓库下载。有时，仓库源代码将是文本中理想化接口的一个更复杂的变体。这将是本书剩余部分的通用格式。</p>
<p>对于那些不熟悉pimpl惯用法（将一个类的实现放在一个单独的私有实现类中）的读者，pimpl成员变量可能看起来很神秘。不用担心。你将在下面的一个部分回顾这个原则。</p>
<p>在暂时离开Stack类设计的讨论之前，让我们稍作分析，并讨论一个相关的实现细节。我们花了很多时间回顾在Stack设计中使用适配器模式来隐藏底层数据结构的重要性。这个决定的一个理由是，它提供了在不影响依赖于Stack接口的类的情况下，无缝地改变底层实现的能力。问题是：“为什么Stack的底层实现可能会改变？”</p>
<p>在实现 Stack 的第一个版本中，我选择了一个显而易见的底层数据结构，即 STL 栈。然而，我很快就遇到了使用 STL 栈的效率问题。我们的 Stack 类接口提供了一个 getElements() 函数，使用户界面能够查看计算器堆栈的内容。不幸的是，STL 栈的接口没有提供类似的功能。查看除顶部元素以外的 STL 栈中的元素的唯一方法是连续弹出栈，直到到达感兴趣的元素。显然，因为我们只是尝试查看堆栈的元素，而不是修改堆栈本身，我们需要立即将所有条目重新压回堆栈。有趣的是，对于我们的目的，STL 栈居然是实现堆栈的不适当的数据结构！一定有更好的解决方案。</p>
<p>幸运的是，STL 为我们的任务提供了另一种适合的数据结构，即双端队列或 deque。deque 是一个类似于向量的 STL 数据结构，只是 deque 允许将元素推到其前端和后端。向量在保持连续性保证的同时进行优化以增长，而 deque 通过牺牲连续性来快速增长和收缩进行优化。这个特性正是高效实现堆栈所需的设计权衡。实际上，实现 STL 栈的最常见方法就是简单地包装一个 STL deque（是的，就像我们的 Stack，STL 的栈也是适配器模式的一个例子）。幸运的是，STL deque 还允许非破坏性迭代，这是我们需要实现 Stack 的 getElements() 方法时，从 STL 栈中缺少的额外要求。我使用封装来隐藏 Stack 的实现对其接口很有好处。在意识到查看 STL 栈的局限性后，我能够将 Stack 类的实现更改为使用 STL deque，而不对 pdCalc 的任何其他模块产生影响。</p>
<h4 id="3-2-2-1-Pimpl-习语">3.2.2.1 Pimpl 习语</h4>
<p>如果你选择查看 pdCalc 实现的 GitHub 存储库版本，你会注意到许多实际类实现都被 pimpl 习语（桥接模式的 C++ 专用化）隐藏起来。对于不熟悉这个术语的人，它是指针到实现的简写。在实践中，你不是在头文件中声明一个类的所有实现，而是前向声明一个指向“隐藏”的实现类的指针，并在实现文件中完全声明和定义这个“隐藏”的类。只要在包含其完整声明的源文件中对 pimpl 变量进行解引用，包含和使用不完整类型（pimpl 变量）是允许的。例如，考虑下面的类 A，其公共接口由函数 f() 和 g() 组成；私有实现包含函数 u()、v() 和 w()；私有数据 v_ 和 m_：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">u</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">v</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">w</span><span class="params">()</span></span>;</span><br><span class="line">  vector&lt;<span class="type">double</span>&gt; v_;</span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt; m_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 pimpl 习语，我们可以将 A 的私有接口从消费者类中隐藏起来，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">AImpl</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unique_ptr&lt;AImpl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 u、v、w、v_ 和 m_ 现在都是类 AImpl 的一部分，这个类只在与类 A 关联的实现文件中声明和定义。为确保 AImpl 不能被其他类访问，我们将这个实现类声明为一个完全在 A 内部定义的私有类。Sutter 和 Alexandrescu [27] 对 pimpl 习语的优点做了简要的解释。主要优点之一是，通过将 A 类的私有接口从 A.h 移动到 A.cpp，我们在只更改 A 的私有接口时不再需要重新编译使用 A 类的代码。对于大型软件项目，编译过程中节省的时间可能很显著。</p>
<p>就我个人而言，我在编写的大部分代码中都使用 pimpl 习语。我普遍规则的例外是具有非常有限的私有接口或计算密集型代码（即 pimpl 的间接开销很大的代码）。除了在只更改 AImpl 类时不必重新编译包含 A.h 的文件的编译优势外，我发现 pimpl 习语为代码增加了很大的清晰度。这种清晰度来自于能够在实现文件中隐藏帮助函数和类，而不是将它们列在头文件中。通过这种方式，头文件真正只反映了接口的基本要素，</p>
<p>在继续完成 Stack 的接口之前，请注意，在这里使用 pimpl 惯用法完全隐藏了 Stack 类用户对底层堆栈数据结构的选择。这个选择是一个实现细节，应该对用户隐藏。pimpl 惯用法使我们能够完全隐藏它，甚至从视觉上也无法检查到。pimpl 惯用法确实是封装的典范。</p>
<h2 id="3-3-添加事件">3.3 添加事件</h2>
<p>为了构建符合第 2 章堆栈接口的堆栈，最后需要实现事件。事件是一种弱耦合形式，允许一个对象（通知器或发布者）向任意数量的其他对象（监听器或订阅者）发出信号，表示有趣的事情发生了。耦合是弱的，因为通知器和监听器都不需要直接了解对方的接口。事件的实现取决于语言和库，甚至在给定的语言中，可能存在多个选项。例如，在 C# 中，事件是核心语言的一部分，事件处理相对容易。在 C++ 中，我们没有那么幸运，必须实现我们自己的事件系统或依赖提供此功能的库。</p>
<p>C++ 程序员有几个已发布的库选项来处理事件；其中最突出的选择是 boost 和 Qt。boost 库支持信号和插槽，这是一种静态类型的机制，供发布者通过回调向订阅者发出事件信号。另一方面，Qt 既提供了完整的事件系统，又提供了动态类型的事件回调机制，巧合的是，这也被称为信号和插槽。这两个库都有详细的文档、经过充分测试、受到尊重，可用于开源和商业用途。任何一个库都是在我们的计算器中实现事件的可行选项。然而，为了教学目的，也为了尽量减少我们计算器后端对外部库的依赖，我们将实现我们自己的事件系统。在设计自己的软件时，做出适当的决策非常依赖于具体情况，你应该权衡使用库与为你的单独应用程序构建自定义事件处理的利弊。也就是说，默认的立场是，除非你有令人信服的理由做其他事情，否则应该使用库。</p>
<h3 id="3-3-1-观察者模式">3.3.1 观察者模式</h3>
<p>因为事件处理是 C++ 中如此常见的功能，你可以确信存在一个描述事件处理的设计模式；这个模式就是观察者模式。观察者模式是实现发布者和监听者的抽象实现的标准方法。顾名思义，这里的监听者被称为观察者。</p>
<p>在 Gamma 等人 [6] 描述的模式中，具体的发布者实现了一个抽象的发布者接口，具体的观察者实现了一个抽象的观察者接口。从概念上讲，实现是通过公共继承进行的。每个发布者都拥有一个观察者容器，发布者的接口允许附加和分离观察者。当事件发生（被引发）时，发布者遍历其观察者集合，并通知每个观察者事件已发生。通过虚拟分派，每个具体观察者根据自己的实现处理此通知消息。</p>
<p>观察者可以通过两种方式从发布者接收状态信息。首先，具体观察者可以具有指向其正在观察的具体发布者的指针。通过这个指针，观察者可以在事件发生时查询发布者的状态。这种机制称为拉取语义。或者，可以实现推送语义，其中发布者将状态信息与事件通知一起推送给观察者。图 3-1 中展示了展示推送语义的观察者模式的简化类图。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/A454125_1_En_3_Fig1_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图 3-1 为 pdCalc 实现的观察者模式的简化版本的类图。该图说明了事件数据的推送语义。
  	</div>
</center>
<h4 id="3-3-1-1-改进观察者模式实现">3.3.1.1 改进观察者模式实现</h4>
<p>在我们的计算器的实际实现中，在图 3-1 中描绘的抽象之外添加了一些额外的功能。首先，在图中，每个发布者拥有一个观察者列表，当事件发生时，所有观察者都会收到通知。然而，这种实现意味着发布者要么只有一个事件，要么有多个事件，但是没有办法区分哪些观察者在每个事件中被调用。一个更好的发布者实现方法是持有一个观察者列表的关联数组。这样，每个发布者可以有多个不同的事件，每个事件只通知对观察该特定事件感兴趣的观察者。虽然关联数组中的键在技术上可以是设计者选择的任何合适数据类型，但我选择在计算器中使用字符串。也就是说，发布者通过名称来区分各个事件。这个选择增强了可读性，并允许在运行时灵活地添加事件（相对于，例如，选择枚举值作为键）。</p>
<p>一旦发布者类可以包含多个事件，程序员需要在调用 attach() 或 detach() 时通过名称指定事件。因此，需要适当地修改这些方法在图 3-1 中出现的签名，以包含事件名称。对于附件，通过添加事件名称来完成方法签名。调用者只需用具体观察者实例和观察者要附加的事件名称调用 attach() 方法即可。然而，从发布者中分离观察者需要稍微复杂一些的机制。由于发布者中的每个事件都可以包含多个观察者，程序员需要有区分观察者以进行分离的能力。自然地，这种需求也导致了观察者的命名，以及 detach() 函数签名必须修改以适应观察者和事件的名称。</p>
<p>为了方便分离观察者，在每个事件上的观察者应该间接存储并通过其名称引用。因此，我们选择使用观察者的关联数组的关联数组，而不是存储关联数组的观察者列表。</p>
<p>在现代 C++ 中，程序员可以选择使用 map 或 unordered_map 作为关联数组的标准库实现。这两种数据结构的规范实现分别是红黑树和哈希表。由于关联数组中元素的顺序并不重要，因此我选择了 unordered_map 作为 pdCalc 的 Publisher 类。然而，对于每个事件可能有的少量观察者来说，这两种数据结构都是同样有效的选择。</p>
<p>到目前为止，我们还没有明确指出观察者在发布者中是如何存储的，只是说它们以某种方式存储在关联数组中。因为观察者是多态的，语言规则要求它们由指针或引用持有。问题变成，发布者应该拥有观察者还是仅引用其他类拥有的观察者？如果我们选择引用途径（通过引用或原始指针），除了发布者之外的其他类需要拥有观察者的内存。这种情况是有问题的，因为在任何特定实例中，谁应该拥有观察者并不清楚。因此，每个开发者可能会选择不同的选项，长期维护观察者会陷入混乱。更糟糕的是，如果观察者的所有者在没有将观察者从发布者分离的情况下释放了观察者的内存，触发发布者的事件会导致崩溃，因为发布者将持有对观察者的无效引用。基于这些原因，我更倾向于让发布者拥有其观察者的内存。</p>
<p>避免使用引用，我们必须使用拥有语义，由于C<ins>多态性的机制，我们必须通过指针实现所有权。在现代C</ins>中，通过unique_ptr实现指针类型的唯一所有权（请参阅“现代C++设计注意事项”侧边栏中关于拥有语义的部分，以了解设计影响）。将上述所有建议结合起来，我们可以设计出发布者类的最终公共接口，如列表3-3所示。</p>
<p>列表3-3 发布者类的最终公共接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Publisher.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">PublisherImpl</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(<span class="type">const</span> string&amp; eventName,</span></span></span><br><span class="line"><span class="params"><span class="function">              unique_ptr&lt;Observer&gt; observer)</span></span>;</span><br><span class="line">  <span class="function">unique_ptr&lt;Observer&gt; <span class="title">detach</span><span class="params">(<span class="type">const</span> string&amp; eventName,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> string&amp; observerName)</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unique_ptr&lt;PublisherImpl&gt; publisherImpl_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>事件存储的实现细节如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Publisher.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Publisher</span>::PublisherImpl</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">  <span class="keyword">using</span> ObserversList = unordered_map&lt;string, unique_ptr&lt;Observer&gt;&gt;;</span><br><span class="line">  <span class="keyword">using</span> Events = unordered_map&lt;string, ObserversList&gt;;</span><br><span class="line">  Events events_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>观察者类的接口比发布者类的接口简单得多。然而，由于我还没有描述如何处理事件数据，我们还没有准备好设计观察者的接口。在下面的3.3.1.2节中，我将讨论事件数据和观察者类的接口。</p>
<hr>
<p>现代C++设计注意事项：拥有语义和unique_ptr</p>
<p>在C<ins>中，拥有一个对象的概念意味着在不再需要对象时负责删除其内存。在C</ins>11之前，尽管任何人都可以实现自己的智能指针（很多人都这么做了），但语言本身没有表达标准的指针所有权语义（除了已被弃用的auto_ptr）。通过原生指针传递内存更像是一个信任问题。也就是说，如果你使用“new”创建一个指针，并通过原始指针将其传递给一个库，你希望该库在使用完它后删除内存。或者，库的文档可能会告诉你在执行某些操作后删除内存。在没有标准智能指针的情况下，在最糟糕的情况下，你的程序会泄露内存。在最好的情况下，你必须使用非标准智能指针来与库进行接口。</p>
<p>C++11通过标准化一组主要来自Boost库的智能指针来解决未知指针所有权的问题。unique_ptr终于允许程序员正确地实现唯一所有权（因此弃用了auto_ptr）。本质上，unique_ptr确保在任何时候只有一个指针实例存在。为了让语言实现这些规则，unique_ptr不实现拷贝和非移动赋值。相反，采用移动语义来确保所有权的转移（也可以使用显式函数调用手动管理内存）。Josuttis[8]提供了一个关于使用unique_ptr机制的详细描述。一个重要的要点是不要在unique_ptr和原始指针之间混合使用指针类型。</p>
<p>从设计的角度来看，unique_ptr意味着我们可以使用标准C++编写接口，明确地表达唯一所有权语义。正如在观察者模式的讨论中所看到的，唯一所有权语义在任何一个类创建内存供另一个类拥有的设计中都是很重要的。例如，在计算器的事件系统中，虽然事件的发布者应该拥有其观察者，但发布者很少有足够的信息来创建其观察者。因此，能够在一个位置创建观察者的内存，但能够将内存的所有权传递给另一个位置，即发布者，是很重要的。unique_ptr提供了这项服务。因为观察者是通过unique_ptr传递给发布者的，所有权转移到发布者，当发布者不再需要观察者时，智能指针会删除观察者的内存。另外，任何类都可以从发布者那里收回一个观察者。因为detach()方法将观察者以unique_ptr的形式返回，发布者通过将其转移回调用者显然放弃了观察者内存的所有权。</p>
<hr>
<p>上述观察者模式的实现明确强制执行发布者拥有其观察者的设计。使用这个实现的最自然方式涉及创建小型的、专用的、中介观察者类，这些类本身持有指向应响应事件的实际类的指针或引用。例如，从第2章我们知道，pdCalc的用户界面是Stack类的观察者。然而，我们真的希望用户界面成为一个由Stack拥有的（公共继承自）观察者，如图3-2a所示吗？不。图3-2c展示了一个更好的解决方案。在这里，Stack拥有一个stack ChangeEvent观察者，当堆栈发生变化时，它会通知UserInterface。这种模式使Stack和UserInterface保持真正的独立性。在第5章学习我们的第一个用户界面时，将对此主题进行更多讨论。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/A454125_1_En_3_Fig2_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图3-2 观察者模式的不同所有权策略
  	</div>
</center>
<p>现代C++确实提供了观察者模式所有权语义的另一个合理选择：共享所有权。如上所述，让Stack拥有用户界面是不合理的。然而，有些人可能认为，与其直接使用户界面成为观察者，不如创建一个额外的ChangeEvent中介类同样不合理。唯一可用的折中选择似乎是让Stack引用用户界面。不过，之前我提到，让发布者引用其观察者是不安全的，因为观察者可能会在发布者下方消失，留下一个悬空的引用。这个悬空引用问题能解决吗？</p>
<p>幸运的是，现代C++再次解决了这个问题，引入了共享语义（如图3-2b所示）。在这个情况下，观察者使用shared_ptr（参见下面的shared_ptr边栏）共享，而发布者使用weak_ptr（shared_ptr的亲戚）保留对观察者的引用。weak_ptr专门设计用于缓解对共享对象的悬空引用问题。这种发布者共享观察者所有权的设计</p>
<h4 id="3-3-1-2-处理事件数据">3.3.1.2 处理事件数据</h4>
<p>在描述观察者模式时，我提到了处理事件数据的两种不同范式：拉取语义和推送语义。在拉取语义中，观察者只被通知事件发生了。然后观察者有责任获取可能需要的任何额外数据。实现非常简单。观察者维护对可能需要获取状态信息的任何对象的引用，并在响应事件时调用成员函数来获取此状态。</p>
<p>拉取语义有几个优点。首先，观察者在处理事件时可以选择要获取的状态。其次，不会在将可能未使用的参数传递给观察者时消耗不必要的资源。第三，拉取语义易于实现，因为事件不需要携带数据。然而，拉取语义也有缺点。首先，拉取语义增加了耦合，因为观察者需要持有发布者的引用并了解发布者的状态获取接口。其次，观察者只能访问发布者的公共接口。这种访问限制使观察者无法从发布者那里获取私有数据。</p>
<p>与拉取语义相反，推送语义是通过让发布者在引发事件时发送与事件相关的状态数据来实现的。然后观察者将此状态数据作为通知回调的参数接收。接口通过在抽象Observer基类中将notify函数设为纯虚函数来强制执行推送语义。</p>
<p>事件处理的推送语义也有优点和缺点。第一个优点是推送语义降低了耦合。发布者和观察者都不需要了解对方的接口。他们只需要遵循抽象的事件处理接口。第二，当发布者推送状态时，可以将私有信息发送给观察者。第三，作为引发事件的对象，发布者可以发送处理事件所需的精确数据。推送语义的主要缺点是实现起来稍微困难，而且在观察者不需要发布者推送的状态数据的情况下可能会产生不必要的开销。最后，请注意，使用推送语义的设计可以通过在推送数据中添加回调引用，总是可以用拉取语义来简单地扩展特殊情况。反之则不然，因为推送语义需要在事件处理机制中专用的基础设施。</p>
<p>基于上述推送和拉取语义之间的权衡，我选择为pdCalc的事件处理实现推送语义。推送语义的主要缺点是实现的潜在计算开销。然而，由于我们的应用程序不是性能密集型的，这种模式表现出的耦合降低以及发布者维护的参数控制优于轻微的性能开销。我们现在的任务是设计一个通过推送语义传递事件数据的实现。</p>
<p>为了实现事件处理的推送语义，必须在引发事件时从发布者到观察者传递参数的接口进行标准化。理想情况下，每个发布者/观察者对都会同意要传递的参数类型，当事件被引发时，发布者将调用观察者上的适当成员函数。然而，在我们的发布者/观察者类层次结构中，这种理想情况实际上是不可能的，因为具体发布者不了解具体观察者的接口。具体发布者只能通过在发布者基类中调用raise()函数来通用地引发事件。raise()函数反过来通过观察者基类的虚拟notify()函数多态地通知具体观察者。因此，我们寻求一种通过抽象raise/notify接口传递定制数据的通用技术。</p>
<p>我们的困境的解决方案相当简单。我们为事件数据创建一个并行的对象层次结构，并通过这个抽象状态接口从发布者传递事件数据到观察者。这个层次结构中的基类，EventData，是一个空类，只包含一个虚拟析构函数。每个需要参数的事件都继承这个基类，并实现适当的数据处理方案。当事件被引发时，发布者通过一个EventData基类指针将数据传递给观察者。在收到数据后，具体观察者将状态数据向下转换为具体数据类，然后通过派生类的具体接口提取所需数据。虽然具体发布者和具体观察者确实需要在数据对象的接口上达成一致，但具体发布者和具体观察者都不需要知道对方的接口。因此，我们保持了松散的耦合。</p>
<p>为了巩固上述观点，让我们来看一下计算器的 Stack 如何实现状态数据。回想一下第2章，Stack 实现了两个事件，stackChanged() 事件和 error(string) 事件。在这个上下文中，stackChanged() 事件并不有趣，因为该事件没有携带数据。然而，错误事件确实携带了数据。考虑一下 Stack 错误条件的类层次结构，如列表3-4所示。</p>
<p>列表3-4 事件数据层次结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Publisher.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">EventData</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Stack.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackEventData</span> : <span class="keyword">public</span> EventData</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum class</span> <span class="title class_">ErrorConditions</span> &#123; Empty, TooFewArguments &#125;;</span><br><span class="line">  <span class="built_in">StackEventData</span>(ErrorConditions e) : <span class="built_in">err_</span>(e) &#123; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">Message</span><span class="params">(ErrorConditions ec)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">message</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">ErrorConditions <span class="title">error</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> err_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ErrorConditions err_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>StackEventData 类定义了 Stack 的事件数据如何封装并发送给观察 Stack 的类。当 Stack 模块内发生错误时，Stack 类引发一个事件，并将有关该事件的信息推送给它的观察者。在这种情况下，Stack 创建一个 StackEventData 实例，在构造函数中指定错误类型。这个包含有限错误条件集合的枚举类型可以使用 message() 函数转换为字符串。当观察者被通知事件发生时，他们可以自由地使用或忽略这些信息。如果你注意到了，是的，我微妙地将 error() 接口的签名从 string 更改为了 EventData。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent_.<span class="built_in">raise</span>(Stack::StackError, <span class="built_in">make_shared</span>&lt;StackEventData&gt;(</span><br><span class="line">  StackEventData::ErrorConditions::Empty));</span><br></pre></td></tr></table></figure>
<p>作为一个具体的例子，假设因为弹出一个空栈而触发错误。为了引发这个事件，Stack 调用以下代码（实际实现略有不同，因为 Stack 被封装在 pimpl 中）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent_.<span class="built_in">raise</span>(Stack::StackError, <span class="built_in">make_shared</span>&lt;StackEventData&gt;(</span><br><span class="line">  StackEventData::ErrorConditions::Empty));</span><br></pre></td></tr></table></figure>
<p>第一个传递给 raise() 函数的参数是一个解析为 “error” 的静态字符串。回想一下，为了处理多个事件，发布者为每个事件命名。在这里，Stack::StackError 静态变量保存了此事件的名称。使用变量而不是直接使用字符串是为了防止因输入错误的事件名称而导致的运行时错误。raise() 函数的第二个参数创建了 StackEventData 实例，并用空栈错误条件对其进行初始化。注意，实现通过 shared_ptr 传递事件数据。这个决定在下面关于共享语义的侧边栏中进行讨论。尽管 StackObserver 类尚未被介绍，但为了完整起见，我注意到一个事件可以通过以下典型代码进行解释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StackObserver::<span class="built_in">notify</span>(shared_ptr&lt;EventData&gt; d)</span><br><span class="line">&#123;</span><br><span class="line">  shared_ptr&lt;StackEventData&gt; p = <span class="built_in">dynamic_pointer_cast</span>&lt;StackEventData&gt;(d);</span><br><span class="line">  <span class="keyword">if</span>(p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// do something with the data</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// uh oh, what event did we just catch?!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>现代 C++ 设计注意事项：共享语义和 shared_ptr</p>
<p>shared_ptr 让程序员可以安全地表达共享所有权，而 unique_ptr 让程序员可以安全地表达独占所有权。在 C<ins>11 标准之前，C</ins> 通过原始指针或引用来实现数据共享。因为类数据的引用只能在构造期间初始化，对于延迟绑定数据，只能使用原始指针。因此，通常两个类通过各自包含一个指向公共对象的原始指针来共享单个数据。当然，这种情况的问题是不清楚哪个对象拥有共享对象。特别是，这种模糊意味着不确定何时可以安全地删除这样的共享对象，以及哪个拥有对象最终应该释放内存。shared_ptrs 在标准库级别解决了这个困境。</p>
<p>shared_ptr 通过引用计数实现共享语义。随着新对象指向 shared_ptr，内部引用计数增加（通过构造函数和赋值实施）。当 shared_ptr 超出范围时，调用其析构函数，从而减少内部引用计数。当计数减少到零时，最后一个 shared_ptr 的销毁触发底层内存的回收。与 unique_ptr 一样，也可以使用显式成员函数调用来手动管理内存。Josuttis [8] 提供了关于使用 shared_ptr 的机制的详细描述。与 unique_ptr 一样，必须小心不要混用指针类型。当然，除了与 weak_ptr 混合使用之外，还有这个规则的例外。此外，引用计数会带来时间和空间开销，因此在部署共享指针之前，读者应该熟悉这些权衡。</p>
<p>在设计考虑方面，shared_ptr 构造允许程序员在不直接跟踪对象所有权的情况下共享堆内存。对于计算器，按值传递事件数据并不是一个选择。因为事件数据对象存在于一个层次结构中，按值传递事件数据对象会导致切片。然而，使用原始指针（或引用）传递事件数据也会有问题，因为这些数据对象的生命周期在共享它们的类之间无法知晓。自然地，当发布者引发事件时，会分配内存。由于观察者可能希望在事件处理完成后保留内存，发布者不能在事件处理完成后简单地释放内存。此外，由于任何给定事件都可以调用多个观察者，因此发布者也不能将数据的唯一所有权转移给任何给定的观察者。因此，C++11 中标准化的 shared_ptr 提供了处理这种情况的理想语义。</p>
<hr>
<p>现在您了解了事件数据，让我们最后编写抽象观察者接口。不出所料，这正是您可能期望的。请参见清单 3-5。</p>
<p>清单 3-5 抽象观察者接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Observer</span><span class="params">(<span class="type">const</span> string&amp; name)</span></span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">(shared_ptr&lt;EventData&gt;)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-栈作为事件">3.3.2 栈作为事件</h3>
<p>构建栈的最后一步只是将所有的部分放在一起。清单 3-1 显示了栈作为单例。为了实现事件，我们只需修改这段代码，使其从 Publisher 基类继承。我们现在必须问自己，这种继承应该是公共的还是私有的？</p>
<p>通常，在面向对象编程中，使用公共继承来表示 is-a 关系。也就是说，公共继承表达了派生类是基类的类型或特化关系。更准确地说，is-a 关系遵循 Liskov 可替换原则（LSP）[29]，该原则规定（通过多态性）一个接受基类指针（引用）作为参数的函数必须能够在不知情的情况下接受派生类指针（引用）。简洁地说，派生类必须能在基类可以使用的地方互换使用。当人们提到继承时，他们通常指的是公共继承。</p>
<p>私有继承用于表示实现关系。简单地说，私有继承用于将一个类的实现嵌入到另一个类的私有实现中。它不遵循 LSP，实际上，如果继承关系是私有的，C++ 语言不允许将派生类替换为基类。为了完整起见，与私有继承关系密切相关的受保护继承在语义上与私有继承相同。唯一的区别是，在私有继承中，基类实现在派生类中变为私有，而在受保护继承中，基类实现在派生类中变为受保护。</p>
<p>我们的问题现在已经细化为，栈是发布者还是栈实现了发布者？答案是肯定的，肯定的。这个答案没有帮助，那么我们如何选择呢？</p>
<p>为了消除这个实例中我们应该使用公共继承还是私有继承的歧义，我们必须深入研究 Stack 类的使用。公共继承，或者说 is-a 关系，表示我们打算将栈多态地作为发布者使用。然而，情况并非如此。虽然 Stack 类是一个发布者，但它不是在可以用 LSP 意义上的发布者替代发布者的上下文中的发布者。因此，我们应该使用私有继承来表明在 Stack 中使用 Publisher 实现的意图。同样地，我们可以说 Stack 提供了 Publisher 服务。如果您一直在关注代码仓库的源代码，您可能已经注意到了私有继承是答案的一个大提示。Publisher 类使用了非虚拟的、受保护的析构函数进行实现，使其无法用于公共继承。</p>
<p>熟悉面向对象设计的读者可能会想知道为什么我没有问无处不在的 has-a 问题，这表示所有权或聚合关系。也就是说，为什么栈不仅仅拥有一个发布者并重用其实现，而不是从它私下继承呢？许多设计者几乎完全使用聚合来代替私有继承，认为在这两者之间有一个等价的选择时，应该总是优先使用导致松散耦合的语言特性（继承关系比聚合关系更强）。这种观点有一定的道理。不过，就我个人而言，我更愿意接受那种通过较强耦合换取更大清晰度的技术。我认为私有继承比聚合更清楚地表达了实现发布者服务的设计意图。这个决定没有对错之分。在你的代码中，你应该选择符合你口味的风格。</p>
<p>另一个从发布者类私有继承的结果是，发布者的 attach() 和 detach() 方法变为私有。然而，如果其他类打算订阅栈的事件，它们需要成为栈的公共接口的一部分。因此，实现者必须选择使用 using 语句或转发成员函数将 attach() 和 detach() 提升到栈的公共接口中。在这种情况下，这两种方法都是可以接受的，实现者可以根据自己的个人喜好来选择。</p>
<h3 id="3-3-3-完整的栈接口">3.3.3 完整的栈接口</h3>
<p>我们终于准备好编写完整的栈公共接口了。请参见列表 3-6。</p>
<p>列表 3-6 完整的栈公共接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> : <span class="keyword">private</span> Publisher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Stack&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">double</span>, <span class="type">bool</span> suppressChangeEvent = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">pop</span><span class="params">(<span class="type">bool</span> suppressChangeEvent = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swapTop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">getElements</span><span class="params">(<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">using</span> Publisher::attach;</span><br><span class="line">  <span class="keyword">using</span> Publisher::detach;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如本章所述，栈是一个单例类（注意 Instance() 方法），实现了发布者服务（注意发布者类的私有继承以及将 attach() 和 detach() 方法提升到公共接口中）。栈类的公共部分，结合列表 3-2 中描述的 EventData 类，包含了第二章表 2-2 中介绍的栈模块的完整接口。尽管我还没有描述任何具体的栈观察者，但我们已经为 pdCalc 完全定义了基于经过验证的观察者模式的事件系统。此时，我们准备设计 pdCalc 的下一个组件，命令调度器模块。</p>
<h2 id="3-4-关于测试的快速说明">3.4 关于测试的快速说明</h2>
<p>在本章结束介绍 pdCalc 的源代码之前，我应该花一点时间来谈谈测试。尽管测试绝非本书的核心探讨主题，但它仍然是任何高质量实现的一个不可或缺的部分。在 GitHub 上找到的计算器源代码旁边，我还包含了所有的自动化单元测试代码。因为我选择了 Qt 作为 pdCalc 的图形用户界面框架（参见第6章），因此 Qt 测试框架是构建 pdCalc 单元测试套件的自然选择。主要原因是这个选择不会给项目增加任何额外的库依赖，并且测试框架保证能在 Qt 移植的所有平台上工作。话虽如此，许多高质量的 C++ 单元测试框架中的任何一个都同样适用。</p>
<p>就我个人而言，即使是在编程小项目时，我也认为单元测试是不可或缺的。首先，单元测试为确保代码按预期功能提供了手段。其次，单元测试使你能够在开发用户界面之前就看到模块正确地工作。早期测试使得早期的错误检测成为可能，软件工程的一个众所周知的事实是，越早发现错误，修复错误的成本就越低。我还发现，在开发周期早期看到模块完全工作会产生一种奇怪的动力。最后，单元测试还使你能够知道代码在更改前后的功能是否相同。由于迭代是设计和实现的一个基本要素，你的代码将在你认为已经完成之后多次更改。在每次构建时自动运行全面的单元测试将确保新的更改没有不可预测地破坏任何现有的功能单元。</p>
<p>因为我非常重视测试（这是我在培训新的专业开发人员时尝试教授的第一课），所以我努力确保 pdCalc 代码的测试完整性。测试代码不仅为读者提供了一个范例（我希望如此），而且还让我确信在编写本书的代码开发部分期间我的代码是正确的。然而，尽管我尽最大努力编写无误的代码，即使在对源代码进行了无数次的审查之后，我仍然确信最终产品中仍然存在错误。请随时给我发送电子邮件报告您发现的任何错误。我将尽最大努力实时将更正内容合并到 GitHub 存储库中的代码，并对首位向我报告错误的读者表示感谢。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">漫艺海</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/">http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">漫艺海的blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Practical-C-Design-From-Programming-to-Architecture-1ed/">Practical C++ Design From Programming to Architecture 1ed</a></div><div class="post_share"><div class="social-share" data-image="/img/logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/1.Defining-the-Case-Study/" title="1. 定义案例研究"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">1. 定义案例研究</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/2.Decomposition/" title="2. 分解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2. 分解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/1.Defining-the-Case-Study/" title="1. 定义案例研究"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">1. 定义案例研究</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/" title="5. 命令行接口"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">5. 命令行接口</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/2.Decomposition/" title="2. 分解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">2. 分解</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/" title="4. 命令分发器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">4. 命令分发器</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/" title="8. 新的需求"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">8. 新的需求</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/6.The-Graphical-User-Interface/" title="6. 图形用户界面"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">6. 图形用户界面</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">漫艺海</div><div class="author-info__description">漫艺海的个人站，主要涉及C++知识共享、实践教程等方面</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">3. 堆栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A0%88%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%86%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">3.1 栈模块的分解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Stack%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">3.2 Stack类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.2.1 单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%A0%86%E6%A0%88%E6%A8%A1%E5%9D%97%E4%BD%9C%E4%B8%BA%E5%8D%95%E4%BE%8B%E7%B1%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">3.2.2 堆栈模块作为单例类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-1-Pimpl-%E4%B9%A0%E8%AF%AD"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">3.2.2.1 Pimpl 习语</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">3.3 添加事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.3.1 观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-1-%E6%94%B9%E8%BF%9B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.3.1.1 改进观察者模式实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-2-%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.3.1.2 处理事件数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%A0%88%E4%BD%9C%E4%B8%BA%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.3.2 栈作为事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E5%AE%8C%E6%95%B4%E7%9A%84%E6%A0%88%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3.3 完整的栈接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%85%B3%E4%BA%8E%E6%B5%8B%E8%AF%95%E7%9A%84%E5%BF%AB%E9%80%9F%E8%AF%B4%E6%98%8E"><span class="toc-number">1.4.</span> <span class="toc-text">3.4 关于测试的快速说明</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/27/CMake/cmake%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8qt%E7%9A%84windeployqt/" title="cmake配置自动调用qt的windeployqt">cmake配置自动调用qt的windeployqt</a><time datetime="2023-03-27T06:14:30.000Z" title="发表于 2023-03-27 14:14:30">2023-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/test/" title="9. 新的需求">9. 新的需求</a><time datetime="2023-03-26T12:29:12.427Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/" title="8. 新的需求">8. 新的需求</a><time datetime="2023-03-26T12:29:12.426Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/" title="7. 插件">7. 插件</a><time datetime="2023-03-26T12:29:12.426Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/" title="5. 命令行接口">5. 命令行接口</a><time datetime="2023-03-26T12:29:12.425Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 漫艺海</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">世上最幸运的事就是喜欢上一个人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>