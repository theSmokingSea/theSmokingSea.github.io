<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>5. 命令行接口 | 漫艺海的blog</title><meta name="author" content="漫艺海"><meta name="copyright" content="漫艺海"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="5. 命令行接口 这是一个非常令人兴奋的章节。虽然命令行界面（CLI）可能没有现代图形用户界面（GUI）的噱头，尤其是手机或平板电脑的界面，但 CLI 仍然是一种非常有用且有效的用户界面。本章详细介绍了 pdCalc 的命令行界面的设计和实现。到本章结束时，我们将首次拥有一个功能完善（尽管功能不完整）的计算器，这是我们开发过程中的一个重要里程碑。 5.1 用户界面抽象 虽然我们可以独立设计一个功能">
<meta property="og:type" content="article">
<meta property="og:title" content="5. 命令行接口">
<meta property="og:url" content="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/index.html">
<meta property="og:site_name" content="漫艺海的blog">
<meta property="og:description" content="5. 命令行接口 这是一个非常令人兴奋的章节。虽然命令行界面（CLI）可能没有现代图形用户界面（GUI）的噱头，尤其是手机或平板电脑的界面，但 CLI 仍然是一种非常有用且有效的用户界面。本章详细介绍了 pdCalc 的命令行界面的设计和实现。到本章结束时，我们将首次拥有一个功能完善（尽管功能不完整）的计算器，这是我们开发过程中的一个重要里程碑。 5.1 用户界面抽象 虽然我们可以独立设计一个功能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/logo.png">
<meta property="article:published_time" content="2023-03-26T12:29:12.425Z">
<meta property="article:modified_time" content="2023-03-26T12:29:12.425Z">
<meta property="article:author" content="漫艺海">
<meta property="article:tag" content="Practical C++ Design From Programming to Architecture 1ed">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/logo.png"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '5. 命令行接口',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-26 20:29:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="漫艺海的blog"><span class="site-name">漫艺海的blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">5. 命令行接口</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-26T12:29:12.425Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-26T12:29:12.425Z" title="更新于 2023-03-26 20:29:12">2023-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Qt/">Qt</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="5. 命令行接口"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>5. 命令行接口</h1>
<p>这是一个非常令人兴奋的章节。虽然命令行界面（CLI）可能没有现代图形用户界面（GUI）的噱头，尤其是手机或平板电脑的界面，但 CLI 仍然是一种非常有用且有效的用户界面。本章详细介绍了 pdCalc 的命令行界面的设计和实现。到本章结束时，我们将首次拥有一个功能完善（尽管功能不完整）的计算器，这是我们开发过程中的一个重要里程碑。</p>
<h2 id="5-1-用户界面抽象">5.1 用户界面抽象</h2>
<p>虽然我们可以独立设计一个功能完整的 CLI，但我们从需求中了解到，功能完整的计算器必须同时具有 CLI 和 GUI。因此，在首先考虑这两个界面之间的共性并将此功能分解为一个通用抽象之前，我们的整体设计将更好地满足需求。让我们考虑两种构建用户界面抽象的设计替代方案：自上而下的方法和自下而上的方法。</p>
<p>在考虑具体类型之前设计抽象接口类似于自上而下的设计。在用户界面方面，您首先考虑任何 UI 必须遵循的最基本要素，并根据这个最小化概念创建一个抽象接口。当抽象概念遗漏了实现具体类型所需的内容时，对接口的细化就变得必要。</p>
<p>在考虑具体类型之后设计抽象接口类似于自下而上的设计。再次以用户界面为例，您首先考虑所有具体类型的需求（在这种情况下是 CLI 和 GUI），寻找所有类型之间的共性，然后将公共特性提炼为一个抽象。当添加一个需要在最初提炼抽象时未考虑的额外功能的新具体类型时，对接口的细化变得必要。</p>
<p>一般来说，哪种策略更适合创建抽象接口：自上而下还是自下而上？通常情况下，答案取决于特定情况、个人舒适度和风格。在这个特定场景中，我们最好从抽象开始，然后向具体类型（自上而下方法）深入。为什么？在这种情况下，自上而下的方法基本上是免费的。用户界面是 pdCalc 的高级模块之一，在第 2 章中，我们在进行初始分解时已经定义了 UI 的抽象接口。现在让我们将抽象模块接口转化为实用的面向对象设计。</p>
<h3 id="5-1-1-抽象接口">5.1.1 抽象接口</h3>
<p>为 UI 提供一个抽象接口的目的是让程序的其他部分与用户界面进行交互，而无需关心当前界面是图形界面、命令行界面还是其他完全不同的界面。理想情况下，我们将能够将抽象接口提炼为使用每个具体接口所需的最少函数数量。任何共享实现的函数可以在基类中定义，而任何需要基于具体类型的唯一实现的函数可以在抽象基类中声明为虚拟函数，并在派生类中定义。这个概念相当简单，但通常情况下，问题在于细节。</p>
<p>考虑图 5-1 所示的层次结构。我们的目标是设计一个简洁而完整的接口，符合 Liskov 替换原则，适用于 pdCalc 的 UserInterface 类，既适用于 CLI，也适用于 GUI。正如前面所讨论的，我们已经在第 2 章中为此 UI 定义了一个高级接口。让我们从这个预定义的接口开始，根据需要进行重构。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/A454125_1_En_5_Fig1_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
       图 5-1 最小接口层次结构
  	</div>
</center>
<p>参考第 2 章中的表 2-2，您会发现 UserInterface 类的完整接口由两个事件处理函数 postMessage() 和 stackChanged() 以及一个 UserInterface 触发的事件 commandEntered() 组成。有趣的是，UserInterface 类既是发布者，又是观察者，还是一个抽象用户界面。</p>
<p>在接口级别，两个事件处理函数 postMessage() 和 stackChanged() 非常简单。就像我们在之前的观察者中所做的那样，我们将简单地将这两个函数添加到 UserInterface 类的公共接口中，并创建代理观察者类来代理发布者和实际观察者之间的通信。这些代理在下面的 5.1.2.2 节中详细讨论。具体的用户界面必须根据各个 UI 与用户的交互方式，为事件处理提供唯一的实现。因此，postMessage() 和 stackChanged() 都必须是纯虚函数。由于 UserInterface 类在事件处理过程中没有插入的必要，为了简单起见，我选择放弃 NVI 模式。然而，正如第 4 章中所讨论的，人们也可以使用带有简单转发非虚拟接口函数的 NVI 模式。</p>
<p>UserInterface 类作为发布者的角色比作为观察者的角色稍显复杂。正如您在第 3 章设计 Stack 类时所看到的，Stack 实现了发布者接口，而不是替代作为发布者。因此，我们得出的结论是，应该从 Publisher 类进行私有继承。对于 UserInterface 类，与 Publisher 类的关系类似，只是 UserInterface 类本身不是发布者。UserInterface 类是系统中用户界面的抽象接口，并从 Publisher 类继承，只是为了强制用户界面必须自己实现发布者接口。CLI 和 GUI 类都需要访问 Publisher 的公共函数（例如，引发事件）。因此，在这种情况下，受保护的继承方式是合适的。</p>
<p>进一步回顾第 3 章，为了让 Stack 类实现发布者接口，我们使用私有继承后，需要将 Publisher 类的 attach() 和 detach() 函数提升到 Stack 的公共接口中。在这里使用受保护继承也是如此。然而，问题是，提升应该发生在 UserInterface 类还是它的派生类中？要回答这个问题，我们需要了解 pdCalc 如何使用特定的用户界面。显然，CLI 或 GUI 都是 UserInterface。因此，具体的用户界面将公开继承自 UserInterface 并被期望遵循 LSP。在不了解底层 UI 类型的情况下，必须能够附加或分离特定用户界面的事件。因此，attach() 和 detach() 函数必须作为 UserInterface 公共接口的一部分可见。有趣的是，在观察者模式的一个相当独特的实现中，发布者接口的一部分是在 UserInterface 层次实现的，而另一部分发布者接口是在派生类层次实现的。</p>
<p>综合以上所有观点，我们最终可以定义 UserInterface 类，如 Listing 5-1 所示。</p>
<p>Listing 5-1 UserInterface 类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserInterface</span> : <span class="keyword">protected</span> Publisher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">UserInterface</span>();</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">UserInterface</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">postMessage</span><span class="params">(<span class="type">const</span> string&amp; m)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stackChanged</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">using</span> Publisher::attach;</span><br><span class="line">  <span class="keyword">using</span> Publisher::detach;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> string CommandEntered;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>CommandEntered 字符串是已输入命令事件的名称。它需要用于附加或分离此事件，并可以给出 UserInterface 类中事件的任何唯一名称。</p>
<p>为了完整起见，我在图 5-2 中展示了最终的用户界面层次结构。类图说明了 CLI、GUI、抽象 UserInterface 类和发布者接口之间的关系。请记住，UserInterface 类和 Publisher 类之间的继承是受保护的，因此 UserInterface（或后续派生类）不能用作 Publisher。然而，正如前面所述，具体 CLI 和 GUI 类与抽象 UserInterface 类之间继承的意图是公开的，允许实例化任何具体类型作为 UserInterface 进行替换。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/A454125_1_En_5_Fig2_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
       图 5-2 用户界面层次结构
  	</div>
</center>
<h3 id="5-1-2-用户界面事件">5.1.2 用户界面事件</h3>
<p>定义 UserInterface 类并未完成 UI 的接口。由于 UserInterface 类是一个事件发布者，我们还必须定义与 commandEntered() 事件相对应的事件数据类。此外，定义 UserInterface 类最终完成了发布者/观察者对，因此我们终于准备好设计和实现事件代理类，以协调用户界面与命令调度器和堆栈之间的事件。</p>
<p>在第 4 章中，你看到所有命令都通过事件传递给命令调度器。具体来说，UI 引发包含特定命令的事件，该命令以字符串参数的形式编码，CommandDispatcher 接收此事件，然后将字符串参数传递给 CommandRepository，从中检索具体命令进行处理。就命令调度器而言，处理 commandEntered() 事件是相同的，无论编码的命令字符串是来自 CLI 还是 GUI。</p>
<p>同样，当 Stack 类引发 stackChanged() 事件时，Stack 对处理此事件的特定 UserInterface 是漠不关心的。因此，我们有动力在用户界面层次结构中的 UserInterface 类级别统一处理 commandEntered() 事件的发出和 stackChanged() 事件的处理。</p>
<p>我们首先检查引发 commandEntered() 事件的公共基础设施。在 UserInterface 类的构造函数中，已为所有用户界面注册了 commandEntered() 事件。因此，任何派生的用户界面类都可以通过调用由 Publisher 接口定义的 raise() 函数简单地引发此事件，这通过受保护的继承是任何具体 UI 实现的一部分。 raise() 函数的签名要求事件的名称和事件的数据。由于事件的名称是在 UserInterface 的构造函数中预定义的，因此引发命令输入事件所需的额外功能只是一个通用的 CommandData 类。现在让我们看一下它的设计。</p>
<h4 id="5-1-2-1-命令数据">5.1.2.1 命令数据</h4>
<p>在第 3 章中，我们设计了我们的事件系统，以使用推送语义传递事件数据。回想一下，推送语义只是指发布者创建一个包含处理事件所需信息的对象，并在事件触发时将该对象推送给观察者。事件数据对象必须公开继承自抽象的 EventData 类。观察者在事件触发时通过抽象接口接收事件数据，并通过将事件数据向下转换为适当的派生类来检索数据。</p>
<p>对于已输入的命令事件，事件数据只是一个字符串，包含要在堆栈上输入的数字或要发出的命令的名称。CommandData 类只需要在构造时接受一个字符串命令，存储此命令，并为观察者提供一个函数来检索命令。完整实现在 Listing 5-2 中给出。</p>
<p>Listing 5-2 CommandData 类的完整实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandData</span> : <span class="keyword">public</span> EventData</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CommandData</span>(<span class="type">const</span> string&amp; s) : <span class="built_in">command_</span>(s) &#123; &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">command</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> command_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string command_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>尽管 CLI 和 GUI 中确定如何以及何时引发 CommandEntered 事件的机制有所不同，但它们最终都是通过调用具有编码特定命令的 CommandData 参数的 Publisher 的 raise() 函数来引发事件。也就是说，对于某个命令字符串 cmd，以下代码在 CLI、GUI 或可能继承自 UserInterface 的任何其他用户界面中引发 commandEntered() 事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">raise</span>( UserInterface::CommandEntered, <span class="built_in">make_shared</span>&lt;CommandData&gt;(cmd) );</span><br></pre></td></tr></table></figure>
<p>现在我们可以引发 UI 事件了，让我们看看它们是如何处理的。</p>
<h4 id="5-1-2-2-用户界面观察者">5.1.2.2 用户界面观察者</h4>
<p>本小节的目标是构建机制，使类能够监听事件。由于抽象用户界面既是事件的来源又是事件的接收器，因此 UI 可作为演示发布者和观察者如何相互作用的理想候选者。</p>
<p>在第3章中，我们了解到观察者是注册并监听发布者引发的事件的类。到目前为止，我们已经遇到了 CommandDispatcher 和 UserInterface 类，这两个类都需要观察事件。尽管可以直接使 CommandDispatcher 或 UserInterface 成为观察者，但我更喜欢在发布者和需要观察事件的类之间构建一个专用的观察者中介。我经常模糊地将这个中介称为代理。现在我准备给这个术语一个更具体的含义。</p>
<p>代理模式[6]是一种设计模式，它使用一个类，即代理，作为其他东西的接口。这个其他东西，我们称之为目标，没有严格定义。它可以是网络连接、文件、内存中的对象，或者像我们这种情况下，仅仅是另一个类。通常，当底层目标不可能、不方便或昂贵复制时，会使用代理模式。代理模式使用类缓冲区，使系统将目标视为独立于其底层组成的对象。在我们的上下文中，我们只是使用代理模式来缓冲发布者和观察者之间的通信。</p>
<p>为什么我们在这里要费心使用代理模式？这种策略有几个明显的优势。首先，它通过用一个描述性的事件处理函数替换泛型的 notify() 函数，增加了目标类公共接口的清晰度。其次，从 Observer 类中删除了不必要的继承。消除这种依赖关系可以减少耦合，增加内聚，并促进在非观察者环境中重用目标。第三，使用代理类消除了目标类需要监听多个事件时产生的歧义。如果不使用代理类，观察者将需要在其单一的 notify() 函数中区分事件。对于每个事件使用单独的代理，使得每个事件能调用目标对象中的唯一处理函数。使用代理实现观察者模式的主要缺点是处理每个事件的额外间接成本略有增加。然而，在使用观察者模式适当的情况下，额外的间接成本可以忽略不计。</p>
<p>使用代理模式实现观察者模式导致了以下两个用于处理 commandEntered() 和 stackChanged() 事件的类：分别是 CommandIssuedObserver 和 StackUpdatedObserver。CommandIssuedObserver 在 UI 引发的 commandEntered() 事件和命令调度器中的观察之间进行调解。StackUpdatedObserver 在栈引发的 stackChanged() 事件和 UI 中的观察之间进行调解。这两个类的实现都相对简单且非常相似。举个例子，让我们来看一下 CommandIssuedObserver 的实现。请参见清单 5-3。</p>
<p>清单 5-3 CommandIssuedObserver 的声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandIssuedObserver</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CommandIssuedObserver</span>(CommandDispatcher&amp; ce);</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">notifyImpl</span><span class="params">(shared_ptr&lt;EventData&gt;)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  CommandDispatcher&amp; ce_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于它在 UI 作为发布者和 CommandDispatcher 作为观察者目标之间调解事件，CommandIssuedObserver 的构造函数需要一个 CommandDispatcher 实例的引用，当 UI 引发 commandEntered() 事件时，它保留该引用以回调命令调度器。请记住，当观察者附加到事件时，CommandIssuedObserver 将存储在发布者的事件符号表中。notifyImpl() 的实现只是对 EventData 参数进行动态转换为特定的 CommandData 实例，然后调用 CommandDispatcher 的 commandEntered() 函数。</p>
<p>当然，在触发事件之前，必须向 UI 注册 CommandIssuedObserver。为了完整起见，以下代码说明了如何完成此任务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ui.<span class="built_in">attach</span>( UserInterface::CommandEntered,</span><br><span class="line">  <span class="built_in">make_unique</span>&lt;CommandIssuedObserver&gt;(ce) );</span><br></pre></td></tr></table></figure>
<p>其中ui是一个UserInterface引用。注意，由于attach()函数有意地提升到抽象UserInterface范围，因此通过引用附加可以让我们对CLI和GUI重用相同的调用。也就是说，通过抽象UI接口完成事件的注册，这大大简化了pdCalc的main()例程中的用户界面设置。StackUpdatedObserver的声明和注册是类似的。</p>
<p>观察者代理类的完整实现可以在AppObservers.cpp中找到。尽管观察者代理的使用与事件观察类相互交织，但代理不是目标类接口的一部分。因此，它们被包含在它们自己的文件中。代理附加到事件是在main.cpp中执行的。这种代码结构保持了发布者和观察者之间的松散绑定。具体而言，发布者知道他们可以引发哪些事件，但不知道谁会观察它们，而观察者知道他们将观察哪些事件，但不知道谁会引发它们。发布者和观察者之外的代码将两者绑定在一起。</p>
<h2 id="5-2-具体的CLI类">5.2 具体的CLI类</h2>
<p>本章剩余部分将详细介绍CLI具体类。让我们从重新审视CLI的需求开始。</p>
<h3 id="5-2-1-需求">5.2.1 需求</h3>
<p>pdCalc的需求表明，计算器必须具有命令行界面，但是，CLI到底是什么呢？我对命令行界面的定义是任何通过文本与用户交互地响应用户命令的程序的用户界面。即使您对命令行界面的定义有所不同，我相信我们可以肯定地说，一个简单地指示程序应该有CLI的宽泛要求是非常不足够的。</p>
<p>在生产开发环境中，当你遇到一个设计组件过于模糊的需求时，你应该立即向客户寻求澄清。注意我说的是何时而不是如果。无论你在前期花多少精力尝试完善需求，你总是会遇到不完整的、不一致的或者不断变化的需求。这通常是由于以下几个原因。有时，这是因为有意识地不花时间在前期完善需求。有时，这是因为没有经验的团队成员不了解如何正确收集需求。然而，通常情况下，这是因为终端用户在产品开始成型之前并不知道他或她真正想要或需要什么。即使对于我自己是客户的小型开发项目，我也发现这是真实的！虽然作为实现者，您总是可以在不与客户交流的情况下完善需求，但我的经验表明，这条路总是不可避免地导致代码的反复重写：一次是为了你认为用户想要的，一次是为了用户认为他想要的，还有一次是为了用户真正想要的。</p>
<p>显然，在我们的案例研究中，我们只有一个假设的终端用户，所以我们只需自己进行完善。我们指定以下内容：</p>
<ol>
<li class="lvl-3">
<p>CLI应该接受计算器定义的任何命令的文本命令（存在于命令仓库中的命令，以及撤消、重做、帮助和退出）。</p>
</li>
<li class="lvl-3">
<p>help命令应显示所有可用命令的列表和一个简短的解释性消息。</p>
</li>
<li class="lvl-3">
<p>CLI应该接受按照它们应该被处理的顺序用空格分隔的命令。回想一下，这个顺序对应于逆波兰表示法。在按下回车键后处理一行上的所有命令。</p>
</li>
<li class="lvl-3">
<p>在处理命令后，界面应显示栈顶部最多四个元素以及栈的当前大小。</p>
</li>
</ol>
<p>令人惊讶的是，上面列出的最小要求足以构建一个简单的CLI。虽然这些要求有些武断，但为了描述设计和实现，需要选择具体的内容。如果你不喜欢生成的CLI，我强烈建议你制定自己的需求，并相应地修改设计和实现。</p>
<h3 id="5-2-2-CLI设计">5.2.2 CLI设计</h3>
<p>CLI的设计非常简单。因为我们整体的架构设计将计算器的整个“业务逻辑”放在了后端，前端只是一个很薄的层，除了接受和对用户输入进行标记化处理、将输入依次传递给控制器并显示结果之外，没有其他功能。让我们从描述接口开始。</p>
<h4 id="5-2-2-1-接口">5.2.2.1 接口</h4>
<p>从本章前面的分析中，我们知道具体的CLI类将继承自抽象UserInterface类。这种继承是公共的，因为CLI“是一个”UserInterface，并且必须作为一个替代。因此，CLI必须实现UserInterface的两个抽象纯虚函数，postMessage()和stackChanged()。这两个方法只通过UserInterface引用多态地调用；因此，这两个方法都成为了CLI的私有接口。除了构造和销毁，CLI需要公开暴露的唯一功能是启动其执行的命令。这个函数驱动整个CLI，只有在用户请求退出程序时才返回（通常）。将上述内容结合起来，CLI的整个接口可以通过列表5-4中的代码给出。</p>
<p>列表5-4 CLI的全部接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cli</span> : <span class="keyword">public</span> UserInterface</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">CliImpl</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cli</span>(istream&amp; in, ostream&amp; out);</span><br><span class="line">  ~<span class="built_in">Cli</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">bool</span> suppressStartupMessage = <span class="literal">false</span>, <span class="type">bool</span> echo = <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">postMessage</span><span class="params">(<span class="type">const</span> string&amp; m)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stackChanged</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  unique_ptr&lt;CliImpl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虽然接口主要是自解释的，但构造函数和execute()函数的参数值得解释。为了满足上述要求，可以编写一个没有参数的execute()函数。接口中包含的这两个参数只是可以打开的可选功能。第一个参数决定CLI启动时是否显示横幅。第二个参数控制命令回显。如果将回显设置为true，则在显示结果之前重复每个命令。这两个功能可以在CLI中硬编码，但我选择将它们作为execute()方法的参数以增加灵活性。</p>
<p>构造函数的参数稍微不那么明显，与execute()命令的参数不同。几乎可以肯定，CLI从cin接收输入并将结果输出到cout或者cerr。然而，将这些标准I/O流硬编码会任意限制这个类的用途，使其仅限于传统的CLI。通常，我主张将功能限制在你确切需要的范围内，而不是预期更通用的用途。然而，使用C++流I/O是我对这个经验法则的少数例外。</p>
<p>让我们讨论为什么在C++ I/O流中使用基类引用通常是一个好的设计实践。首先，使用不同的I/O模式的需求相当普遍。具体而言，重定向到文件或从文件中重定向是CLI经常要求修改的。实际上，你会在第8章看到这个请求！其次，实现通用与特定接口几乎不增加复杂性。例如，不是直接写入cout，而是保留一个输出流引用并改为写入该引用。在基本情况下，此引用仅指向cout。最后，使用任意流输入和输出大大简化了测试。虽然程序可能使用cin和cout实例化Cli类，但测试可以使用文件流或字符串流实例化Cli类。通过这种方式，可以使用字符串或文件模拟交互式流输入和输出。这种策略简化了Cli类的测试，因为输入可以很容易地传入，输出可以很容易地捕获为字符串，而不是通过标准输入和输出。</p>
<h4 id="5-2-2-2-实现">5.2.2.2 实现</h4>
<p>值得研究Cli类的实现，以观察pdCalc设计的模块化所带来的简单性。Cli类的整个实现实际上包含在execute()和postMessage()成员函数中。execute()函数驱动CLI。它向最终用户展示启动消息，等待输入命令，对这些命令进行标记化处理，并发出事件以通知命令调度器已输入新命令。stackChanged()函数是一个观察者代理回调目标，在触发stackChanged()事件后将堆栈顶部写入命令行。本质上，CLI可以简化为两个I/O例程，其中execute()处理输入，stackChanged()处理输出。让我们从列表5-5中显示的execute()函数开始，看看这两个函数的实现。</p>
<p>列表5-5 execute()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> Cli::CliImpl::<span class="built_in">execute</span>(<span class="type">bool</span> suppressStartupMessage, <span class="type">bool</span> echo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!suppressStartupMessage) <span class="built_in">startupMessage</span>();</span><br><span class="line">  <span class="keyword">for</span>(string line; <span class="built_in">getline</span>(in_, line, <span class="string">&#x27;\n&#x27;</span>);)</span><br><span class="line">  &#123;</span><br><span class="line">    Tokenizer tokenizer&#123;line&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; i : tokenizer)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(echo) out_ &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="string">&quot;exit&quot;</span> || i == <span class="string">&quot;quit&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        parent_.<span class="built_in">raise</span>( CommandEntered, <span class="built_in">make_shared</span>&lt;CommandData&gt;(i) );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CLI的主要算法相当简单。首先，CLI等待用户输入一行。然后，由Tokenizer类对这个输入行进行标记处理。然后，CLI在输入行中的每个标记上循环，并使用标记字符串作为事件的数据发出事件。当CLI遇到退出或退出标记时，它会终止。</p>
<p>在execute()函数中尚未解释的部分是Tokenizer类。简单地说，Tokenizer类负责接收一段文本字符串，并将该字符串拆分为独立的空格分隔的标记。CLI和Tokenizer都不确定标记的有效性。标记只是作为事件触发，由命令调度器处理。值得注意的是，作为编写自己的替代方法，许多库（例如boost）提供了简单的分词器。</p>
<p>考虑到分词算法的简单性（请参阅Tokenizer.cpp中的实现），为什么我要将Tokenizer设计为一个类，而不是一个返回字符串向量的函数？实际上，这两种设计在功能上都可行，而且两种设计都很容易测试和维护。然而，我更喜欢类设计，因为它为Tokenizer提供了一个独特的类型。让我们来看一下为标记化创建一个独特类型的优点。</p>
<p>假设我们想要在函数foo()中对输入进行标记化处理，但在另一个函数bar()中处理标记。考虑以下两个可能的函数对来实现这个目标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use a Tokenizer class</span></span><br><span class="line"><span class="function">Tokenizer <span class="title">foo</span><span class="params">(<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> Tokenizer&amp;)</span></span>;</span><br><span class="line"><span class="comment">// use a vector of strings</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">foo</span><span class="params">(<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>首先，使用Tokenizer类，foo()和bar()的签名立即告诉程序员这些函数的意图。我们知道这些函数涉及到标记化。使用字符串向量会在没有进一步文档的情况下留下歧义（我故意没有为参数提供名称）。更重要的是，输入标记器使编译器确保bar()只能使用一个Tokenizer类作为参数，从而防止程序员不小心用一个无关的字符串集合调用bar()。类设计的另一个好处是，Tokenizer类封装了表示标记集合的数据结构。这种封装保护了bar()的接口，免受更改底层数据结构的决定（例如，从字符串向量更改为字符串列表）。最后，Tokenizer类可以封装关于标记化的其他状态信息（例如，原始的、未标记化的输入），如果需要的话。显然，字符串集合仅限于携带标记本身。</p>
<p>现在让我们来看一下stackChanged()函数的简化实现，如Listing 5-6所示。</p>
<p>Listing 5-6 stackChanged函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> Cli::CliImpl::<span class="built_in">stackChanged</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nElements&#123;<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> v = Stack::<span class="built_in">Instance</span>().<span class="built_in">getElements</span>(nElements);</span><br><span class="line">  ostringstream oss;</span><br><span class="line">  <span class="type">size_t</span> size = Stack::<span class="built_in">Instance</span>().<span class="built_in">size</span>();</span><br><span class="line">  oss &lt;&lt; <span class="string">&quot;stack\n&quot;</span>;</span><br><span class="line">  <span class="type">size_t</span> j&#123; v. <span class="built_in">size</span>() &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> i = v.<span class="built_in">rbegin</span>(); i != v.<span class="built_in">rend</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    oss &lt;&lt; j &lt;&lt; <span class="string">&quot;:\t&quot;</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    --j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">postMessage</span>( oss. <span class="built_in">str</span>() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cli.cpp中的实现仅在打印的繁琐程度上有所不同。请注意，每当堆栈发生变化时，CLI只需选择堆栈顶部的四个条目（如我们的要求所述）（getElements()返回nElements和堆栈大小的最小值），将它们格式化到ostringstream中，然后将一个字符串消息传递给postMessage()函数。对于CLI，postMessage()只需将字符串写入输出流。</p>
<p>在继续之前，让我们暂停并反思CLI实现的简洁和简明。这种简单性是pdCalc整体设计的直接结果。虽然许多用户界面将业务逻辑与显示代码混合在一起，但我们精心设计了这两个层次以实现独立性。命令的解释和处理（业务逻辑）完全位于命令调度器中。因此，CLI只负责接受命令、标记化命令和报告结果。此外，根据我们的事件系统设计，CLI与命令调度器之间没有直接耦合，这是符合我们MVC架构的决策。命令调度器确实与用户界面有直接联系，但由于我们的抽象，命令调度器绑定到一个抽象的UserInterface，而不是一个特定的用户界面实现。这样，Cli可以完美地替代UserInterface（LSP的应用），并可以轻松地作为计算器的许多独特视图之一进行交换。虽然这种灵活性可能看起来对于计算器的设计来说有些过分，但所有组件的模块化对于测试和关注点分离来说都是有益的，即使计算器没有计划使用另一个用户界面。</p>
<h2 id="5-3-整合：一个可运行的程序">5.3 整合：一个可运行的程序</h2>
<p>在结束本章关于CLI的讨论之前，编写一个简单的主程序将所有组件连接在一起以展示一个可运行的计算器是值得的。pdCalc的实际实现在main.cpp中要复杂得多，因为它处理多个用户界面和插件。最终，我们将逐步了解main.cpp中的完整实现，但现在，Listing 5-7中的代码将使我们能够使用命令行界面执行一个可运行的计算器（当然，包括适当的头文件）：</p>
<p>Listing 5-7 一个可运行的计算器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Cli cli&#123;cin, cout&#125;;</span><br><span class="line">  CommandDispatcher ce&#123;cli&#125;;</span><br><span class="line">  <span class="built_in">RegisterCoreCommands</span>(cli);</span><br><span class="line">  cli.<span class="built_in">attach</span>( UserInterface::CommandEntered,</span><br><span class="line">    <span class="built_in">make_unique</span>&lt;CommandIssuedObserver&gt;(ce) );</span><br><span class="line">  Stack::<span class="built_in">Instance</span>().<span class="built_in">attach</span>( Stack::StackChanged,</span><br><span class="line">    <span class="built_in">make_unique</span>&lt;StackUpdatedObserver&gt;(cli) );</span><br><span class="line">  cli.<span class="built_in">execute</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于设计的模块化，整个计算器可以通过仅仅六个可执行语句来设置、组装和执行！main() 函数中的逻辑非常容易理解。从维护的角度来看，项目中的任何新程序员都可以轻松地追踪计算器的逻辑，并看到每个模块的功能都被清晰地划分为不同的抽象。在后续章节中，将看到随着模块数量的增加，抽象变得更加强大。</p>
<p>为了让您快速开始，仓库源代码中包含了一个项目，该项目使用上述 main() 函数作为应用程序的驱动程序构建一个可执行文件，pdCalc-simple-cli。该可执行文件是一个独立的 CLI，包含了到目前为止在本书中讨论的所有功能。</p>
<p>在下一章中，我们将考虑设计计算器的图形用户界面。一旦 GUI 完成，许多用户会很快将 CLI 视为一个练习或者是过去时代的遗物。在此之前，我想鼓励读者不要过于快速地评判谦逊的 CLI。CLI 是非常高效的接口，而且通常在需要大规模部署或自动化的任务中编写脚本更为简便。就 pdCalc 而言，我个人更喜欢 CLI 而不是 GUI，因为它更易于使用。当然，也许这只是表明我也是过去时代的遗物。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">漫艺海</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/">http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">漫艺海的blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Practical-C-Design-From-Programming-to-Architecture-1ed/">Practical C++ Design From Programming to Architecture 1ed</a></div><div class="post_share"><div class="social-share" data-image="/img/logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/" title="7. 插件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">7. 插件</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/6.The-Graphical-User-Interface/" title="6. 图形用户界面"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">6. 图形用户界面</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/1.Defining-the-Case-Study/" title="1. 定义案例研究"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">1. 定义案例研究</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/" title="3. 堆栈"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">3. 堆栈</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/2.Decomposition/" title="2. 分解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">2. 分解</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/" title="4. 命令分发器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">4. 命令分发器</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/" title="8. 新的需求"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">8. 新的需求</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/6.The-Graphical-User-Interface/" title="6. 图形用户界面"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">6. 图形用户界面</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">漫艺海</div><div class="author-info__description">漫艺海的个人站，主要涉及C++知识共享、实践教程等方面</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">5. 命令行接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">5.1 用户界面抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E6%8A%BD%E8%B1%A1%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">5.1.1 抽象接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">5.1.2 用户界面事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-1-%E5%91%BD%E4%BB%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">5.1.2.1 命令数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-2-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%A7%82%E5%AF%9F%E8%80%85"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">5.1.2.2 用户界面观察者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%85%B7%E4%BD%93%E7%9A%84CLI%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">5.2 具体的CLI类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E9%9C%80%E6%B1%82"><span class="toc-number">1.2.1.</span> <span class="toc-text">5.2.1 需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-CLI%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.2.</span> <span class="toc-text">5.2.2 CLI设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-1-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">5.2.2.1 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-2-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">5.2.2.2 实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%95%B4%E5%90%88%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">5.3 整合：一个可运行的程序</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/27/CMake/cmake%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8qt%E7%9A%84windeployqt/" title="cmake配置自动调用qt的windeployqt">cmake配置自动调用qt的windeployqt</a><time datetime="2023-03-27T06:14:30.000Z" title="发表于 2023-03-27 14:14:30">2023-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/test/" title="9. 新的需求">9. 新的需求</a><time datetime="2023-03-26T12:29:12.427Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/" title="8. 新的需求">8. 新的需求</a><time datetime="2023-03-26T12:29:12.426Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/" title="7. 插件">7. 插件</a><time datetime="2023-03-26T12:29:12.426Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/" title="5. 命令行接口">5. 命令行接口</a><time datetime="2023-03-26T12:29:12.425Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 漫艺海</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">世上最幸运的事就是喜欢上一个人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>