<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>7. 插件 | 漫艺海的blog</title><meta name="author" content="漫艺海"><meta name="copyright" content="漫艺海"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="7. 插件 您可能已经读过本章的标题，所以您已经知道这一章是关于插件的，具体来说是关于插件的设计和实现。此外，插件还将为我们提供一个机会，让我们探讨隔离平台特定功能的设计技巧。然而，在深入了解细节之前，让我们先定义一下插件是什么。 7.1 什么是插件？ 插件是一种软件组件，使得在程序的初始编译之后向程序添加新功能成为可能。在这一章中，我们将专注于运行时插件，也就是以共享库（例如，POSIX .so">
<meta property="og:type" content="article">
<meta property="og:title" content="7. 插件">
<meta property="og:url" content="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/index.html">
<meta property="og:site_name" content="漫艺海的blog">
<meta property="og:description" content="7. 插件 您可能已经读过本章的标题，所以您已经知道这一章是关于插件的，具体来说是关于插件的设计和实现。此外，插件还将为我们提供一个机会，让我们探讨隔离平台特定功能的设计技巧。然而，在深入了解细节之前，让我们先定义一下插件是什么。 7.1 什么是插件？ 插件是一种软件组件，使得在程序的初始编译之后向程序添加新功能成为可能。在这一章中，我们将专注于运行时插件，也就是以共享库（例如，POSIX .so">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/logo.png">
<meta property="article:published_time" content="2023-03-26T12:29:12.426Z">
<meta property="article:modified_time" content="2023-03-26T12:29:12.426Z">
<meta property="article:author" content="漫艺海">
<meta property="article:tag" content="Practical C++ Design From Programming to Architecture 1ed">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/logo.png"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '7. 插件',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-26 20:29:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="漫艺海的blog"><span class="site-name">漫艺海的blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">7. 插件</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-26T12:29:12.426Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-26T12:29:12.426Z" title="更新于 2023-03-26 20:29:12">2023-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Qt/">Qt</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="7. 插件"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>7. 插件</h1>
<p>您可能已经读过本章的标题，所以您已经知道这一章是关于插件的，具体来说是关于插件的设计和实现。此外，插件还将为我们提供一个机会，让我们探讨隔离平台特定功能的设计技巧。然而，在深入了解细节之前，让我们先定义一下插件是什么。</p>
<h2 id="7-1-什么是插件？">7.1 什么是插件？</h2>
<p>插件是一种软件组件，使得在程序的初始编译之后向程序添加新功能成为可能。在这一章中，我们将专注于运行时插件，也就是以共享库（例如，POSIX .so 或 Windows .dll 文件）的形式构建的、在运行时可以发现和加载的插件。</p>
<p>插件在应用程序中有很多不同的用途。这里只列举了一些例子。首先，插件允许最终用户在不需要重新编译的情况下为现有程序添加功能。通常，这些是原始应用程序开发者完全没有预料到的新功能。其次，在架构上，插件使得程序可以分成多个可选的部分，这些部分可以单独与程序一起发布。例如，考虑一个程序（如网络浏览器），它附带一些基本功能，但允许用户添加特殊功能（如广告拦截器）。第三，插件可以用于设计一个可以根据特定客户进行定制的应用程序。例如，考虑一个电子健康记录系统，根据软件部署在医院还是医生的个人诊所，需要不同的功能。不同的模块可以通过插件形式捕获必要的定制，并插入核心系统。当然，还可以想到许多其他插件的应用场景。</p>
<p>在 pdCalc 的上下文中，插件是提供新计算器命令的共享库，以及可选的新 GUI 按钮。这个任务有多困难？在第 4 章中，我们创建了许多命令，并发现添加新命令相当简单。我们只需从 Command 类（或其派生类，如 UnaryCommand 或 BinaryCommand）继承，实例化命令，并将其注册到 CommandRepository。例如，正弦命令在 CoreCommands.h 中声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sine</span> : <span class="keyword">public</span> UnaryCommand &#123;</span><br><span class="line">    <span class="comment">// implement Command virtual members</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>并在 CoreCommands.cpp 中通过以下行注册</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">registerCommand</span>( ui, <span class="string">&quot;sin&quot;</span>, <span class="built_in">MakeCommandPtr</span>&lt;Sine&gt;() );</span><br></pre></td></tr></table></figure>
<p>结果证明，插件命令几乎可以完全按照这个配方进行，除了一个关键步骤。由于在编译时 pdCalc 不知道插件命令的类名，我们无法使用插件类的名称进行分配。</p>
<p>这个看似简单的难题导致了我们需要为插件解决的第一个问题。具体来说，我们需要建立一个抽象接口，使得插件命令可以被 pdCalc 发现并在其中注册。一旦我们就插件接口达成一致，我们将迅速遇到第二个基本的插件问题，即如何动态加载一个插件，甚至让共享库中的名称对 pdCalc 可用。为了使我们的生活更加复杂，这第二个问题的解决方案取决于平台，所以我们将寻求一种尽量减少平台依赖痛苦的设计策略。我们将遇到的最后一个问题是动态更新现有代码以添加新命令和按钮。也许令人惊讶的是，这最后一个问题是最容易解决的。然而，在我们开始解决这三个问题之前，我们需要考虑一下 C++ 插件的一些规则。</p>
<h3 id="7-1-1-C-插件的规则">7.1.1 C++ 插件的规则</h3>
<p>插件在概念上并不是 C++ 语言的一部分。相反，插件是操作系统动态加载和链接共享库的体现（因此插件的平台特性）。对于任何非平凡大小的项目，应用程序通常被划分为一个可执行文件和几个共享库（传统上，在 Unix 中是 .so 文件，在 Mac OS X 中是 .dylib 文件，在 MS Windows 中是 .dll 文件）。</p>
<p>通常情况下，作为 C++ 程序员，我们对这种结构涉及的细微差别一无所知，因为可执行文件和库是在一个统一的构建环境中构建的（即，相同的编译器和标准库）。然而，在实际的插件接口中，我们不能做出这样的保证。相反，我们必须采取防御性编程，并假设最糟糕的情况，即插件是在与主应用程序不同但兼容的环境中构建的。在这里，我们将做一个相对较弱的假设，即这两个环境至少具有相同的对象模型。具体来说，我们要求这两个环境在处理虚拟函数指针（vptr）的布局上是相同的。如果您不熟悉虚拟函数指针的概念，可以在 Lippman [13] 中找到所有详细信息。虽然原则上，C++ 编译器作者可以选择不同的 vptr 布局，但在实践中，编译器通常使用兼容的布局，尤其是相同编译器的不同版本。如果没有这种共享对象模型的假设，我们将被迫开发一个仅使用 C 语言的插件结构。请注意，我们还必须假设主应用程序和插件中所有类型 T 的 sizeof(T) 大小相同。这排除了例如具有 32 位应用程序和 64 位插件的情况，因为这两个平台具有不同的指针大小。</p>
<p>在异构环境中编程如何影响我们可以使用的编程技术？在最糟糕的情况下，主应用程序可能会使用不同的编译器和不同的标准库构建。这一事实有几个严重的影响。首先，我们不能假设插件和应用程序之间的内存分配和释放是兼容的。这意味着在插件中分配的任何内存必须在相同的插件中释放。其次，我们不能假设来自标准库的代码在任何插件和主应用程序之间是兼容的。因此，我们的插件接口不能包含任何标准容器。尽管库不兼容可能看起来有点奇怪（这是标准库，对吧？），但请记住，标准指定的是接口，而不是实现（受到某些限制，例如向量占用连续内存）。例如，不同的标准库实现通常具有不同的字符串实现。有些人更喜欢小字符串优化，而另一些人更喜欢使用写时复制。第三，虽然我们已经假设了对象中 vptr 的兼容布局，但我们不能假设相同的对齐方式。因此，如果主应用程序中使用了这些成员变量，插件类不应该继承具有基类中定义的成员变量的主应用程序类。这是因为如果每个编译器使用不同的对齐方式，主应用程序的编译器可能会为成员变量使用与插件编译器定义的不同内存偏移量。第四，由于不同编译器之间名称改编的差异，导出的接口必须指定 extern “C” 连接。连接要求是双向的。插件不应该在没有 extern “C” 连接的情况下调用应用程序函数，应用程序也不应该在没有 extern “C” 连接的情况下调用插件函数。请注意，由于非内联、非虚成员函数需要跨编译单元链接（与虚函数相反，虚函数通过虚函数表中的偏移量通过 vptr 调用），应用程序只应通过虚函数调用插件代码，插件代码不应调用在主应用程序中编译的基类非内联、非虚函数。最后，异常在主程序和插件之间的二进制接口上很少是可移植的，所以我们不能在插件中抛出异常并尝试在主应用程序中捕获它们。</p>
<p>这实在是说得太多了。让我们通过列举C++插件的规则来回顾一下：</p>
<ol>
<li class="lvl-3">
<p>在插件中分配的内存必须在相同的插件中释放。</p>
</li>
<li class="lvl-3">
<p>标准库组件不能在插件接口中使用。</p>
</li>
<li class="lvl-3">
<p>假设不兼容的对齐方式。如果变量在主应用程序中使用，避免插件继承具有成员变量的主应用程序类。</p>
</li>
<li class="lvl-3">
<p>从插件导出的函数（由主应用程序调用）必须指定extern &quot;C&quot;连接。从主应用程序导出的函数（由插件调用）必须指定extern &quot;C&quot;连接。</p>
</li>
<li class="lvl-3">
<p>主应用程序应通过虚函数专门与插件派生类通信。插件派生类不应调用非内联、非虚拟的主应用程序基类函数。</p>
</li>
<li class="lvl-3">
<p>不要让插件抛出的异常传播到主应用程序。</p>
</li>
</ol>
<p>牢记这些规则，让我们回到为了设计插件必须解决的三个基本问题。</p>
<h2 id="7-2-问题1：插件接口">7.2 问题1：插件接口</h2>
<p>插件接口负责几个项目。首先，它必须实现新命令和新GUI按钮的发现。我们将看到，通过类接口最有效地实现这一功能。其次，插件必须支持用于分配和释放上述插件类的C连接接口。第三，pdCalc应该提供一个从Command派生的PluginCommand类，以协助正确编写插件命令。从技术上讲，PluginCommand类是可选的，但提供这样一个接口有助于用户遵守插件规则3和6。第四，插件接口提供查询插件支持的API版本的功能是值得的。最后，pdCalc必须为插件调用的任何函数提供C连接。具体来说，插件命令必须能够访问堆栈。我们将按顺序解决这些问题，从发现命令的接口开始。</p>
<h3 id="7-2-1-发现命令的接口">7.2.1 发现命令的接口</h3>
<p>我们面临的第一个问题是如何从插件中分配命令，而我们既不知道插件提供的命令，也不知道我们需要实例化的类的名称。我们将通过创建一个所有插件都必须遵循的抽象接口来解决这个问题，该接口可以导出命令及其名称。首先，让我们讨论一下我们需要的功能。</p>
<p>回想一下第4章，为了将新命令加载到计算器中，我们必须将其注册到CommandRepository中。按设计，CommandRepository是专门用于承认动态分配命令的，这正是我们为插件命令所需的功能。现在，我们假设插件管理系统可以访问注册命令（我们将在第7.4节解决这个问题）。CommandRepository的注册功能需要一个字符串名称和一个作为命令原型的unique_ptr。由于pdCalc事先对插件中的命令名称一无所知，插件接口必须首先使名称可发现。其次，由于C++缺少反射这种语言特性，插件接口必须提供一种方法来创建一个与每个发现的名称相关联的原型命令。再次，根据设计，抽象的Command接口通过clone()虚成员函数支持原型模式。让我们看看这两个先前的设计决策如何有效地启用插件。</p>
<p>基于上述C<ins>插件规则，我们实现命令发现的唯一手段是将其封装为一个纯虚接口，所有插件都必须遵循这个接口。理想情况下，我们的虚函数将返回一个由字符串键控的unique_ptr<CommandPtr>值的关联容器。然而，我们的C</CommandPtr></ins>插件规则也规定我们不能使用标准容器，因此排除了string、map、unordered_map和unique_ptr。与其（糟糕地）重新实现这些容器的自定义版本，我们只是使用一个通常避免的低级功能：指针数组。</p>
<p>通过创建一个插件类来强制执行上述设计，所有插件都必须遵循这个类。这个抽象类的目的是标准化插件命令发现。类声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plugin</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Plugin</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Plugin</span>();</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PluginDescriptor</span> &#123;</span><br><span class="line">        <span class="type">int</span> nCommands;</span><br><span class="line">        <span class="type">char</span>** commandNames;</span><br><span class="line">        Command** commands;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> PluginDescriptor&amp; <span class="title">getPluginDescriptor</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在我们有了一个抽象的插件接口，当进行特化时，需要一个派生类返回一个描述符，该描述符提供了可用命令的数量、这些命令的名称以及命令本身的原型。显然，命令名称的顺序必须与命令原型的顺序相匹配。不幸的是，对于原始指针和原始数组，命令名称和命令原型的内存归属变得模糊。我们无法使用标准容器，使我们陷入了一个不幸的设计：通过注释约定。因为我们的规则规定插件中分配的内存必须由相同的插件释放，所以最好的策略是规定插件负责释放PluginDescriptor及其组成部分。如前所述，内存约定是通过注释“强制执行”的。</p>
<p>太好了，我们的问题解决了。我们创建一个插件，叫做MyPlugin，继承自Plugin。在下面的第7.3节中，我们将了解如何分配和释放插件。在MyPlugin内部，我们像往常一样通过继承Command来创建新的命令。由于插件知道自己的命令名称，与主程序不同，插件可以使用new操作符分配其命令原型。然后，为了注册插件的所有命令，我们简单地分配一个带有命令名称和命令原型的插件描述符，通过覆盖getPluginDescriptor()函数返回描述符，并让pdCalc注册命令。因为Commands必须实现一个clone()函数，pdCalc可以通过这个虚函数复制插件命令原型，将它们注册到CommandRepository。简单地说，可以从commandNames数组中创建用于注册的字符串名称。对于已分配的Plugin* p，pdCalc中的以下代码可以实现注册：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Plugin::PluginDescriptor&amp; d = p-&gt;<span class="built_in">getPluginDesciptor</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.nCommands; ++i)</span><br><span class="line">    CommandRepository::<span class="built_in">Instance</span>().<span class="built_in">registerCommand</span>(d.commandNames[i],</span><br><span class="line">        <span class="built_in">MakeCommandPtr</span>(d.commands[i]-&gt;<span class="built_in">clone</span>()));</span><br></pre></td></tr></table></figure>
<p>在这一点上，您可能会认识到我们的插件面临的困境。命令在插件中分配，在主程序的CommandRepository中通过clone()调用注册时复制，最后在CommandRepository的析构函数执行时由主程序删除。更糟糕的是，每次执行命令时，CommandRepository会克隆它的原型，通过插件中的Command的clone()函数触发一个新的语句。这个执行命令的生命周期由CommandManager通过它的撤消和重做堆栈来管理。具体来说，当一个命令从这些堆栈中清除时，当保存命令的unique_ptr被销毁时，主程序中会调用delete。至少，在没有一些调整的情况下就是这样工作的。正如第4章中提到的，CommandPtr不仅仅是unique_ptr<Command>的简单别名。现在我终于要描述CommandPtr别名和MakeCommandPtr()函数背后的机制，这些机制允许正确地管理插件命令内存。</Command></p>
<p>从根本上说，我们首先需要一个函数在适当的编译单元中调用delete。解决这个问题的最简单方法是将一个deallocate()虚函数添加到Command类中。这个函数的职责是在命令被销毁时在正确的编译单元中调用delete。对于所有核心命令，正确的行为只是在主程序中删除类。因此，我们不将deallocate()函数设置为纯虚函数，我们为其提供以下默认实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Command::deallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于插件命令，deallocate()的重写具有相同的定义，只是定义出现在插件的编译代码中（例如，在特定插件中的命令使用的基类中）。因此，当在主应用程序中的Command指针上调用deallocate()时，虚拟函数分派确保从正确的编译单元调用delete。现在我们只需要一个机制来确保在回收Commands时调用deallocate()而不是直接调用delete。幸运的是，就像他们设计unique_ptr时标准委员会完美地预料到了我们的需求一样。让我们回到CommandPtr别名，看看unique_ptr如何用来解决我们的问题。</p>
<p>只需要很少的几行代码就可以定义一个CommandPtr别名，并实现一个能够调用deallocate()而不是delete的MakeCommandPtr()函数。代码利用了unique_ptr的删除器对象（见侧边栏），该对象在调用unique_ptr的析构函数时启用自定义例程来回收unique_ptr所持有的资源。让我们看看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">CommandDeleter</span><span class="params">(Command* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">deallocate</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> CommandPtr = unique_ptr&lt;Command, <span class="keyword">decltype</span>(&amp;CommandDeleter)&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">MakeCommandPtr</span><span class="params">(Command* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CommandPtr&#123;p, &amp;CommandDeleter&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面密集代码的简短解释是有必要的。CommandPtr只是一个unique_ptr的别名，它包含一个在析构时通过调用CommandDeleter()函数回收的Command指针。unique_ptr调用的CommandDeleter()函数是一个简单的内联函数，它调用之前定义的虚拟deallocate()函数。为了减轻创建CommandPtrs的语法负担，我们引入了一个内联MakeCommandPtr()辅助函数，它从Command指针构造一个CommandPtr。就是这样。现在，就像以前一样，unique_ptrs自动管理Commands的内存。然而，unique_ptr的析构函数不是直接在底层的Command上调用delete，而是调用CommandDeleter函数，该函数调用deallocate()，在正确的编译单元上对底层的Command发出delete。</p>
<p>如果您查看MakeCommandPtr()的源代码，除了上面看到的接受Command指针参数的函数版本外，您还会看到一个使用可变模板和完美转发的非常不同的重载。由于MakeCommandPtr()在构建存储过程中具有不同的语义用法，这个重载函数必须存在。我们将在第8章中重新审视函数的两种形式背后的原因。如果悬念无法忍受，请随时跳到第8.1.2节。</p>
<hr>
<p>现代C++设计注意事项：Unique_Ptr析构语义</p>
<p>unique_ptr&lt;T,D&gt; 类模板是一种智能指针，它模拟对资源的唯一所有权。最常见的用法仅指定第一个模板参数，T，它声明要拥有的指针类型。第二个参数，D，指定在析构 unique_ptr 期间调用的自定义删除可调用对象。让我们看一个 unique_ptr 析构函数的概念模型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D = default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr &#123;</span><br><span class="line">    T* p_;</span><br><span class="line">    D d_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">unique_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">d_</span>(p_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>unique_ptr 的析构函数不直接调用 delete，而是使用函数调用语义将所拥有的指针传递给删除器。从概念上讲，default_delete 的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，default_delete 只是删除 unique_ptr 包含的底层指针。然而，通过在构造过程中指定一个自定义删除器可调用对象（D模板参数），unique_ptr 可用于释放需要自定义释放语义的资源。作为一个简单的例子，结合一个 lambda 表达式，unique_ptr 的删除语义允许我们创建一个简单的 RAII（资源获取即初始化）容器类，MyObj，由 malloc() 分配：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyObj* m = <span class="built_in">static_cast</span>&lt;MyObj*&gt;( <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(MyObj) ) );</span><br><span class="line"><span class="keyword">auto</span> d = [](MyObj* p)&#123; <span class="built_in">free</span>(p); &#125;;</span><br><span class="line"><span class="keyword">auto</span> p = unique_ptr&lt;MyObj, <span class="keyword">decltype</span>(d)&gt;&#123;m, d&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，我们为 pdCalc 设计的另一个实例也显示了 unique_ptr 自定义删除语义的有用性。应该指出的是，shared_ptr 也以类似的方式接受自定义删除器。</p>
<hr>
<h3 id="7-2-2-添加新GUI按钮的接口">7.2.2 添加新GUI按钮的接口</h3>
<p>从概念上讲，动态添加按钮与动态添加命令没有太大区别。主应用程序不知道需要从插件中导入哪些按钮，因此Plugin接口必须提供一个提供按钮描述符的虚拟函数。然而，与命令不同，插件实际上不需要分配按钮本身。回顾第6章，GUI CommandButton 部件只需要文本进行构造。具体来说，它需要 push button 的显示文本（可选的，shifted状态文本）和与 clicked() 信号一起发出的命令文本。因此，即使对于插件命令，相应的 GUI 按钮本身也完全位于主应用程序中；插件只需提供文本。这导致了Plugin类中以下简单的接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plugin</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PluginButtonDescriptor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nButtons;</span><br><span class="line">        <span class="type">char</span>** dispPrimaryCmd; <span class="comment">// primary command label</span></span><br><span class="line">        <span class="type">char</span>** primaryCmd;     <span class="comment">// primary command</span></span><br><span class="line">        <span class="type">char</span>** dispShftCmd;    <span class="comment">// shifted command label</span></span><br><span class="line">        <span class="type">char</span>** shftCmd;        <span class="comment">// shifted command</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> PluginButtonDescriptor* <span class="title">getPluginButtonDescriptor</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再次强调，由于我们必须遵循插件的规则，接口必须由低级字符数组组成，而不能是更高级的STL结构。</p>
<p>getPluginButtonDescriptor() 函数相对于 getPluginDescriptor() 的一个有趣的方面是决定返回指针而不是引用。这个选择背后的理由是插件编写者可能希望编写一个导出没有相应 GUI 按钮的命令的插件（即，仅CLI命令）。反过来，当然是无意义的。也就是说，我无法想象为什么有人会编写一个导出不存在命令的按钮的插件。这种实用性体现在两个描述符函数的返回类型中。由于这两个函数都是纯虚的，插件专门化必须实现它们。因为getPluginDescriptor()返回一个引用，它必须导出一个非空描述符。然而，通过返回描述符的指针，getPluginButtonDescriptor()允许返回一个空指针，表示插件没有导出任何按钮。有人可能会争辩说，getPluginButtonDescriptor() 函数不应该是纯虚的，而应该提供一个默认实现，返回一个空指针。这个决定在技术上是可行的。然而，通过坚持插件作者手动实现getPluginButtonDescriptor()，接口强制显式地做出决策。</p>
<h3 id="7-2-3-插件分配和释放">7.2.3 插件分配和释放</h3>
<p>我们最初的问题是主程序不知道插件命令的类名，因此无法通过调用 new 分配它们。我们通过创建一个抽象的 Plugin 接口来解决这个问题，该接口负责导出命令原型、命令名称以及 GUI 创建按钮所需的足够信息。当然，要实现这个接口，插件必须从 Plugin 类派生，从而创建一个特化，其名称主应用程序无法预先知道。看似我们没有取得进展，又回到了最初的问题。</p>
<p>我们的新问题，尽管与原问题相似，实际上要容易得多解决。解决问题的方法是在每个插件中创建一个 extern “C” 分配/释放函数对，预先指定的名称通过基类指针分配/释放 Plugin 特化类。为了满足这些要求，我们在插件接口中添加了以下两个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span>* <span class="title">AllocPlugin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">DeallocPlugin</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br></pre></td></tr></table></figure>
<p>显然，AllocPlugin() 函数分配 Plugin 特化并将其返回给主应用程序，而 DeallocPlugin() 函数在主应用程序完成使用插件后对其进行释放。有趣的是，AllocPlugin() 和 DeallocPlugin() 函数使用 void 指针而不是 Plugin 指针。这个接口是保持 C 链接所必需的，因为 extern “C” 接口必须符合 C 类型。维护 C 链接的一个不幸后果是必须进行类型转换。在使用它之前，主应用程序必须将 void* 转换为 Plugin*，在调用 delete 之前，共享库必须将 void* 转换回 Plugin*。请注意，我们不需要具体 Plugin 的类名。因此，AllocPlugin()/DeallocPlugin() 函数对解决了我们的问题。</p>
<h3 id="7-2-4-插件命令接口">7.2.4 插件命令接口</h3>
<p>从技术上讲，不需要特殊的插件命令接口。但是，提供这样一个接口有助于编写遵循 C++ 插件规则的插件命令。具体来说，通过创建一个 PluginCommand 接口，我们为插件开发者提供了两个关键特性。首先，我们提供了一个接口，确保插件命令不会从具有任何状态（避免对齐问题）的命令类继承。这个属性在构造时是显而易见的。其次，我们调整 checkPreconditionsImpl() 函数以在插件边界上创建一个无异常的接口。根据这个指导思想，这里是 PluginCommand 接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PluginCommand</span> : <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PluginCommand</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">checkPluginPreconditions</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> PluginCommand* <span class="title">clonePluginImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkPreconditionsImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> <span class="keyword">final</span></span>;</span><br><span class="line">    <span class="function">PluginCommand* <span class="title">cloneImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虽然在第 4 章中只简要提及，但 Command 类中的所有纯虚函数都标记为 noexcept，除了 c heckPreconditionsImpl() 和 cloneImpl()（请参阅关于 noexcept 关键字的侧边栏）。因此，为确保插件命令不产生异常，我们只需在 PluginCommand 层次结构中实现 checkPreconditionsImpl() 和 cloneImpl() 函数，并为其派生类创建新的、无异常的纯虚函数来实现。PluginCommand 类中的 checkPreconditionsImpl() 和 cloneImpl() 都标记为 final，以防止特化意外地覆盖这两个函数。checkPreconditionsImpl() 的实现可以简单地写为如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PluginCommand::checkPreconditionsImpl</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = <span class="built_in">checkPluginPreconditions</span>();</span><br><span class="line">    <span class="keyword">if</span>(p) </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Exception</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，上述实现背后的关键思想是 PluginCommand 类的实现位于主应用程序的编译单元中，而该类的任何特化都位于插件的编译单元中。因此，通过虚拟调度，调用 checkPreconditionsImpl() 在主应用程序的编译单元中执行，此函数反过来调用位于插件编译单元中的无异常 checkPluginPreconditions() 函数。如果发生错误，checkPreconditionsImpl() 函数通过 nullptr 返回值接收错误，并从主应用程序的编译单元而不是插件的编译单元产生异常。</p>
<p>类似的简单实现对于 cloneImpl() 可以在 Command.cpp 中找到。从 PluginCommand 而不是 Command、UnaryCommand 或 BinaryCommand 继承的插件命令更有可能避免违反任何 C++ 插件规则，因此不太可能产生难以诊断的插件特定运行时错误。</p>
<hr>
<p>现代 C++ 设计注解：Noexcept</p>
<p>C++98 标准允许使用异常规范。例如，以下规范表示函数 foo() 不抛出任何异常（抛出规范为空）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>不幸的是，C++98 异常规范存在许多问题。虽然它们是指定函数可能抛出的异常的高尚尝试，但它们通常并不表现如预期。例如，编译器从不在编译时保证异常规范，而是通过运行时检查来强制执行此约束。更糟糕的是，声明一个不抛出异常的规范可能会影响代码性能。出于这些原因和其他原因，许多编码标准规定应该简单地避免异常规范（例如，请参见 [27] 中的标准 75）。</p>
<p>虽然指定函数可以抛出哪些异常规范事实证明并不是非常有用，但指定函数不能抛出任何异常可能是一个重要的接口考虑。幸运的是，C++11 标准通过引入 noexcept 关键字来解决异常规范混乱的问题。关于 noexcept 说明符的用途的深入讨论，请参见 [19] 中的项目 14。在我们的讨论中，我们将关注这个关键字在设计中的实用性。</p>
<p>性能优化不考虑，将 noexcept 用于函数规范的选择主要是个人喜好问题。对于大多数函数，没有异常规范是常规的。即使函数的代码本身不发出异常，也很难静态地确保函数内的嵌套函数调用不发出任何异常。因此，noexcept 在运行时强制执行，而不是在编译时保证。因此，我的个人建议是将 noexcept 说明符的使用保留在需要对函数的意图进行强烈声明的特定实例中。pdCalc 的 Command 层次结构说明了不抛出异常对于正确操作非常重要的几种情况。这个要求在接口中编码，以告知开发人员抛出异常将导致运行时故障。</p>
<hr>
<h3 id="7-2-5-API-版本控制">7.2.5 API 版本控制</h3>
<p>在一个长寿命应用程序的生命周期中，插件的规范可能会发生变化。这意味着在某个时间点编写的插件可能无法与更新后的 API 版本一起使用。对于作为单个单元交付的应用程序，组成整体的组件（即多个共享库）通过开发计划进行同步。对于完整的应用程序，版本控制用于向外部世界表示整个应用程序已发生更改。然而，由于插件被设计为与主应用程序的开发独立，插件发布与应用程序发布之间的同步可能是不可能的。此外，插件 API 可能会或可能不会随着每个应用程序版本的发布而改变。因此，为确保兼容性，我们必须将插件 API 单独从主应用程序进行版本控制。虽然您可能不预料到将来会更改插件 API，但是如果您没有将查询插件支持的 API 版本作为 API 本身的一部分添加到前端，则您将不得不稍后引入一个突破性的更改以添加此功能。根据您的要求，这样的重大更改可能不可行，您将永远无法添加 API 版本控制。因此，即使最初没有使用，也应该将查询插件支持的 API 版本的功能添加到插件接口中，将其视为隐含的要求。希望现在大家明白，API 版本与应用程序版本是不同的。</p>
<p>实际的 API 版本编号方案可以简单或复杂，具体取决于认为合适的程度。在简单的一面，它可以是一个整数。在更复杂的一面，它可以是一个包含主要版本、次要版本等多个整数的结构。对于 pdCalc，我选择了一个简单的结构，只使用主版本和次版本号。接口代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plugin</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ApiVersion</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> major;</span><br><span class="line">        <span class="type">int</span> minor;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ApiVersion <span class="title">apiVersion</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为 pdCalc 是第一个版本，主应用程序不需要比检查插件是否使用 API 版本 1.0 更复杂的算法。如果违反了这个约束，就不会加载有问题的插件。</p>
<h3 id="7-2-6-提供堆栈功能">7.2.6 提供堆栈功能</h3>
<p>插件接口的一部分包括让插件及其命令对 pdCalc 可发现。pdCalc 的插件接口的另一部分包括让 pdCalc 的必要功能部分对插件可用。具体来说，新命令的实现需要访问 pdCalc 的堆栈。</p>
<p>正如我们在开发核心命令时看到的，命令只需要非常基本的访问堆栈功能。具体来说，它们需要将元素压入堆栈、从堆栈弹出元素以及可能从堆栈检查元素（以实现前提条件）的能力。我们为核心命令提供这些功能的策略是将 Stack 类作为具有包括 push、pop 和检查成员函数的公共接口的单例来实现。然而，这种设计无法扩展到插件命令，因为它违反了 C++ 插件规则中的两条。即，我们当前的接口不符合 C 链接（堆栈提供 C++ 类接口），当前的检查函数通过 STL 向量返回堆栈元素。</p>
<p>解决这个问题的方法相当简单。我们只需在堆栈上添加一个新接口（最好是在专门指定的头文件中），该接口由一组全局（在 pdCalc 命名空间之外）的 extern “C” 函数组成，这些函数在 C 链接和 C++ 类链接之间进行转换（再次使用适配器模式）。请记住，由于 Stack 类是作为单例实现的，因此插件和全局辅助函数都不需要拥有 Stack 引用或指针。辅助函数通过其 Instance() 函数直接访问 Stack。我选择在单独的 StackPluginInterface.h 头文件中实现以下五个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">StackPush</span><span class="params">(<span class="type">double</span> d, <span class="type">bool</span> suppressChangeEvent)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">double</span> <span class="title">StackPop</span><span class="params">(<span class="type">bool</span> suppressChangeEvent)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">size_t</span> <span class="title">StackSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">double</span> <span class="title">StackFirstElement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">double</span> <span class="title">StackSecondElement</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>为了简单起见，由于我的示例插件不需要比前两个元素更深入地访问堆栈，我只创建了两个检查函数，StackFirstElement() 和 StackSecondElement() ，用于获取堆栈的前两个元素。如果需要，可以实现一个返回堆栈中任何深度的元素的函数。为了保持 extern “C” 链接，实现这样一个功能的人需要记住使用原始 double 数组而不是 STL 向量。</p>
<p>上述五个函数的完整、简单实现出现在 StackPluginInterface.cpp 文件中。作为示例，给出了 StackSize() 函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">StackSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pdCalc::Stack::<span class="built_in">Instance</span>().<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-3-问题-2：加载插件">7.3 问题 2：加载插件</h2>
<p>如前所述，插件是特定于平台的，从本质上讲，加载插件需要特定于平台的代码。在本节中，我们将考虑两个主题。首先，我们将解决加载库及其各自符号所需的特定于平台的代码。在这里，我们将查看两个平台接口：POSIX（Linux、UNIX、Mac OS X）和win32（MS Windows）。其次，我们将探讨一种设计策略，以减轻常常因使用特定于平台的代码而产生的源代码混乱。</p>
<h3 id="7-3-1-特定于平台的插件加载">7.3.1 特定于平台的插件加载</h3>
<p>为了使用插件，我们只需要三个特定于平台的函数：一个用于打开共享库的函数，一个用于关闭共享库的函数，以及一个用于从打开的共享库中提取符号的函数。表7-1按平台列出了这些函数及其关联的头文件。让我们看看如何使用这些函数。</p>
<p>Table 7-1 Plugin functions for different platforms<br>
表7-1 不同平台的插件函数</p>
<table>
<thead>
<tr>
<th></th>
<th>FunPOSIXctions</th>
<th>win32</th>
</tr>
</thead>
<tbody>
<tr>
<td>header</td>
<td>dlfcn.h</td>
<td>windows.h</td>
</tr>
<tr>
<td>load library</td>
<td>dlopen()</td>
<td>LoadLibrary()</td>
</tr>
<tr>
<td>close library</td>
<td>dlclose()</td>
<td>FreeLibrary()</td>
</tr>
<tr>
<td>get library symbol</td>
<td>dlsym()</td>
<td>GetProcAddress()</td>
</tr>
</tbody>
</table>
<h3 id="7-3-2-加载、使用和关闭共享库">7.3.2 加载、使用和关闭共享库</h3>
<p>使用插件的第一步是要求运行时系统打开库，并使其可导出符号可用于当前的工作程序。每个平台上的打开命令都需要要打开的共享库的名称（POSIX 还需要一个指定符号绑定的标志，要么是延迟的，要么是立即的），它返回一个不透明的库句柄，该句柄用于在后续函数调用中引用库。在 POSIX 系统上，句柄类型为 void*，而在 win32 系统上，句柄类型为 HINSTANCE（经过一些拆解，这是一个 void* 的 typedef）。例如，以下代码在 POSIX 系统上打开一个插件库，<a target="_blank" rel="noopener" href="http://libPlugin.so">libPlugin.so</a>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* handle = <span class="built_in">dlopen</span>(<span class="string">&quot;libPlugin.so&quot;</span>, RTLD_LAZY);</span><br></pre></td></tr></table></figure>
<p>其中 RTLD_LAZY 选项告诉运行时系统执行延迟绑定，这将在引用它们的代码被执行时解析符号。另一种选择是 RTLD_NOW，它会在 dlopen() 返回之前解析库中的所有未定义符号。如果打开失败，则返回空指针。简单的错误处理方案跳过从空插件加载任何功能，警告用户打开插件失败。</p>
<p>除了不同的函数名称外，打开插件的主要特定于平台的区别是不同平台采用的规范命名约定。例如，在 Linux 上，共享库以 lib 开头，具有 .so 文件扩展名。在 Windows 上，共享库（通常称为动态链接库，或简称 DLL）没有特定的前缀，具有 .dll 文件扩展名。在 Mac OS X 上，共享库通常以 lib 为前缀，具有 .dylib 扩展名。从本质上讲，这种命名约定仅在两个地方有关系。首先，构建系统应为各个平台创建具有适当名称的插件。其次，打开插件的调用应使用正确的格式指定名称。由于插件名称在运行时指定，我们需要确保由提供插件的用户正确指定插件名称。</p>
<p>一旦插件被打开，我们需要从共享库中导出符号，以便调用插件中包含的函数。这可以通过调用 dlopen() 或 LoadLibrary()（取决于平台）来实现，它们中的任何一个都使用插件函数的字符串名称将插件函数绑定到函数指针。然后在主应用程序中通过获得的函数指针间接调用绑定的插件函数。</p>
<p>为了绑定共享库中的符号，我们需要有一个插件句柄（打开插件的返回值），知道我们要调用的插件中的函数的名称，以及我们要调用的函数的签名。对于 pdCalc，我们需要调用的第一个插件函数是 AllocPlugin()，用于分配嵌入式 Plugin 类（请参见上面的第 7.2.3 节）。因为这个函数是作为插件接口的一部分声明的，所以我们知道它的名称和签名。举例来说，在 Windows 上，对于一个已经加载的插件，由 HINSTANCE 句柄指向，我们将插件的 AllocPlugin() 函数绑定到一个函数指针，使用以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function pointer of AllocPlugin &#x27;s type:</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123; <span class="keyword">typedef</span> <span class="type">void</span>* (*PluginAllocator)(<span class="type">void</span>); &#125;</span><br><span class="line"><span class="comment">// bind the symbol from the plugin</span></span><br><span class="line"><span class="keyword">auto</span> alloc = <span class="built_in">GetProcAddress</span>(handle, <span class="string">&quot;AllocPlugin&quot;</span>);</span><br><span class="line"><span class="comment">// cast the symbol from void* (return of GetProcAddress)</span></span><br><span class="line"><span class="comment">// to the function pointer type of AllocPlugin</span></span><br><span class="line">PluginAllocator allocator&#123; <span class="built_in">reinterpret_cast</span>&lt;PluginAllocator&gt;(alloc) &#125;;</span><br></pre></td></tr></table></figure>
<p>随后，通过以下方式分配插件的 Plugin 专门化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only dereference if the function was bound properly</span></span><br><span class="line"><span class="keyword">if</span>(allocator)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// dereference the allocator, call the function,</span></span><br><span class="line">    <span class="comment">// cast the void* return to a Plugin*</span></span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">static_cast</span>&lt;Plugin*&gt;((*allocator)());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，具体的插件已经可以通过抽象的插件接口来使用（例如，加载插件命令，查询支持的插件API）。</p>
<p>/redo stack in the CommandManager.</p>
<p>在插件释放时，需要绑定并执行插件的DeallocPlugin()函数，这需要类似的代码序列。有兴趣的读者可以参考GitHub仓库中的平台特定代码了解详细信息。请记住，在释放插件之前，由于插件分配的命令驻留在主应用程序的内存中（但必须在插件中回收），插件在释放所有命令之前不得关闭。驻留在主应用程序内存空间中的插件命令示例包括CommandRepository中的命令原型以及CommandManager中的撤消/重做堆栈上的命令。</p>
<p>由于插件是一个获取的资源，当我们不再使用它时，应该释放它。这个操作在POSIX平台上通过调用dlclose()来完成，在win32平台上通过调用FreeLibrary()来完成。例如，以下代码用于关闭在POSIX系统上使用dlopen()打开的共享库（句柄）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only try to close a non-null library</span></span><br><span class="line"><span class="keyword">if</span>(handle) <span class="built_in">dlclose</span>(handle);</span><br></pre></td></tr></table></figure>
<p>现在我们已经讨论了打开、使用和关闭插件的平台特定机制，让我们把注意力转向一种设计策略，以减轻处理多平台源代码所固有的复杂性。</p>
<h3 id="7-3-3-多平台代码的设计">7.3.3 多平台代码的设计</h3>
<p>跨平台的可移植性对于任何软件项目来说都是值得称赞的目标。然而，在保持代码库可读的同时实现这一目标需要认真考虑。在本节中，我们将探讨一些在保持可读性的同时实现平台可移植性的设计技巧。</p>
<h4 id="7-3-3-1-显而易见的解决方案：库">7.3.3.1 显而易见的解决方案：库</h4>
<p>显而易见（也是首选）的解决可移植性问题的方法是使用一个为您抽象平台依赖性的库。在任何开发场景中使用高质量的库总是可以节省为您的项目设计、实现、测试和维护所需功能的努力。对于跨平台开发，使用库还有一个额外的好处，即在一个平台无关的API后面隐藏平台特定的代码。这种API当然允许您在不用预处理器指令污染源代码的情况下，维护一个在多个平台上无缝工作的单一代码库。尽管我在第6章中没有明确讨论这些优点，但Qt的工具包抽象提供了一个用于构建GUI的平台无关的API，而这本来是一个依赖于平台的任务。在pdCalc中，我们使用Qt构建了一个在Windows和Linux（以及可能是OS X，尽管我没有验证这一点）上编译和执行的GUI，而不需要在平台之间更改源代码的任何一行。</p>
<p>然而，显而易见的解决方案并不总是可行。很多原因导致项目无法采用库。首先，许多库不是免费的，库的成本可能过高，特别是如果许可证除了开发费用外还有使用费用。其次，库的许可证可能与项目的许可证不兼容。例如，也许您正在构建一个封闭源代码，但唯一可用的库具有不兼容的开源许可证（反之亦然）。第三，库通常在没有源代码的情况下发布。缺少源代码使得扩展库的功能变得不可能。第四，您可能需要库的支持，但供应商可能不提供。第五，库可能会随着与您自己不兼容的升级周期发布。第六，库可能与您的工具链不兼容。最后，您正在寻求的功能可能根本没有相应的库。因此，尽管通常使用库是实现可移植性的首选，但还有足够多的反例使我们有必要讨论如何在不使用库的情况下实现可移植性。</p>
<h4 id="7-3-3-2-原始预处理器指令">7.3.3.2 原始预处理器指令</h4>
<p>在尝试实现跨平台代码时，使用原始预处理器指令无疑是首先尝试的方法。几乎所有编写过可移植代码的人可能都是从这种方法开始的。简单地说，在出现平台相关代码的地方，将平台特定部分用预处理器#ifdef指令包围起来。以Linux和Windows中共享库的运行时加载为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> POSIX</span></span><br><span class="line"><span class="type">void</span>* handle = <span class="built_in">dlopen</span>(<span class="string">&quot;libPlugin.so&quot;</span>, RTLD_LAZY);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> WIN32</span></span><br><span class="line">HINSTANCE handle = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;Plugin.dll&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>不要忘记也要围绕头文件使用预处理器指令：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> POSIX</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>对于少量的平台或很少的实例，使用原始预处理器指令是可以忍受的。然而，这种技术扩展性很差。一旦平台数量或需要平台相关代码的代码位置数量增加，使用原始预处理器指令很快就会变得混乱。代码变得难以阅读，当添加新平台时，找到所有平台相关位置变得非常困难。即使在一个中等规模的项目中，源代码中充斥着#ifdefs也很快变得难以维护。</p>
<h4 id="7-3-3-3-（稍微）更聪明的预处理器指令">7.3.3.3 （稍微）更聪明的预处理器指令</h4>
<p>在平台API在名称上有所不同，但在函数调用参数上相同（这比您预期的更常见，因为类似的功能，不足为奇地，需要类似的定制）的情况下，我们可以在使用预处理器时更加聪明一些。我们可以创建依赖于平台的宏名称，并在集中位置定义它们，而不是将预处理器指令放在每个平台相关的函数调用和类型声明的位置。通过一个例子来更好地解释这个想法。让我们看一下在Linux和Windows上关闭共享库：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some common header defining all platform dependent analogous symbols</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> POSIX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE void*</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOSE_LIBRARY dlclose</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOSE_LIBRARY FreeLibrary</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE HINSTANCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// in the code, for some shared library HANDLE handle</span></span><br><span class="line"><span class="built_in">CLOSE_LIBRARY</span>(handle);</span><br></pre></td></tr></table></figure>
<p>与在每个函数调用中使用#ifdefs的简单方法相比，这种技术要干净得多。然而，它仅适用于具有相同参数的函数调用，其局限性很大。显然，对于打开共享库的调用，我们仍然需要在调用位置使用#ifdef，因为POSIX调用需要两个参数，而Windows调用只需要一个。当然，借助C++的抽象功能，我们可以做得更好。</p>
<h4 id="7-3-3-4-构建系统解决方案">7.3.3.4 构建系统解决方案</h4>
<p>一开始看起来很有吸引力的一个有趣想法是将特定于平台的代码分离到特定于平台的源文件中，然后使用构建系统根据平台选择正确的文件。让我们考虑一个例子。将所有Unix特定的代码放在一个名为UnixImpl.cpp的文件中，将所有Windows特定的代码放在一个名为WindowsImpl.cpp的文件中。在每个相应的平台上，编写构建脚本以仅编译适当的平台特定文件。使用这种技术，不需要平台预处理器指令，因为任何给定的源文件只包含一个平台的源代码。</p>
<p>上述方案存在两个明显的缺点。首先，该方法只有在您在所有平台的所有平台特定文件中保持相同的接口（例如，函数名、类名、参数列表）时才有效。这个壮举说起来容易做起来难，尤其是当您有独立的团队在每个平台上工作和测试时。更糟糕的是，由于编译器在任何给定时间只能看到一个平台的代码，因此没有语言机制（例如类型系统）来强制执行这些跨平台接口约束。其次，实现跨平台兼容性的机制对于在单个平台上检查源代码的任何开发者来说是完全不透明的。在任何一个平台上，只有一个平台相关的源文件真正存在，而这个源文件没有提供其他文件存在的任何提示。当然，这后一个问题加剧了前一个问题，因为缺乏跨平台源代码透明性以及缺乏对该技术的语言支持使得维护接口一致性几乎不可能。因此，纯构建系统解决方案是棘手的。</p>
<p>在注意到这种技术的缺点之后，我们必须小心不要抛弃可取之处，因为我们最终解决方案的核心在于一个由语言支持的机制，既包括预处理器解决方案，也包括构建系统解决方案。这种设计技术将在以下部分进行讨论。</p>
<h4 id="7-3-3-5-平台工厂函数">7.3.3.5 平台工厂函数</h4>
<p>在代码中随处使用预处理器宏以实现平台特定功能类似于使用整数标志和switch语句执行特定于类型的代码。并非巧合的是，两个问题都有相同的解决方案，即构建一个抽象类层次结构并通过多态性执行特定功能。</p>
<p>我们将分两步构建设计一个通用跨平台架构的解决方案。首先，我们将设计一个用于处理动态加载的平台层次结构。其次，我们将把这个特定的解决方案扩展成一个框架，将平台依赖抽象为一个平台无关的接口。在这两个步骤中，我们将采用一种混合解决方案，通过最小化使用特定于平台的预处理器指令，以类型安全的方式利用构建系统。在此过程中，我们将遇到两个额外的、重要的设计模式：工厂方法和抽象工厂。让我们从检查平台无关的插件动态加载开始。</p>
<p>为了解决我们的具体问题，我们首先定义一个平台无关的DynamicLoader基类的抽象接口。我们的DynamicLoader只需要做两件事：分配和释放插件。因此，基类可以简单地定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicLoader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DynamicLoader</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Plugin* <span class="title">allocatePlugin</span><span class="params">(<span class="type">const</span> string&amp; pluginName)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">deallocatePlugin</span><span class="params">(Plugin*)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述基类的设计意图是，层次结构将根据平台进行特化。</p>
<p>请注意，接口本身是平台无关的。平台相关的分配和释放是通过虚拟函数由该接口的平台特定派生类处理的实现细节。此外，因为每个平台特定的实现都完全包含在一个派生类中，所以将每个派生类放在一个单独的文件中，我们可以使用构建系统有选择地仅编译每个平台相关的文件，从而避免在层次结构中任何地方使用平台预处理器指令。更好的是，一旦分配了一个DynamicLoader，接口就会抽象出插件加载的平台特定细节，插件的使用者不需要关心插件加载的细节。加载就能正常工作。对于DynamicLoader派生类的实现者，编译器可以使用类型信息来强制执行跨平台的接口一致性，因为每个派生类必须符合抽象基类所指定的接口，这是所有平台通用的。设计总结如图7-1所示。pdCalc的源代码实现了针对POSIX兼容系统和Windows的平台特定加载器。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/A454125_1_En_7_Fig1_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图7-1 平台无关插件分配和回收的动态加载器层次结构
    </div>
</center>
<p>上述设计将平台特定细节隐藏在抽象接口后面，减轻了插件使用者了解插件加载方式的需求。当然，这是基于插件使用者实例化正确的平台特定派生类，而这是DynamicLoader层次结构无法自动处理的。在这里，我们引入了一个新的设计模式，工厂函数，来解决实例化正确派生类的问题。简单来说，工厂函数是一种将类型创建与实例化的逻辑点分离的模式。</p>
<p>在继续之前，我应该指出工厂函数与Gang of Four[6]定义的工厂方法模式之间的语义差异。简单来说，工厂方法模式通过一个单独的类层次结构实现一个工厂。更一般地说，工厂是将特定派生类在层次结构中的选择与逻辑实例化点分离的任何机制。工厂函数是由单个函数组成的工厂，而不是单独的创建层次结构。</p>
<p>通常，工厂是通过调用一个函数实现的，该函数接受一个标志（整数、枚举、字符串等）来限定层次结构的特化，并返回一个基类指针。让我们来看一个人工示例。假设我们有一个由Circle、Triangle和Rectangle派生的Shapes层次结构。此外，假设我们定义了以下枚举类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShapeType</span> &#123;Circle, Triangle, Rectangle&#125;;</span><br></pre></td></tr></table></figure>
<p>以下工厂函数可以用于创建形状：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Shape&gt; <span class="title">shapeFactory</span><span class="params">(ShapeType t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> ShapeType::Circle:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Circle&gt;();</span><br><span class="line">        <span class="keyword">case</span> ShapeType::Triangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Triangle&gt;();</span><br><span class="line">        <span class="keyword">case</span> ShapeType::Rectangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Rectangle&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过以下函数调用创建一个Circle：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s = <span class="built_in">shapeFactory</span>(ShapeType::Circle);</span><br></pre></td></tr></table></figure>
<p>为什么上述构造比输入更有用呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s = <span class="built_in">make_unique</span>&lt;Circle &gt;();</span><br></pre></td></tr></table></figure>
<p>实际上，它并没有。然而，考虑一个接受字符串参数而不是枚举类型的工厂函数（用一系列if语句替换switch语句）。我们现在可以用以下语句构造一个Circle：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s = <span class="built_in">shapeFactory</span>(<span class="string">&quot;circle&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>与直接使用类名实例化相比，上述构造更有用，因为可以将shapeFactory()的字符串参数的值发现推迟到运行时。简单工厂方法的典型用法如上所述，是使定义实例化哪个特化的条件出现在配置文件或输入文件中。</p>
<p>在我们的例子中，工厂更简单。由于我们的层次结构是根据平台进行特化的，因此我们不需要传入一个标志来选择适当的派生类，而是通过使用预处理器指令进行选择，如清单7-1所示。</p>
<p>清单7-1 动态加载器工厂函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;DynamicLoader&gt; <span class="title">dynamicLoaderFactory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> POSIX</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;PosixDynamicLoader&gt;();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> WIN32</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;WindowsDynamicLoader&gt;();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将dynamicLoaderFactory()函数编译到它自己的源文件中，我们可以通过将一组预处理器指令隔离在一个源文件中实现平台无关的插件创建。然后调用工厂函数，在需要插件分配或释放的地方返回正确类型的DynamicLoader。通过让工厂返回一个unique_ptr，我们不需要担心内存泄漏。以下代码片段说明了DynamicLoader的平台无关用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Question: What plaform?</span></span><br><span class="line"><span class="keyword">auto</span> loader = <span class="built_in">dynamicLoaderFactory</span>();</span><br><span class="line"><span class="comment">// Answer: Who cares?</span></span><br><span class="line"><span class="keyword">auto</span> plugin = (loader ? loader-&gt;<span class="built_in">allocatePlugin</span>(pluginName) : <span class="literal">nullptr</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于pdCalc的目的，我们可以使用DynamicLoader层次结构和简单的工厂函数来停止。我们只需要抽象一个依赖于平台的特性（插件的分配和释放），上面的代码就足够了。然而，我们已经走到这一步，值得再迈出一步，看看适用于需要多个不同平台相关特性的情况的平台独立性的通用实现，即使我们的案例研究并不特别需要它。</p>
<h4 id="7-3-3-6-用于通用平台无关代码的抽象工厂">7.3.3.6 用于通用平台无关代码的抽象工厂</h4>
<p>作为软件开发人员，我们经常面临由于平台依赖性而导致的设计挑战。以下是C<ins>开发人员常见的平台特定编程任务的不完全列表：插件加载、进程间通信、文件系统导航（在C</ins>17中标准化）、图形、线程（在C<ins>11中标准化）、持久设置、二进制序列化、内置数据类型的sizeof()、计时器（在C</ins>11中标准化）和网络通信。此列表中的大部分（如果不是全部）功能都可以通过诸如boost或Qt这样的库中的平台无关API获得。对我个人而言，导致最多麻烦的平台特定功能是简单的目录分隔符（在Posix系统上是/，在Windows系统上是\）。</p>
<p>假设我们的计算器需要具有读取、写入和保存持久自定义设置的功能（请参阅第8章了解计算器可能需要这个功能的一些原因）。通常，Linux系统将设置保存在文本文件中（例如，在Ubuntu上，用户设置保存在家目录的.config目录中的文件中），而在Windows系统上，持久设置保存在系统注册表中。实际上，最好的解决方案是使用已经实现了这种抽象的现有库（例如，Qt的QSettings类）。为了教学目的，我们假设没有外部库可用，我们将研究一种在现有动态加载器旁边添加持久设置（或任意数量的平台相关功能）的设计。我们关注的是抽象，而不是每个平台上设置实现的细节。</p>
<p>简单的解决方案是依赖我们的动态加载器，并直接将必要的设置接口添加到DynamicLoader类中。当然，我们需要将类重命名为更通用的名称，例如OsSpecificFunctionality，以及派生类如LinuxFuntionality和WindowsFunctionality。这种方法简单、快速、很快就无法解决；它与内聚性背道而驰。对于任何大型代码，这种技术最终会导致无法控制的膨胀，从而导致接口的完全无法维护。尽管项目上的时间压力，我建议始终避免这种快速解决方案，因为它只会增加你的技术债务，并导致未来比现在使用合适的解决方案所经历的更长的延迟。</p>
<p>与其让我们现有的DynamicLoader类变得臃肿，我们不如从其设计中汲取灵感，创建一个单独的、类似的设置层次结构，如图7-2所示。同样，我们面临在每个独特平台上实例化特定于平台的派生类的问题。然而，我们不是添加一个额外的settingsLoaderFactory()函数来反映现有的dynamicLoaderFactory()函数，而是寻求一个通用解决方案，该解决方案能够在保留平台选择的单个代码点的同时实现无限的功能扩展。正如预期的那样，我们并不是第一批遇到这个特定问题的程序员，已经存在一个解决方案：抽象工厂模式。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/A454125_1_En_7_Fig2_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图7-2 针对平台无关持久设置的设置层次结构
  	</div>
</center>
<p>根据Gamma等人[6]，抽象工厂“提供了一个用于创建相关或依赖对象族的接口，而无需指定其具体类。”本质上，该模式可以分为两个步骤构建：</p>
<ol>
<li class="lvl-3">
<p>为每个相关对象（例如，一个动态加载器层次结构和一个设置层次结构，它们通过平台依赖性关联）创建独立的层次结构（族）。</p>
</li>
<li class="lvl-3">
<p>创建一个专门针对依赖关系（例如，平台）的层次结构，为每个族提供工厂函数。</p>
</li>
</ol>
<p>在没有具体示例的情况下，我发现上述抽象非常难以理解；因此，让我们考虑我们在pdCalc中试图解决的问题。当你浏览这个示例时，请参考图7-3中的（过于复杂的）类图。回顾一下，这个抽象的总体目标是创建一个单一的源位置，能够为创建任意数量的特定于平台的专门化提供平台无关的机制。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/A454125_1_En_7_Fig3_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图7-3 将抽象工厂模式应用于pdCalc
  	</div>
</center>
<p>正如我们已经看到的，平台相关的功能可以抽象为并行的、独立的层次结构。这些层次结构使得通过多态性通过平台无关的基类接口访问平台相关的实现成为可能。对于pdCalc，这种模式转化为提供平台不可知的Settings和DynamicLoader层次结构，分别抽象持久性设置和动态加载。例如，我们可以通过抽象的DynamicLoader接口多态地分配和释放插件，前提是系统根据平台实例化正确的底层派生类（PosixDynamicLoader或WindowsDynamicLoader）。抽象工厂的这一部分由图7-3中的DynamicLoader层次结构表示。</p>
<p>现在的问题缩小为根据当前平台实例化正确的派生类。我们不是提供单独的工厂函数来实例化DynamicLoader和Settings对象（这是一种分散的方法，需要在每个工厂中分别使用平台的#ifdefs），而是创建一个层次结构，为创建DynamicLoader和Settings对象提供必要的工厂函数的抽象接口。然后，该抽象工厂层次结构（图7-3中的PlatformFactory层次结构）针对平台进行专门化，以便我们拥有工厂层次结构的平台特定派生类，创建功能层次结构的平台特定派生类。这种方案将平台依赖性集中到一个实例化正确的PlatformFactory专门化的工厂函数中。在pdCalc的实现中，我选择将PlatformFactory设为单例，从而在Instance()函数中“隐藏”PlatformFactory的工厂函数。</p>
<p>抽象工厂模式可能仍然没有多少意义，所以让我们看一些示例代码，从上到下查看抽象。归根结底，抽象工厂模式使我们能够在pdCalc中编写以下平台无关的高级代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PlatformFactory Instance returns either a PosixFactory or a</span></span><br><span class="line"><span class="comment">// WindowsFactory instance (based on the platform), which in turn</span></span><br><span class="line"><span class="comment">// creates the correct derived DynamicLoader</span></span><br><span class="line"><span class="keyword">auto</span> loader = PlatformFactory::<span class="built_in">Intance</span>().<span class="built_in">createDynamicLoader</span>();</span><br><span class="line"><span class="comment">// The correctly instantiated loader provides platform specific</span></span><br><span class="line"><span class="comment">// dynamic loading functionality polymorphically through a platform</span></span><br><span class="line"><span class="comment">// independent interface</span></span><br><span class="line"><span class="keyword">auto</span> plugin = loader-&gt;<span class="built_in">allocatePlugin</span>(pName);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">loader-&gt;<span class="built_in">deallocatePlugin</span>(plugin);</span><br><span class="line"><span class="comment">// Same principle for settings ...</span></span><br><span class="line"><span class="keyword">auto</span> settings = PlatformFactory::<span class="built_in">Instance</span>().<span class="built_in">createSettings</span>();</span><br><span class="line">settings-&gt;<span class="built_in">readSettingsFromDisk</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">settings-&gt;<span class="built_in">commitSettingsToDisk</span>();</span><br></pre></td></tr></table></figure>
<p>深入挖掘，我们首先要检查的是PlatformFactory的Instance()函数，根据平台返回PosixFactory或WindowsFactory。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PlatformFactory&amp; <span class="title">PlatformFactory::Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> POSIX</span></span><br><span class="line"><span class="type">static</span> PosixFactory instance;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> WIN32</span></span><br><span class="line"><span class="type">static</span> WindowsFactory instance;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数在执行一些微妙但聪明的操作，这是一个值得了解的技巧。从客户端的角度来看，PlatformFactory看起来像一个普通的单例类。调用Instance()函数，返回一个PlatformFactory引用。然后，客户端像使用任何其他单例类一样使用PlatformFactory的公共接口。然而，由于Instance()成员函数返回一个引用，我们可以自由地多态地使用该实例。由于PosixFactory和WindowsFactory都继承自PlatformFactory，实例化的实例变量是与由实现中的#ifdef定义的平台匹配的专门化。我们巧妙地掩饰了一个实现细节，抽象工厂模式的机制，从类的用户中。除非客户端注意到PlatformFactory中的工厂函数是纯虚函数，否则他可能不会意识到他正在使用面向对象的层次结构。当然，目标不是在一个邪恶的计划中向用户隐藏任何东西以模糊实现。相反，这种信息隐藏是为了减轻PlatformFactory客户端的复杂性负担。</p>
<p>接下来我们检查PosixFactory和WindowsFactory类中createDynamicLoader()函数的简单实现（注意函数的协变返回类型）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;DynamicLoader&gt; <span class="title">PosixFactory::createDynamicLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;PosixDynamicLoader&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">unique_ptr&lt;DynamicLoader&gt; <span class="title">WindowsFactory::createDynamicLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;WindowsDynamicLoader&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面，我们仅仅用一个类层次结构替换了动态加载器工厂函数（见清单7-1），用多态性替换了平台的#ifdefs。对于只有一个功能依赖于平台的情况，用抽象工厂替换工厂函数肯定是过犹不及。然而，在我们的示例中，我们有独立的DynamicLoader和Settings家族，它们都依赖于相同的平台标准（原则上，我们可以有任意数量的这样的层次结构），抽象工厂模式允许我们将平台依赖性集中在一个位置（这里是PlatformFactory的Instance()函数），而不是将其分散在多个独立的工厂函数中。从维护的角度来看，价值主张类似于多态性优于switch语句。</p>
<p>谜题的最后一部分是DynamicLoader和Settings层次结构的实现。幸运的是，这些实现与第7.3.3节中概述的想法相同，我在这里不需要重复它们的实现。实际上，抽象工厂模式并不增加对平台相关功能实现的固有复杂性。该模式仅在一个工厂层次结构中添加了通过单个工厂层次结构而不是一系列工厂函数实例化这些类的机制。</p>
<p>在pdCalc的代码库中的源代码中，没有Settings层次结构（或者其在PlatformFactory中关联的readSettingsFromDisk()和commitSettingsToDisk()函数）的实现，因为就像编写的pdCalc一样，没有需要持久设置抽象。Settings层次结构仅仅是作为一个合理的例子来具体展示抽象工厂模式的机制和相关性。也就是说，我确实选择在pdCalc的代码中为DynamicLoader单独包含一个完整的抽象平台工厂实现，只是为了说明抽象工厂模式的实际实现，尽管一个更简单的单一工厂函数就足够了，而且更适合生产代码。</p>
<h2 id="7-4-问题3：重构pdCalc">7.4 问题3：重构pdCalc</h2>
<p>现在我们来看最后一个插件问题，即重构已开发的类和接口以适应动态添加计算器功能。这个问题与插件管理无关。相反，我们在这里要解决的问题是扩展pdCalc的模块接口以接受插件功能。本质上，第7.2节定义了如何在插件中发现命令和按钮，这一节描述了如何将这些新发现的命令整合到pdCalc中。</p>
<p>让我们首先创建一个接口，以便在注入新发现的插件命令时启用。回顾第4章，当应用程序启动时，核心命令是如何加载到CommandRepository中的。首先，主应用程序调用RegisterCoreCommands()函数。其次，在此函数中，对于每个核心命令，调用CommandRepository类的registerCommand()函数，将命令的名称和命令原型注册到CommandRepository。在第7.2节中，我们开发了一个用于从插件中导出命令名称和命令原型的接口。显然，要注册这些插件命令，我们只需扩展命令调度模块的接口，包括registerCommand()函数。然而，这种接口扩展引发了一个有趣的问题。在C++这样一个没有正式模块定义的语言中，扩展模块接口意味着什么？</p>
<h4 id="7-4-1-模块接口">7.4.1 模块接口</h4>
<p>迄今为止，我们尚未严格定义实现或描述模块的机制。我们只是宽松地声明某些类是某些模块的一部分（例如，CommandRepository是命令调度器模块的一部分）。但这实际上意味着什么？C++语言，就目前而言，并未实现模块概念。因此，模块本质上是一种元语言概念，而语言本身在强制执行模块接口方面提供了很少的帮助。然而，我们确实有一些基本的选项来定义模块及其接口。首先，将不直接作为接口的所有类封装在一个源文件中，并仅在单个头文件中公开有限的模块接口。其次，将每个模块构建到一个单独的DLL中，并使用DLL符号导出机制来有选择性地导出接口函数。第三，通过文档和注释中的声明隐式地定义模块边界。让我们来探讨这些选项。</p>
<h4 id="7-4-1-1-源代码隐藏">7.4.1.1 源代码隐藏</h4>
<p>让我们从讨论C程序员一直可用的封装模型开始：在源文件中隐藏非公共接口类和函数，不在头文件中公开它们的接口。这是C++为真正隐藏符号提供的唯一机制（请记住，访问修饰符，如private，不能用于类本身，就像在Java或C#中可能的那样）。您已经在pimpl模式背后看到了这种机制用于隐藏类细节。</p>
<p>在模块级别，这种封装方案意味着一个模块的所有源代码必须驻留在一个单独的源文件中，只有模块接口的公共部分会出现在一个单独的模块头文件中。例如，对于pdCalc的命令调度模块，只有CommandDispatcher和Command接口会出现在一个单独的头文件中，而CommandDispatcher类的定义以及所有具体命令、CommandRepository和CommandManager的声明和定义将驻留在一个单独的源文件中。源代码隐藏的最大缺点是，对于复杂的模块，它可能导致非常大的单个文件。大型文件由于体积庞大而难以阅读，并且由于模块中的任何更改都需要重新编译所有代码，因此即使是最小的更改也会导致漫长的编译时间。这种技术的优点是它可以在C++语言中原生实现，而且不需要每个模块驻留在一个单独的动态链接库中。</p>
<p>我亲自见过至少一个开源软件包采用这种策略。从技术角度看，虽然它确实实现了模块接口的隐藏，但结果是整个库分布在一个单独的头文件和一个单独的源文件中。头文件超过3000行，源文件接近20000行。我无法想象这种解决方案在可读性或可维护性方面是否被优化设计。据我所知，这个开源软件包只有一个作者。因此，对于一个开发者团队来说，可读性和可维护性不太可能是他的主要目标。</p>
<h4 id="7-4-1-2-DLL隐藏">7.4.1.2 DLL隐藏</h4>
<p>如果您使用C++，拥有大型代码库，并希望真正隐藏模块接口，使用DLL隐藏是最合理的选择。当然，使用这个选项超出了C++语言本身的范畴。DLL隐藏基于操作系统的库格式，并通过编译器指令实现。本质上，程序员用特殊的编译器指令修饰类或函数，以指示是否要从DLL中导入或导出函数。编译器然后创建一个只公开导出适当标记的符号的DLL，链接到DLL的代码必须指定它打算导入的符号。由于在编译DLL时，同一个头文件需要标记为导出，而在编译使用DLL的代码时需要标记为导入，因此实现通常是通过使用特定于编译器/操作系统的预处理器指令来完成的。例如，在Windows中，会使用以下代码（或类似的变体）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declspec .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BUILDING_DLL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLSPEC __declspec(export)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLSPEC __declspec(import)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们想要从DLL中导出的函数foo()的声明应该写为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Declspec.h&quot;</span></span></span><br><span class="line"><span class="function">DECLSPEC <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>当构建DLL时，预处理器宏BUILDING_DLL被定义；因此，DECLSPEC宏展开为__declspec(export)。当使用DLL时，BUILDING_DLL宏未定义，DECLSPEC宏展开为__declspec(import)。任何未用DECLSPEC宏修饰的函数或类都保持为DLL的私有。GCC使用略有不同的语法实现类似的机制。</p>
<p>大多数Windows程序员非常熟悉用于控制模块接口的DLL隐藏机制，因为在Visual Studio中，全局隐藏DLL中的符号是默认范例。如果一个符号没有修饰，它将不会从DLL中导出。因此，为了制作一个可以从外部调用的DLL（还有其他种类吗？），Windows程序员必须使用__declspec指令手动导出符号。然而，许多UNIX程序员对DLL隐藏并不熟悉，因为默认的共享库实现公开导出所有符号。也就是说，在典型的UNIX或Linux系统中，共享库代码中没有必要将符号修饰为导出或导入，因为当共享库加载时，链接器会将共享库中的所有符号公开提供给调用程序。如果需要，编译器命令行选项可以将默认可见性从公共更改为私有，并且可以手动标记符号以类似于Windows构建的方式导入或导出。</p>
<p>我开始这一节时说，如果你想要真正隐藏大型C<ins>代码库中模块接口，使用DLL隐藏是最合理的选择。只要你愿意为每个模块分配一个单独的DLL，它可以为模块访问控制提供非常精细的粒度。这种技术的主要缺点在于可读性、可维护性和可移植性。使用这种技术确实需要为每个可导出的函数使用编译器和操作系统特定的装饰器，这些装饰器并不是C</ins>语言的一部分。尽管对于每个函数或类来说，额外的DECLSPEC宏并不是难以忍受的，但在考虑多个操作系统或多个编译器时，宏的定义可能很快变得难以处理。此外，当构建或使用DLL时忘记定义正确的预处理器宏可能会让初学者感到困惑。最后，在模板代码存在的情况下正确实现DLL导入和导出可能并非易事。</p>
<h4 id="7-4-1-3-隐式或文档隐藏">7.4.1.3 隐式或文档隐藏</h4>
<p>我所说的隐式隐藏技术实际上就是通过不记录接口来隐藏它。实际操作中，这意味着什么呢？由于C++语言不直接支持模块，隐式隐藏只是在一组类和函数周围绘制一个逻辑结构，并声明这些类组成一个模块。语言允许从模块外部的代码调用任何类的公共函数。因此，模块的公共接口是通过仅记录应该从外部调用的函数来“声明”的。从纯技术角度来看，隐式隐藏根本不是隐藏！</p>
<p>为什么有人会选择隐式隐藏而不是源代码隐藏或DLL隐藏呢？很简单，这个选择是出于方便。使用隐式隐藏允许开发者以逻辑、可读和可维护的方式组织类和源代码。每个类（或一组紧密相关的类）可以分组到自己的头文件和源文件对中。这使得只包含必要的代码，从而加快编译时间。隐式隐藏还不强制将包含的边界定义纳入特定的共享库，如果设计目标是最小化与软件包一起发布的单个共享库的数量，这可能很重要。</p>
<p>当然，隐式隐藏的问题在于，没有语言机制可以防止在逻辑模块之外使用设计师未打算使用的函数和类。这是一个严重的问题吗？为什么我们可能想强制阻止用户调用部分被认为不是公共的接口？主要的设计原因是，我们不希望用户依赖于未记录的功能，因为非公共接口可能会发生变化。不出所料，这个原因与我们珍视类设计中的封装的原因是一样的。也就是说，实现应该允许独立于接口进行更改。那么，强制隐藏非公共接口有多重要呢？最终，这取决于你是否信任你的代码的用户，他们要么不调用未记录的接口，要么至少接受由于对未记录接口的更改而强制进行的非计划性维护的所有权。</p>
<h4 id="7-4-1-4-pdCalc的模块设计">7.4.1.4 pdCalc的模块设计</h4>
<p>在pdCalc的设计中，我选择使用隐式隐藏。对于这个项目，我认为简单性的优势超过了使用其他模块接口隐藏方式所需的复杂性。你为自己的项目选择哪种技术自然取决于你的个人喜好。鉴于pdCalc相对较小的代码库，使用隐式隐藏可以使类按逻辑分组，而不是沿着模块边界分组。此外，隐式隐藏允许将几个模块（例如，命令调度器、堆栈和插件管理）合并到一个共享的后端库中。</p>
<p>我选择使用隐式隐藏对解决将命令调度器模块接口扩展到包含CommandRepository类的registerCommand()函数的原始问题有直接影响。这种扩展可以通过文档更改简单地实现。从本质上讲，可以通过更新第2章中的表2-2将此函数添加到接口中。</p>
<p>隐式隐藏没有特定的语言支持功能，所以你不能指向一个特定的类并说：“这个头定义了模块的接口。”相反，文档用于在选定的公共类和函数周围画出一个隐式的线条，这些类和函数定义了模块的接口。因此，一旦文档被更改，main() 函数可以在插件加载过程中通过调用 CommandRepository 的现有 registerCommand() 函数注入插件命令。为了使 pdCalc 支持插件命令注入，无需更改代码。</p>
<h3 id="7-4-2-向GUI添加插件按钮">7.4.2 向GUI添加插件按钮</h3>
<p>回顾一下本节开始时，我们概述了在为插件改装 pdCalc 时要解决的两个问题。第一个问题，我们刚刚解决了，是在加载插件后如何将插件命令添加到 CommandRepository。解决方案事实上非常简单，因为我们已经编写了必要的函数，只需要扩展模块定义的公共接口。第二个问题涉及改装 pdCalc，使其能够将与插件命令相对应的按钮添加到 GUI。</p>
<p>根据我们的命令调度器的设计，一旦命令被注册，任何用户界面都可以通过将命令的名称作为事件的参数来触发 commandEntered() 事件来执行它。因此，对于 CLI，用户可以通过键入其名称来执行插件命令。也就是说，一旦注册了插件命令，它们就立即可以在 CLI 中使用。当然，在 GUI 中访问插件命令稍微复杂一些，因为每个发现的插件命令都必须创建一个可以触发 commandEntered() 事件的按钮。</p>
<p>在第7.2节中，我们定义了一个用于标记 CommandButtons 的接口。每个插件提供一个 PluginButtonDescriptor，定义主要命令标签、次要命令标签以及与标签关联的底层命令。因此，为了添加一个与插件命令对应的新 GUI 按钮，我们只需扩展 GUI 的 MainWindow 类的接口，包括根据标签添加按钮的功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow, <span class="keyword">public</span> UserInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Existing interface plus the following:</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCommandButton</span><span class="params">(<span class="type">const</span> string&amp; dispPrimaryCmd,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> string&amp; primaryCmd, <span class="type">const</span> string&amp; dispShftCmd,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> string&amp; shftCmd)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，这个功能还需要根据某种合适的算法来布局按钮。我的简单算法只是将按钮从左到右排列，每行放置四个按钮。</p>
<p>正如在第6章简要提到的，MainWindow 类还包括一个 setupFinalButtons() 函数和一个 fixSize() 函数。setupFinalButtons() 函数将撤消、重做和 proc（见第8章）按钮作为 GUI 的顶行添加。fixSize() 函数强制使 GUI 的几何形状保持在当前尺寸固定。只有在添加了所有插件按钮之后，才能逻辑上调用这些操作。</p>
<p>与 CommandRegistry 的 registerCommand() 函数不同，addCommandButton() 不是 MainWindow 类的预先存在的公共函数。因此，我们必须添加并实现这个新功能。很可能，一个模块化的 GUI 实现已经在 GUI 模块中的某个地方有了类似的功能，因为创建核心命令按钮已经需要这个功能。因此，实现 addCommandButton() 函数可能就像从 MainWindow 向适当的内部 GUI 类转发此调用一样简单，在那里该功能可能已经存在。</p>
<h2 id="7-5-整合插件">7.5 整合插件</h2>
<p>到目前为止，我们已经讨论了 C++ 插件的指南、插件接口、插件命令内存管理、加载和卸载插件、通过接口抽象平台相关代码的设计模式以及改装 pdCalc 以启用插件命令和 GUI 注入。然而，我们尚未讨论查找插件、从磁盘实际加载和卸载插件、管理插件的生命周期或将插件功能注入 pdCalc 的任何机制。这些操作由 PluginLoader 类和应用程序的 main() 函数执行，现在将进行描述。</p>
<h3 id="7-5-1-加载插件">7.5.1 加载插件</h3>
<p>通过 PluginLoader 类实现插件的加载。PluginLoader 负责查找插件动态库文件，将插件加载到内存中，并根据需求将具体的 Plugin 专门化提供给 pdCalc。PluginLoader 还负责在适当的时候释放插件资源。正如我们之前看到的，良好的设计将通过 RAII 实现自动释放。</p>
<p>加载插件的第一步是确定应该加载哪些插件以及何时加载。实际上，回答这个问题只有两个实际选项。插件是在程序启动时由 pdCalc 自动加载（例如，配置文件中指定的文件或特定目录中的所有 DLL），还是根据用户的直接请求按需加载。当然，这些选项并不是互斥的，可以设计一个 PluginLoader 类，结合这两个选项，可能还具有让用户指导将来自动加载哪些手动加载的插件的功能。如何加载插件没有正确或错误的答案。这个决定必须根据程序的需求来解决。</p>
<p>为了简单起见，我选择实现一个在 pdCalc 启动期间自动加载插件的插件加载器。PluginLoader 通过读取一个由每行文本单独列出插件文件名的 ASCII 配置文件来找到这些插件。配置文件被任意命名为 plugins.pdp，该文件必须位于当前可执行路径中。在 plugins.pdp 中列出的插件文件可以使用相对路径或绝对路径来指定。一个更复杂的插件加载器实现可能会将插件文件的位置存储在操作系统特定的配置位置（例如，Windows 注册表），并使用更好的文件格式，如 XML。像 Qt 这样的好库可以帮助您解析 XML 并使用平台无关的抽象来查找特定于系统的配置文件。</p>
<p>考虑到上述插件加载器设计约束，PluginLoader 接口非常简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PluginLoader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadPlugins</span><span class="params">(UserInterface&amp; ui, <span class="type">const</span> string&amp; pluginFileName)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> vector&lt;<span class="type">const</span> Plugin*&gt; <span class="title">getPlugins</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>loadPlugins() 函数将配置文件的名称作为输入，将每个库加载到内存中，并为每个库的 Plugin 类分配一个实例。UserInterface 引用仅用于错误报告。当 main() 函数准备好注入插件命令时，调用 getPlugins() 函数返回已加载插件的集合。当然，loadPlugins() 和 getPlugins() 函数可以合并，但我更喜欢一种能让程序员保留更精细的插件加载与插件使用时机控制的设计。我的 PluginLoader 实现使用了一些巧妙的技巧，利用 RAII 管理插件自动释放。由于这里的实现与设计无关，有兴趣的读者可以参考 PluginLoader.cpp 源文件了解详细信息。</p>
<h3 id="7-5-2-注入功能">7.5.2 注入功能</h3>
<p>决定插件应该从配置文件自动加载后，插件加载在 main() 函数调用树中的最佳位置。从本质上讲，这个 loadPlugins() 函数只是将我们之前讨论过的所有部分组合在一起：加载插件库、加载插件、从插件描述符中提取命令和按钮，并将这些命令和按钮注入 pdCalc。当然，一个合适的实现还会对插件进行错误检查。例如，错误检查可能包括检查插件 API 版本、确保命令尚未注册以及确保 GUI 按钮与命令存储库中的命令相对应。Listing 7-2 是加载插件功能的一个框架。它的输入是一个用于报告错误的 UserInterface 引用和一个 PluginLoader 引用。</p>
<p>Listing 7-2 加载插件的功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setupPlugins</span><span class="params">(UserInterface&amp; ui, PluginLoader&amp; loader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loader.<span class="built_in">loadPlugins</span>(ui, <span class="string">&quot;plugins.pdp&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> plugins = loader.<span class="built_in">getPlugins</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : plugins) &#123;</span><br><span class="line">        <span class="keyword">auto</span> apiVersion = p-&gt;<span class="built_in">apiVersion</span>();</span><br><span class="line">        <span class="comment">// verify plugin API at correct level</span></span><br><span class="line">        <span class="comment">// inject plugin commands into CommandRepository - recall</span></span><br><span class="line">        <span class="comment">// the cloned command will auto release in the plugin</span></span><br><span class="line">        <span class="keyword">auto</span> descriptor = p-&gt;<span class="built_in">getPluginDescriptor</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; descriptor.nCommands; ++i) &#123;</span><br><span class="line">            <span class="built_in">registerCommand</span>(ui, descriptor.commandNames[i],</span><br><span class="line">                <span class="built_in">MakeCommandPtr</span>(descriptor.commands[i]-&gt;<span class="built_in">clone</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if gui, setup buttons</span></span><br><span class="line">        <span class="keyword">auto</span> mw = <span class="built_in">dynamic_cast</span>&lt;MainWindow*&gt;(&amp;ui);</span><br><span class="line">        <span class="keyword">if</span> (mw) &#123;</span><br><span class="line">            <span class="keyword">auto</span> buttonDescriptor = p-&gt;<span class="built_in">getPluginButtonDescriptor</span>();</span><br><span class="line">            <span class="keyword">if</span> (buttonDescriptor) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; buttonDescriptor-&gt;nButtons; ++i) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> b = *buttonDescriptor;</span><br><span class="line">                    <span class="comment">// check validity of button commands</span></span><br><span class="line">                    mw-&gt;<span class="built_in">addCommandButton</span>(b.dispPrimaryCmd[i], </span><br><span class="line">                        b.primaryCmd[i], b.dispShftCmd[i], b.shftCmd[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在详细描述如何实现 C++ 插件的长篇章节之后，结局有点反高潮，因为大部分机制在抽象的更深层次上处理。当然，正如你在本书中学到的，这种“无聊”只是通过精心设计实现的。简单性总是比代码本身显示的更难实现。如果在这种高级抽象中出现了任何泄漏，那肯定意味着设计不佳。</p>
<h2 id="7-6-一个具体的插件">7.6 一个具体的插件</h2>
<p>在详细讨论如何将原生 C++ 插件整合到 pdCalc 之后，我们终于到了可以实现一个具体插件的地方。根据我们在第 1 章中的需求，我们需要编写一个添加自然对数、其逆指数算法以及双曲三角函数命令的插件。当然，你可以随意添加包含任何你可能喜欢的功能的插件。例如，两个有趣的插件可能是概率插件和统计插件。概率插件可以计算排列、组合、阶乘和随机数，而统计插件可以计算均值、中位数、众数和标准差。然而，现在我们只需考虑双曲线、自然对数插件的设计和实现。</p>
<h3 id="7-6-1-插件接口">7.6.1 插件接口</h3>
<p>HyperbolicLnPlugin 的实现实际上非常简单。我们将从类的接口开始，然后，不同寻常地，研究一些实现细节。为进一步研究而选择的代码突出了与原生 C++ 插件相关的特定细节。</p>
<p>HyperbolicLnPlugin 的接口由特殊化 Plugin 类的类定义以及所需的插件分配和释放函数给出；参见 Listing 7-3。</p>
<p>Listing 7-3 HyperbolicLnPlugin接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HyperbolicLnPlugin</span> : <span class="keyword">public</span> pdCalc::Plugin &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">HyperbolicLnPluginImpl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HyperbolicLnPlugin</span>();</span><br><span class="line">    ~<span class="built_in">HyperbolicLnPlugin</span>();</span><br><span class="line">    <span class="function"><span class="type">const</span> PluginDescriptor&amp; <span class="title">getPluginDescriptor</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> PluginButtonDescriptor* <span class="title">getPluginButtonDescriptor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    pdCalc::<span class="function">Plugin::ApiVersion <span class="title">apiVersion</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unique_ptr&lt;HyperbolicLnPluginImpl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span>* <span class="title">AllocPlugin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">DeallocPlugin</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
</li>
</ul>
<p>正如预期的那样，该类实现了 Plugin 类中的三个纯虚函数，并将大部分实现推迟到一个私有实现类。AllocPlugin() 和 DeallocPlugin() 函数具有显而易见的实现。AllocPlugin() 只需返回一个新的 HyperbolicLnPlugin 实例，而 DeallocPlugin() 函数将其 void* 参数转换为 Plugin*，然后在此指针上调用 delete。注意，插件根据定义不是主程序的一部分，因此不应该是 pdCalc 命名空间的一部分。因此，在某些位置有明确的命名空间限定。</p>
<p>HyperbolicLnPluginImpl 类的责任仅仅是根据需求提供插件描述符，并管理描述符所需对象的生命周期。PluginDescriptor 提供插件实现的命令名称和相应的命令。这些命令将在下面的第 7.6.3 节中描述。插件的 PluginButtonDescriptor 只需列出由 PluginDescriptor 定义的命令名称以及将出现在 GUI 按钮上的相应标签。因为 HyperbolicLnPlugin 中的命令都有自然的逆，我们只需用前向命令标记每个按钮，并将次要（移位）命令附加到逆。我为插件提供的命令使用了显而易见的标签：sinh、asinh、cosh、acosh、tanh、atanh、ln 和 exp。你选择 ln 作为主要命令，exp 作为次要命令，还是反过来，只是个人喜好问题。</p>
<p>出于已经讨论过的原因，插件描述符在不使用 STL 容器的情况下传输内容。在接口中，我们通常更喜欢使用向量和 unique_ptrs 来管理资源，但我们被迫使用原始数组。当然，pimpl 提供的封装使得我们可以实现所需的任何内存管理方案。对于 HyperbolicLnPlugin，我选择了一种使用字符串、unique_ptrs 和向量的复杂自动内存管理方案。使用 RAII 内存管理方案的优点是，我们可以确保在异常出现时（即在构造过程中抛出的内存不足异常）插件不会泄漏内存。实际上，我不希望计算器在低内存环境中执行，即使是在这种情况下，插件分配期间泄漏内存也不太可能有什么影响，因为用户在这种情况下可能的下一个操作是重启计算机。因此，回顾起来，在构造函数中使用裸露的 new 和析构函数中的 delete 的更简单的内存管理方案可能更加务实。</p>
<h3 id="7-6-2-源代码依赖反转">7.6.2 源代码依赖反转</h3>
<p>令人惊讶的是，上面的 HyperbolicLnPlugin 类声明确实是插件的完整接口。我之所以感到惊讶，是因为乍一看，人们可能会惊讶地发现插件的接口与插件提供的功能之间没有关系。当然，这种情况恰恰是如此。插件提供的计算器功能实际上仅仅是一个实现细节，可以完全包含在插件的实现文件中。</p>
<p>不应忽视上述微妙之处，即 pdCalc 只知道插件的接口，而对功能本身一无所知。事实上，源代码依赖性反转是插件设计的全部要点。那么，什么是源代码依赖性反转，为什么它如此重要？要回答这个问题，我们必须先进行一次简短的历史回顾。</p>
<p>传统上（想想20世纪70年代的Fortran），代码是通过简单地编写新函数和子程序来扩展的。这种方法的主要设计问题是，要求主程序调用新函数使主程序与任何扩展的具体接口相绑定。因此，主程序变得依赖于扩展作者定义的接口更改。也就是说，每个新扩展都定义了一个主程序必须遵循的新接口。这种设置非常脆弱，因为主程序需要不断修改以跟上其扩展接口的变化。由于每个新扩展都需要对主程序的源代码进行独特的修改，因此处理扩展的主程序代码的复杂性与扩展数量成线性增长。如果这还不够糟糕的话，添加新功能总是需要重新编译和重新链接主程序。具体而言，想象一下，每次添加新的插件命令时，都需要修改、重新编译和重新链接 pdCalc 的源代码的设计。</p>
<p>上述问题可以通过函数指针和回调来解决，尽管这种方法有些不优雅和笨拙，但不需要面向对象编程。然而，随着面向对象编程的兴起，特别是继承和多态，依赖问题以一种类型安全的方式得到了语言支持的解决方案。这些技术使源代码依赖性反转的普及成为可能。具体而言，源代码依赖性反转是指主程序定义一个接口（例如，我们在本章中研究的插件接口），所有扩展都必须符合这个接口。根据这种策略，扩展要服从主程序的接口，而不是相反。因此，主程序可以通过插件进行扩展，而无需修改、重新编译或重新链接主程序的源代码。更重要的是，可扩展性的接口是由应用程序而不是插件决定的。具体而言，pdCalc 提供了插件接口类来定义新功能的添加，但 pdCalc 从不了解其扩展的实现细节。不符合 pdCalc 接口的插件根本无法注入新命令。</p>
<h3 id="7-6-3-实现-HyperbolicLnPlugin-的功能">7.6.3 实现 HyperbolicLnPlugin 的功能</h3>
<p>在这个阶段，我们知道 HyperbolicLnPlugin 将通过为每个操作实现一个命令类来提供其功能。在实现了一些这样的类之后，人们会很快注意到插件中的所有命令都是一元命令。不幸的是，基于 C++ 插件的第三条规则（假设不兼容的对齐），我们不能继承 UnaryCommand 类，而必须继承 PluginCommand 类。请注意，我们的对齐假设甚至排除了通过多重继承使用 UnaryCommand 类，我们必须在 HyperbolicLnPluginCommand 基类中重新实现一元命令功能。虽然这感觉有点重复，但 C++ 插件的规则让我们没有其他选择（尽管我们可以为 UnaryPluginCommand 和 UnaryBinaryCommand 提供源代码，但这些必须与每个插件单独编译）。</p>
<p>因此，我们最终得到了 HyperbolicLnPlugin 中所有命令派生的接口类；请参见清单7-4。</p>
<p>清单7-4 HyperbolicLnPluginCommand 类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HyperbolicLnPluginCommand</span> : <span class="keyword">public</span> pdCalc::PluginCommand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HyperbolicLnPluginCommand</span>() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">HyperbolicLnPluginCommand</span><span class="params">(<span class="type">const</span> HyperbolicLnPluginCommand&amp; rhs)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">HyperbolicLnPluginCommand</span>() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">checkPluginPreconditions</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">HyperbolicLnPluginCommand* <span class="title">clonePluginImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HyperbolicLnPluginCommand* <span class="title">doClone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">unaryOperation</span><span class="params">(<span class="type">double</span> top)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> top_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与 UnaryCommand 类一样，HyperbolicLnPluginCommand 类实现了纯虚拟的 executeImpl() 和 undoImpl() 命令，将命令操作委托给纯虚拟的 unaryOperation() 函数。此外，HyperbolicLnPluginCommand 类实现了 checkPluginPreconditions() 函数，以确保在调用命令之前堆栈上至少有一个数字。该函数受保护，以便子类可以直接覆盖前提条件函数，如果必须实现任何额外的前提条件，同时仍然调用基类的 checkPluginPreconditions() 来进行一元命令前提条件检查。</p>
<p>deallocate() 和 clonePluginImpl() 函数有明显的实现，但在插件中起着关键作用。deallocate() 函数的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HyperbolicLnPluginCommand::deallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回顾一下，deallocate() 函数的目的是强制在插件的编译单元中释放插件命令的内存。当销毁持有命令的 unique_ptr 时，通过 CommandDeleter() 函数调用它。</p>
<p>clonePluginImpl() 函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HyperbolicLnPluginCommand*</span></span><br><span class="line"><span class="function"><span class="title">HyperbolicLnPluginCommand::clonePluginImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HyperbolicLnPluginCommand* p;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        p = <span class="built_in">doClone</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数的唯一目的是适应插件命令的克隆，以确保异常不会跨越插件和主应用程序之间的内存边界。</p>
<p>完成 HyperbolicLnPlugin 的所有剩余部分是为插件中所需的每个数学操作继承 HyperbolicLnPluginCommand，并实现其余的纯虚拟函数（unaryOperation()、doClone() 和 helpMessageImpl()）。此时，这些函数的实现与第 4 章的一元函数实现无异。有兴趣的读者可以参考 HyperbolicLnPlugin.cpp 中的源代码了解详细信息。</p>
<h2 id="7-7-下一步">7.7 下一步</h2>
<p>在关于 C++ 插件的较长讨论之后，并通过实现双曲三角函数和自然对数插件，我们完成了第 1 章中提出的 pdCalc 的需求。按照最初的描述，计算器已经完成！好吧，版本 1.0 已经完成了。然而，作为有经验的软件开发人员，我们知道任何“完成”的产品都只是在客户要求新功能之前的一个临时里程碑。下一章将处理这种情况，我们将修改我们的设计以包含未计划的扩展。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">漫艺海</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/">http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">漫艺海的blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Practical-C-Design-From-Programming-to-Architecture-1ed/">Practical C++ Design From Programming to Architecture 1ed</a></div><div class="post_share"><div class="social-share" data-image="/img/logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/" title="8. 新的需求"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">8. 新的需求</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/" title="5. 命令行接口"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">5. 命令行接口</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/1.Defining-the-Case-Study/" title="1. 定义案例研究"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">1. 定义案例研究</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/" title="3. 堆栈"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">3. 堆栈</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/2.Decomposition/" title="2. 分解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">2. 分解</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/" title="5. 命令行接口"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">5. 命令行接口</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/" title="4. 命令分发器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">4. 命令分发器</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/" title="8. 新的需求"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">8. 新的需求</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">漫艺海</div><div class="author-info__description">漫艺海的个人站，主要涉及C++知识共享、实践教程等方面</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">7. 插件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%92%E4%BB%B6%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">7.1 什么是插件？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-C-%E6%8F%92%E4%BB%B6%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.1.1.</span> <span class="toc-text">7.1.1 C++ 插件的规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E9%97%AE%E9%A2%981%EF%BC%9A%E6%8F%92%E4%BB%B6%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">7.2 问题1：插件接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E5%8F%91%E7%8E%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text">7.2.1 发现命令的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E6%B7%BB%E5%8A%A0%E6%96%B0GUI%E6%8C%89%E9%92%AE%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">7.2.2 添加新GUI按钮的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-%E6%8F%92%E4%BB%B6%E5%88%86%E9%85%8D%E5%92%8C%E9%87%8A%E6%94%BE"><span class="toc-number">1.2.3.</span> <span class="toc-text">7.2.3 插件分配和释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-%E6%8F%92%E4%BB%B6%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.4.</span> <span class="toc-text">7.2.4 插件命令接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-API-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.5.</span> <span class="toc-text">7.2.5 API 版本控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-6-%E6%8F%90%E4%BE%9B%E5%A0%86%E6%A0%88%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.6.</span> <span class="toc-text">7.2.6 提供堆栈功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E9%97%AE%E9%A2%98-2%EF%BC%9A%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">7.3 问题 2：加载插件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E7%89%B9%E5%AE%9A%E4%BA%8E%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.3.1.</span> <span class="toc-text">7.3.1 特定于平台的插件加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E5%8A%A0%E8%BD%BD%E3%80%81%E4%BD%BF%E7%94%A8%E5%92%8C%E5%85%B3%E9%97%AD%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-number">1.3.2.</span> <span class="toc-text">7.3.2 加载、使用和关闭共享库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-%E5%A4%9A%E5%B9%B3%E5%8F%B0%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.3.</span> <span class="toc-text">7.3.3 多平台代码的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-1-%E6%98%BE%E8%80%8C%E6%98%93%E8%A7%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%BA%93"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">7.3.3.1 显而易见的解决方案：库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-2-%E5%8E%9F%E5%A7%8B%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">7.3.3.2 原始预处理器指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-3-%EF%BC%88%E7%A8%8D%E5%BE%AE%EF%BC%89%E6%9B%B4%E8%81%AA%E6%98%8E%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">7.3.3.3 （稍微）更聪明的预处理器指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-4-%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">7.3.3.4 构建系统解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-5-%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">7.3.3.5 平台工厂函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-6-%E7%94%A8%E4%BA%8E%E9%80%9A%E7%94%A8%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">7.3.3.6 用于通用平台无关代码的抽象工厂</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E9%97%AE%E9%A2%983%EF%BC%9A%E9%87%8D%E6%9E%84pdCalc"><span class="toc-number">1.4.</span> <span class="toc-text">7.4 问题3：重构pdCalc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-%E6%A8%A1%E5%9D%97%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">7.4.1 模块接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-1-%E6%BA%90%E4%BB%A3%E7%A0%81%E9%9A%90%E8%97%8F"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">7.4.1.1 源代码隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-2-DLL%E9%9A%90%E8%97%8F"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">7.4.1.2 DLL隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-3-%E9%9A%90%E5%BC%8F%E6%88%96%E6%96%87%E6%A1%A3%E9%9A%90%E8%97%8F"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">7.4.1.3 隐式或文档隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-4-pdCalc%E7%9A%84%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.0.5.</span> <span class="toc-text">7.4.1.4 pdCalc的模块设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-%E5%90%91GUI%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6%E6%8C%89%E9%92%AE"><span class="toc-number">1.4.1.</span> <span class="toc-text">7.4.2 向GUI添加插件按钮</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%95%B4%E5%90%88%E6%8F%92%E4%BB%B6"><span class="toc-number">1.5.</span> <span class="toc-text">7.5 整合插件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6"><span class="toc-number">1.5.1.</span> <span class="toc-text">7.5.1 加载插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-%E6%B3%A8%E5%85%A5%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.2.</span> <span class="toc-text">7.5.2 注入功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E7%9A%84%E6%8F%92%E4%BB%B6"><span class="toc-number">1.6.</span> <span class="toc-text">7.6 一个具体的插件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1-%E6%8F%92%E4%BB%B6%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.1.</span> <span class="toc-text">7.6.1 插件接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2-%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.6.2.</span> <span class="toc-text">7.6.2 源代码依赖反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-3-%E5%AE%9E%E7%8E%B0-HyperbolicLnPlugin-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.6.3.</span> <span class="toc-text">7.6.3 实现 HyperbolicLnPlugin 的功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-%E4%B8%8B%E4%B8%80%E6%AD%A5"><span class="toc-number">1.7.</span> <span class="toc-text">7.7 下一步</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/test/" title="9. 新的需求">9. 新的需求</a><time datetime="2023-03-26T12:29:12.427Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/" title="8. 新的需求">8. 新的需求</a><time datetime="2023-03-26T12:29:12.426Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/" title="7. 插件">7. 插件</a><time datetime="2023-03-26T12:29:12.426Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/" title="5. 命令行接口">5. 命令行接口</a><time datetime="2023-03-26T12:29:12.425Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/6.The-Graphical-User-Interface/" title="6. 图形用户界面">6. 图形用户界面</a><time datetime="2023-03-26T12:29:12.425Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 漫艺海</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">世上最幸运的事就是喜欢上一个人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>