<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>8. 新的需求 | 漫艺海的blog</title><meta name="author" content="漫艺海"><meta name="copyright" content="漫艺海"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="8. 新的需求 这是一个美丽的星期一早晨，经过一个轻松的周末，你刚刚踏进了工作岗位。毕竟，你上周五刚刚完成了pdCalc项目，现在已经准备好发布了。然而，在你坐下来享用早晨的一杯咖啡之前，你的项目经理走进你的办公室，说：“我们还没有完成。客户要求添加一些新功能。” 上述情况在软件开发中非常普遍。虽然新功能可能不会在上线日期要求添加，但在你完成设计和实现的大部分工作之后，新功能几乎不可避免地会被要求">
<meta property="og:type" content="article">
<meta property="og:title" content="8. 新的需求">
<meta property="og:url" content="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/index.html">
<meta property="og:site_name" content="漫艺海的blog">
<meta property="og:description" content="8. 新的需求 这是一个美丽的星期一早晨，经过一个轻松的周末，你刚刚踏进了工作岗位。毕竟，你上周五刚刚完成了pdCalc项目，现在已经准备好发布了。然而，在你坐下来享用早晨的一杯咖啡之前，你的项目经理走进你的办公室，说：“我们还没有完成。客户要求添加一些新功能。” 上述情况在软件开发中非常普遍。虽然新功能可能不会在上线日期要求添加，但在你完成设计和实现的大部分工作之后，新功能几乎不可避免地会被要求">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/logo.png">
<meta property="article:published_time" content="2023-03-26T12:29:12.426Z">
<meta property="article:modified_time" content="2023-03-26T12:29:12.426Z">
<meta property="article:author" content="漫艺海">
<meta property="article:tag" content="Practical C++ Design From Programming to Architecture 1ed">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/logo.png"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '8. 新的需求',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-26 20:29:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="漫艺海的blog"><span class="site-name">漫艺海的blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">8. 新的需求</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-26T12:29:12.426Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-26T12:29:12.426Z" title="更新于 2023-03-26 20:29:12">2023-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Qt/">Qt</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="8. 新的需求"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>8. 新的需求</h1>
<p>这是一个美丽的星期一早晨，经过一个轻松的周末，你刚刚踏进了工作岗位。毕竟，你上周五刚刚完成了pdCalc项目，现在已经准备好发布了。然而，在你坐下来享用早晨的一杯咖啡之前，你的项目经理走进你的办公室，说：“我们还没有完成。客户要求添加一些新功能。”</p>
<p>上述情况在软件开发中非常普遍。虽然新功能可能不会在上线日期要求添加，但在你完成设计和实现的大部分工作之后，新功能几乎不可避免地会被要求添加。因此，在实际开发中，我们应尽量采取防御性开发策略，预测到可扩展性。我之所以说尽可能实用的防御性开发，而不是尽可能的防御性开发，是因为过于抽象的代码可能会对开发产生和过于具体的代码一样的负面影响。通常情况下，如果需要，重写不灵活的代码比维护高度灵活但无缘无故的代码更容易。在实践中，我们寻求在代码简单、可维护与可扩展性之间取得平衡。</p>
<p>在本章中，我们将探讨如何修改代码以实现超出原始需求设计的功能。本章对新功能的讨论范围从完整的设计和实现，到仅设计，再到仅为自我探索的建议。让我们从两个扩展开始，将它们从需求一直延伸到实现。</p>
<h2 id="8-1-完全设计的新功能">8.1 完全设计的新功能</h2>
<p>在本节中，我们将研究两个新功能：计算器的批处理操作和存储过程的执行。让我们从批处理操作开始。</p>
<h3 id="8-1-1-批处理操作">8.1.1 批处理操作</h3>
<p>对于那些不熟悉这个术语的人来说，任何程序的批处理操作只是在程序启动后，从开始到结束，不需要用户交互地执行程序。大多数桌面程序不是以批处理模式运行。然而，在许多编程领域，如科学计算，批处理操作仍然非常重要。也许对那些受雇于大公司的人来说，更有趣的是，你们的工资单可能是由一个以批处理模式运行的程序来生成的。</p>
<p>诚实地说，pdCalc的批处理操作除了可能用于测试之外，并不是一个非常有用的扩展。我之所以包含它，主要是因为它展示了一个设计良好的CLI可以如何轻松地扩展以添加批处理模式。</p>
<p>回顾第5章，pdCalc的CLI具有以下公共接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cli</span> : <span class="keyword">public</span> UserInterface</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">CliImpl</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cli</span>(istream&amp; in, ostream&amp; out);</span><br><span class="line">  ~<span class="built_in">Cli</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">bool</span> suppressStartupMessage = <span class="literal">false</span>, <span class="type">bool</span> echo = <span class="literal">false</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要使用CLI，该类使用cin和cout作为参数进行构造，然后使用空参数调用execute()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cli cli&#123;cin, cout&#125;;</span><br><span class="line"><span class="comment">// setup other parts of the calculator</span></span><br><span class="line">cli.<span class="built_in">execute</span>();</span><br></pre></td></tr></table></figure>
<p>我们如何修改Cli类以启用批处理操作？令人惊讶的是，我们根本不需要修改类的代码！从设计上讲，CLI本质上是一个解析器，它只需从输入流中获取用空格分隔的字符输入，通过计算器处理数据，然后将字符输出生成到输出流。因为我们预先考虑到不要将这些输入和输出流硬编码为cin和cout，我们可以通过将输入和输出流转换为文件流来将CLI转换为批处理处理器，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifstream fin&#123;inputFile&#125;;</span><br><span class="line">ofstream fout&#123;outputFile&#125;;</span><br><span class="line">Cli cli&#123;fin, fout&#125;;</span><br><span class="line"><span class="comment">// setup other parts of the calculator</span></span><br><span class="line">cli.<span class="built_in">execute</span>(<span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>其中inputFile和outputFile是可以通过pdCalc命令行参数获取的文件名。回想一下，execute()函数的参数只是用来抑制启动横幅并将命令回显到输出。</p>
<p>是的，这确实就是它（但请参见main.cpp中的一些实现技巧）。我们的CLI最初是这样构建的，以便它可以通过简单地更改其构造函数参数来转换为批处理处理器。当然，你可以辩称，作为作者的我，有意以这种方式设计Cli类，因为我知道计算器会以这种方式进行扩展。然而，事实上，我只是将所有的CLI接口用流输入构造，而不是硬编码输入，因为这种设计使CLI在几乎没有额外认知负担的情况下变得更加灵活。</p>
<p>在离开本节之前，我想快速指出，事实上，pdCalc的CLI在操作系统的协助下已经具备了批处理模式。通过在命令行中重定向输入和输出，我们可以实现相同的结果：<br>
my_prompt&gt; cat inputFile | pdCalc – cli &gt; outputFile</p>
<p>对于Windows，只需将Linux的cat命令替换为Windows的type命令。</p>
<h3 id="8-1-2-存储过程">8.1.2 存储过程</h3>
<p>承认吧，将批处理模式添加到pdCalc是一个有些做作的例子。新增的功能并不是特别有用，而代码更改非常简单。在本节中，我们将研究一个更有趣的功能扩展：存储过程。</p>
<p>什么是存储过程？在pdCalc中，存储过程是一组存储在当前栈上操作的可重复操作序列。存储过程提供了一种扩展计算器功能的技术，通过从现有计算器原语创建用户定义的函数。你可以将执行存储过程看作是运行一个非常简单的计算器程序。要理解这个概念，最简单的方法是考虑一个例子。</p>
<p>假设你需要经常计算三角形的斜边。对于图8-1中所示的直角三角形，我们可以使用勾股定理计算斜边c的长度：$$ c=\sqrt{a<sup>2+{b}</sup>2} $$。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/A454125_1_En_8_Fig1_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
          图8-1 直角三角形
  	</div>
</center>
<p>假设我们有一个三角形，边长a = 4，b = 3，这些值输入到pdCalc的堆栈中。在CLI中，你会看到以下内容：</p>
<p>堆栈顶部的2个元素（大小 = 2）：</p>
<p>2:      3</p>
<p>1:      4</p>
<p>为了计算这个三角形的c值，我们将实现以下指令序列：dup * swap dup * + 2 root。按下回车后，最终结果将是：</p>
<p>堆栈顶部元素（大小 = 1）：</p>
<p>1:      5</p>
<p>如果将命令一个接一个地输入，每次按下回车时，我们都会看到中间的结果堆栈。如果我们将所有命令输入在一行，然后按下回车，pdCalc将在显示最终结果之前显示每个中间堆栈。当然，请注意，这个命令序列并不是唯一的。例如，使用命令序列 2 pow swap 2 pow + 2 root 也可以得到相同的结果。</p>
<p>如果你和我一样，在pdCalc中反复计算斜边时，你可能会在第一次手动计算后想要自动化该操作。这正是存储过程允许的。自动化不仅节省时间，而且因为封装了许多连续命令的存储过程可以编写、测试和随后重用，所以也更不容易出错。只要操作可以从pdCalc原语（包括插件函数）组合而成，存储过程就可以在不需要编写任何C++代码的情况下扩展计算器的功能，计算简单的公式。现在我们只需要设计和实现这个新功能。</p>
<h4 id="8-1-2-1-用户界面">8.1.2.1 用户界面</h4>
<p>pdCalc既有GUI，也有CLI，所以添加任何面向用户的功能都需要对这两个用户界面组件进行一定的修改。对于存储过程，用户界面的修改非常小。首先，存储过程只是一个包含pdCalc指令有序序列的文本文件。因此，用户可以使用任何纯文本编辑器创建存储过程。因此，除非你想提供一个带有语法高亮的存储过程文本编辑器，否则存储过程的用户界面就是简化为从CLI和GUI执行它们。</p>
<p>首先，让我们讨论在CLI中整合存储过程。如前所述，存储过程只是文件系统中的文本文件。回顾一下，CLI是通过对空格分隔的输入进行标记化，然后将每个标记单独传递给命令调度器来处理事件。因此，访问存储过程的一个简单方法就是将存储过程文件名传递给CLI。然后，这个文件名将像任何其他命令或数字一样进行标记化，并传递给命令调度器进行处理。为确保命令调度器将文件名解释为存储过程而不是命令，我们只需在文件名前加上符号proc：并更改命令调度器的解析器。例如，对于名为hypotenuse.psp的存储过程，我们将向CLI发出命令proc:hypotenuse.psp。我采用文件扩展名psp作为pdCalc存储过程的缩写。当然，文件本身是一个包含用于计算直角三角形斜边的命令序列的普通ASCII文本文件，你可以使用.txt扩展名，如果你喜欢的话。</p>
<p>回想一下，GUI被设计成像CLI一样将命令传递给命令调度器。因此，要使用存储过程，我们添加一个按钮，打开一个对话框，浏览文件系统以找到存储过程。一旦选择了存储过程，我们在文件名前加上proc：并引发CommandEntered事件。显然，您可以根据需要制作您的存储过程选择对话框。我选择了一种简单的设计，允许将文件名键入可编辑的组合框中。为了方便使用，组合框预先填充了当前目录中所有具有.psp扩展名的文件。</p>
<h4 id="8-1-2-2-命令调度器的更改">8.1.2.2 命令调度器的更改</h4>
<p>清单8-1是CommandDispatcher的executeCommand()函数的简略清单，包括解析存储过程所需的逻辑。省略的代码部分出现在第4.5.2节。</p>
<p>清单8-1 CommandDispatcher的executeCommand()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CommandDispatcher::CommandDispatcherImpl::<span class="built_in">executeCommand</span>(<span class="type">const</span> string&amp; command)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// handle numbers, undo, redo, help in nested if</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(command.<span class="built_in">size</span>() &gt; <span class="number">6</span> &amp;&amp; command.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>) == <span class="string">&quot;proc:&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> filename = command.<span class="built_in">substr</span>(<span class="number">5</span>, command.<span class="built_in">size</span>() - <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">handleCommand</span>( <span class="built_in">MakeCommandPtr</span>&lt;StoredProcedure&gt;(ui_, filename) );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// else statement to handle Commands from CommandRepository</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中，我们可以看到实现只是从字符串命令参数中剥离proc：以创建存储过程文件名，创建一个新的StoredProcedure Command子类，并执行这个类。目前，我们将假设使StoredProcedure类成为Command类的子类是最佳设计。我将在下面的章节中讨论为什么这种策略是首选，并检查其实现。然而，在我们到达那里之前，让我们讨论一下这个新的MakeCommandPtr()函数的重载。</p>
<p>在第7.2.1节中，我们首次看到了由以下实现给出的MakeCommandPtr版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">CommandDeleter</span><span class="params">(Command* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p-&gt;<span class="built_in">deallocate</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> CommandPtr = std::unique_ptr&lt;Command, <span class="keyword">decltype</span>(&amp;CommandDeleter)&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">MakeCommandPtr</span><span class="params">(Command* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> CommandPtr&#123;p, &amp;CommandDeleter&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数是一个辅助函数，用于从原始Command指针创建CommandPtrs。这种形式的函数用于从克隆现有命令创建CommandPtr（例如，如CommandRepository::allocateCommand()中）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">MakeCommandPtr</span>( command-&gt;<span class="built_in">clone</span>() );</span><br></pre></td></tr></table></figure>
<p>然而，在CommandDispatcherImpl::executeCommand()中，我们看到了一个完全不同的用法，即构造一个派生自Command的类的实例。当然，我们可以用现有的MakeCommandPtr原型满足这个用例。例如，我们可以创建一个StoredProcedure，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> c = <span class="built_in">MakeCommandPtr</span>(<span class="keyword">new</span> StoredProcedure&#123;ui, filename&#125;);</span><br></pre></td></tr></table></figure>
<p>然而，只要有可能，最好不要在高级代码中使用裸露的new。因此，我们寻求实现一个可以为我们执行此构造的重载辅助函数。它的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">MakeCommandPtr</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> CommandPtr&#123;<span class="keyword">new</span> T&#123;std::forward&lt;Args&gt;(args)...&#125;, &amp;CommandDeleter&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C<ins>11之前，没有简单而高效的技术可以使用可变数量的构造函数参数构造通用类型，这是创建可能从Command类派生的任何一个类所必需的，每个类都有不同的构造函数参数。然而，现代C</ins>使用可变模板和完美转发提供了一个优雅的解决方案。这个构造是下面边栏的主题。</p>
<hr>
<p>现代C++设计注意事项：可变模板和完美转发</p>
<p>可变模板和完美转发分别解决了C<ins>中的不同问题。可变模板允许使用未知数量的类型参数进行类型安全的通用函数调用。完美转发允许在模板函数内部将参数正确地转发给底层函数。可以在您最喜欢的C</ins>11参考文本中（例如[23]）学习这些技术的机制。此侧边栏展示了一种类型安全的、通用的设计技术，用于构造需要不同数量构造函数参数的具体对象。这种技术是通过可变模板和完美转发的组合实现的。由于缺乏命名创意，我将这种模式命名为通用完美转发构造器（GPFC）。让我们首先介绍GPFC解决的基本问题。</p>
<p>让我们考虑每个作者最喜欢的过于简化的面向对象编程示例，形状层次结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Circle</span>(<span class="type">double</span> r) : r_&#123;r&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.14159</span> * r_ * r_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> r_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Rectangle</span>(<span class="type">double</span> l, <span class="type">double</span> w) : l_&#123;l&#125;, w_&#123;w&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> l_ * w_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> l_, w_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在C++中，可替代性（实现为虚拟分派）解决了需要通过基类指针调用派生类型的特定实现的问题，使用基类保证的接口。在形状示例中，可替代性意味着能够按如下方式计算面积：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(<span class="type">const</span> Shape&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s.<span class="built_in">area</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于任何派生自Shape的类。虚拟函数的确切接口是完全规定的，包括任何函数参数的数量和类型（即使在这个示例中area()函数的空实例中）。然而，问题在于对象构造永远无法以这种方式“虚拟化”，即使它可以，它也无法工作，因为构造对象所需的信息（其参数）很频繁地从一个派生类到另一个派生类都是不同的。</p>
<p>进入通用完美转发构造器模式。在这种模式下，我们使用可变模板提供一个类型安全的接口，该接口可以接受任意数量的不同类型的构造函数参数。第一个模板参数始终是我们要构造的类型。然后，完美转发用于确保参数以正确的类型传递给构造函数。为什么完美转发在这种情况下是必要的，源于模板中类型的推导方式，这已超出了本讨论的范围（有关详细信息，请参见[19]）。对于我们的形状示例，应用GPFC模式得到以下实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">MakeShape</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;T&gt;(forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下代码说明了如何使用MakeShape()函数创建具有不同构造函数参数数量的不同类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> c = <span class="built_in">MakeShape</span>&lt;Circle&gt;(<span class="number">4.0</span>);</span><br><span class="line"><span class="keyword">auto</span> r = <span class="built_in">MakeShape</span>&lt;Rectangle&gt;(<span class="number">3.0</span>, <span class="number">5.0</span>);</span><br></pre></td></tr></table></figure>
<p>请注意，GPFC模式也适用于创建在继承层次结构中彼此不相关的类。事实上，标准库中的make_unique()函数使用GPFC模式以高效、通用的方式创建unique_ptrs，而不需要使用裸new。虽然严格来说它们是不同的，但我喜欢将GPFC模式视为工厂方法的通用类比。</p>
<hr>
<h4 id="8-1-2-3-设计StoredProcedure类">8.1.2.3 设计StoredProcedure类</h4>
<p>现在我们回到设计StoredProcedure类的棘手问题。我们首先要问的问题是我们是否需要一个类。我们已经有了一个解析单个命令、执行它们并将它们放在撤消/重做堆栈上的设计。也许正确的答案是将存储过程视为与批处理输入类似的处理方式。也就是说，在交互式会话（GUI或CLI）期间，通过读取存储过程文件、解析它并批量执行命令（如我们在CLI中带有多个命令的长行中所做的那样）处理存储过程，而不引入新的StoredProcedure类。</p>
<p>在考虑以下非常简单的示例之后，上述设计几乎可以立即被驳回。假设您实现了一个计算三角形面积的存储过程。存储过程的输入将是堆栈上的三角形底边和高度。triangleArea.psp如下所示：<br>
*<br>
0.5<br>
*</p>
<p>如果我们没有StoredProcedure类，那么triangleArea.psp中的每个命令将被执行并按顺序输入到撤消/重做堆栈中。对于I/O堆栈上的值4和5，存储过程的正向执行将产生正确的结果10和一个撤消堆栈，如图8-2所示。基于此撤消堆栈，如果用户尝试撤消，而不是撤消三角形面积存储过程，用户只会撤消堆栈顶部的最后一个操作，即最后的乘法。I/O堆栈将读取<br>
4<br>
5<br>
0.5<br>
（撤消堆栈将在5和0.5之间有一个*）而不是<br>
4<br>
5</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/A454125_1_En_8_Fig2_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图8-2 没有StoredProcedure类的撤消堆栈
  	</div>
</center>
<p>要完全撤消一个存储过程，用户需要按n次撤消，其中n等于存储过程中的命令数量。重做操作也存在相同的不足。在我看来，撤消存储过程的预期行为应该是撤消整个过程，并将I/O堆栈保持在执行存储过程之前的状态。因此，不使用StoredProcedure类的处理存储过程的设计无法正确实现撤消和重做操作，因此必须被抛弃。</p>
<h3 id="8-1-2-4-组合模式">8.1.2.4 组合模式</h3>
<p>本质上，为了解决存储过程中的撤销/重做问题，我们需要一个特殊的命令来封装多个命令，但它的行为就像一个单独的命令。幸运的是，组合模式解决了这个难题。根据Gamma等人[6]的说法，组合模式“让客户端可以统一对待单个对象和对象的组合”。通常，组合模式是指树形数据结构。我更喜欢一个较宽松的定义，其中模式可以应用于允许统一处理复合对象的任何数据结构。</p>
<p>图8-3以其通用形式说明了组合模式。Component类是一个抽象类，需要执行某些操作。这个操作可以由Leaf节点单独执行，也可以由称为Composite的一组Components执行。客户端通过Component接口以多态的方式与组件层次结构中的对象进行交互。从客户端的角度来看，Leaf节点和Composite节点都能无差别地处理doSomething()请求。通常，Composites通过简单地调用它所持有的Components（Leafs或嵌套Composites）的doSomething()命令来实现doSomething()。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/A454125_1_En_8_Fig3_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图8-3 组合模式的一般形式
  	</div>
</center>
<p>在我们的具体情况下，Command类扮演Component的角色，诸如Add或Sine这样的具体命令扮演Leaf节点的角色，StoredProcedure类是复合体。doSomething()命令被替换为executeImpl()和undoImpl()这一对纯虚函数。我怀疑以这种方式将命令和组合模式结合在一起相当常见。</p>
<p>此前，我们了解到为了正确实现存储过程的撤销/重做策略，需要一个类设计。如上所述，应用组合模式激发了将StoredProcedure类子类化为Command类。</p>
<p>现在让我们设计一个StoredProcedure类，并将其作为组合模式的具体应用来检查其实现。</p>
<h4 id="8-1-2-5-第一次尝试">8.1.2.5 第一次尝试</h4>
<p>实现组合模式的常见方法是通过递归。Composite类包含一组Component，通常是通过一个简单的向量或者更复杂的结构，例如二叉树中的节点。Composite的doSomething()函数只需遍历这个集合，为集合中的每个Component调用doSomething()。Leaf节点的doSomething()函数实际上会执行某些操作并终止递归。尽管不是必需的，但Component类中的doSomething()函数通常是纯虚函数。</p>
<p>让我们考虑上述方法，用于实现pdCalc中StoredProcedure的组合模式。我们已经确定pdCalc的Command类是Component，而具体的命令类（如Add）是Leaf类。因此，我们只需要考虑StoredProcedure类本身的实现。注意，由于当前Component和Leaf类的实现可以直接使用，组合模式可以简单地应用于扩展现有代码库的功能。</p>
<p>考虑以下StoredProcedure类的框架设计：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StoredProcedure</span> : <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">  vector&lt;unique_ptr&lt;CommandPtr&gt;&gt; components_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>executeImpl()命令将按如下方式实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoredProcedure::executeImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : components_)</span><br><span class="line">    i-&gt;<span class="built_in">execute</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>undoImpl()将以类似的方式实现，但是要在component_集合上进行反向迭代。</p>
<p>上述设计是否解决了之前在没有StoredProcedure类的情况下将存储过程命令直接输入到撤销/重做堆栈时遇到的撤销/重做问题？考虑我们之前检查过的triangleArea.psp示例中的撤销堆栈，如图8-4所示。存储过程在撤销堆栈中显示为一个对象，而不是表示其组成命令的单个对象。因此，当用户发出撤销命令时，CommandManager将通过调用存储过程的undoImpl()函数将存储过程作为单个命令进行撤销。这个存储过程的undoImpl()函数反过来通过对其Command容器的迭代撤销单个命令。这种行为正是我们所期望的，这种组合模式的应用确实解决了手头的问题。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/A454125_1_En_8_Fig4_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图8-4 使用StoredProcedure类的撤销堆栈
  	</div>
</center>
<p>为了完成StoredProcedure类的实现，我们需要解析存储过程文件的字符串命令（带有错误检查），并用它们填充StoredProcedure的components_向量。这个操作可以在StoredProcedure的构造函数中编写，实现将是有效的和完整的。现在我们将拥有一个StoredProcedure类，可以将字符串命令转换为Commands，将它们存储在容器中，并根据需要执行和撤销这些存储的Commands。换句话说，我们将重写命令调度器！相反，让我们考虑一种实现StoredProcedure类的替代设计，通过重用CommandDispatcher类。</p>
<h4 id="8-1-2-6-StoredProcedure类的最终设计">8.1.2.6 StoredProcedure类的最终设计</h4>
<p>这个设计的目标是重用CommandDispatcher类。放宽此约束并修改CommandDispatcher的代码可以稍微清理实现，但无论哪种方式，设计的本质是相同的。考虑以下修改后的StoredProcedure类的框架设计：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StoredProcedure</span> : <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">  std::unique_ptr&lt;Tokenizer&gt; tokenizer_;</span><br><span class="line">  std::unique_ptr&lt;CommandDispatcher&gt; ce_;</span><br><span class="line">  <span class="type">bool</span> first_ = first;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>目前的设计几乎与我们之前的设计相同，只是components_vector被CommandDispatcher替换，而且需要明确标记器。幸运的是，我们在第5章中编写的标记器是可重用的！</p>
<p>现在我们准备查看executeImpl()和undoImpl()的完整实现。请注意，虽然下面的实现没有使用上面看到的模式的规范版本，但这个StoredProcedure类的实现仍然只是组合模式的一个应用。首先，让我们看一下executeImpl()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoredProcedure::executeImpl</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(first_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : *tokenizer_)</span><br><span class="line">    &#123;</span><br><span class="line">      ce_-&gt;<span class="built_in">commandEntered</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    first_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; tokenizer_-&gt;<span class="built_in">nTokens</span>(); ++i)</span><br><span class="line">      ce_-&gt;<span class="built_in">commandEntered</span>(<span class="string">&quot;redo&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>executeImpl()第一次被调用时，必须从标记器中提取标记并由StoredProcedure自己的CommandDispatcher执行。随后对executeImpl()的调用只需请求StoredProcedure的CommandDispatcher重做存储过程命令的前向执行。请记住，StoredProcedure的executeImpl()函数本身将由pdCalc的CommandDispatcher调用；因此，我们的设计需要嵌套的CommandDispatchers。图8-5展示了这个三角形区域存储过程示例的设计，其中CD表示CommandDispatcher。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/A454125_1_En_8_Fig5_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图8-5 使用嵌套的CommandDispatchers的撤销堆栈
  	</div>
</center>
<p>StoredProcedure的undoImpl()的实现非常简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoredProcedure::undoImpl</span> <span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; tokenizer_-&gt;<span class="built_in">nTokens</span>(); ++i)</span><br><span class="line">    ce_-&gt;<span class="built_in">commandEntered</span>(<span class="string">&quot;undo&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>撤销是通过请求底层CommandDispatcher撤销存储过程中的命令数量来实现的。</p>
<p>在结束对最终StoredProcedure类的讨论之前，我们应该考虑在StoredProcedure类中对命令进行标记化。StoredProcedure的标记化过程涉及两个步骤。首先要打开并读取存储过程文件，然后对文本流进行实际的标记化。这个过程只需要在StoredProcedure实例化时的初始化阶段执行一次。因此，标记化的自然位置是在StoredProcedure的构造函数中。然而，在StoredProcedure的构造函数中进行标记化会导致与pdCalc命令错误处理程序的不一致。具体来说，pdCalc假设命令可以构造，但不一定会执行，而不会失败。如果一个命令无法执行，预期是通过检查命令的前提条件来处理这个错误。标记化可以失败吗？当然可以。例如，如果无法打开存储过程文件，标记化将失败。因此，为了保持错误处理的一致性，我们在StoredProcedure的checkPreconditionsImpl()函数中实现标记化，该函数将在pdCalc的CommandDispatcher首次尝试执行存储过程时调用。由于标记化需要执行一次，我们只在checkPreconditionsImpl()函数的第一次执行中执行此操作。完整的实现可以在StoredProcedure.cpp文件中找到。</p>
<h2 id="8-2-更有用的计算器设计">8.2 更有用的计算器设计</h2>
<p>到目前为止，关于pdCalc的所有讨论都集中在设计和实现一个可从GitHub下载的完整代码。然而，本章剩余部分标志着这种风格的转变。从现在开始，我们将仅讨论扩展的想法以及如何修改pdCalc以适应这些新功能的建议。这里不仅没有提供工作代码，而且在编写这些部分之前也没有创建工作代码。因此，我即将讨论的设计尚未经过测试，冒险的读者选择完成这些扩展可能会发现待讨论的想法是次优的，或者，敢于说，错误的。欢迎来到从空白设计功能的野蛮西部！将需要进行实验和迭代。</p>
<h3 id="8-2-1-复数">8.2.1 复数</h3>
<p>计算器的原始设计规范要求使用双精度数，并且我们专门设计和实现了计算器以处理双精度数。然而，需求会发生变化。假设您的同事，一位电气工程师，顺便来到您的办公室，爱上了您的计算器，但需要能处理复数（虚数）的计算器。这是一个合理的请求，因此让我们看看如何重构我们的计算器以满足这个新功能。</p>
<p>向pdCalc添加复数需要对其进行四个主要修改：内部使用复数表示而不是将数字表示为双精度，更改输入和输出（以及相应的解析）以适应复数，修改pdCalc的堆栈以存储复数而不是双精度数，以及修改命令以对复数执行计算而不是实值输入。第一个更改，找到复数的C++表示非常简单；我们将使用std::complex<double>。只有实部的数字将被存储为具有虚部设置为0的complex<double>。其他三个更改则不那么简单。现在让我们更深入地看一些能够适应这些更改的设计选项。</double></double></p>
<h4 id="8-2-1-1-修改输入和输出">8.2.1.1 修改输入和输出</h4>
<p>在所有必需的更改中，修改I/O例程实际上是最简单的。首先要解决的问题是复数将如何解释和表示。例如，我们是否希望复数c表示为c = re + im * i（也许虚数应该是j，因为特性请求来自电气工程师）。也许我们更喜欢使用c = (re, im)或使用尖括号或方括号的变体。这个问题没有正确的答案。虽然有些选择可能比其他选择更容易实现，但由于这个选择只是一个约定，在实践中，我们会将解决方案推迟给客户。对于我们的案例研究，我们将简单地采用约定c = (re, im)。</p>
<p>我将仅讨论修改命令行版本的I/O。一旦为CLI提供处理复数的基础设施，适应GUI应该相当简单。我们遇到的第一个问题是Tokenizer类。这个类的原始设计仅通过在空格上拆分输入进行标记化。然而，对于复数，这种方案是不够的。例如，根据逗号后是否插入空格，复数的标记化方式会有所不同。</p>
<p>在某个时候，输入变得足够复杂，您需要使用一种语言语法并将简单的输入例程迁移到一个“真正”的扫描器和解析器（可能使用像lex和yacc这样的库）。有些人可能会说，通过添加复数，我们已经达到了这种复杂程度。然而，我认为，如果我们修改tokenize()例程以扫描(标记并为包括开括号和闭括号之间的任何内容创建一个“数字”标记，我们可能可以使用现有的简单输入标记器。显然，我们需要进行一些基本的错误检查以确保正确的格式。另一种选择是根据正则表达式匹配对输入流进行分解。这本质上就是lex的工作方式，我会在从头编写复杂的扫描器之前调查使用lex或类似的库。</p>
<p>我们遇到的下一个输入问题是在CommandDispatcherImpl的executeCommand()函数中解析数字。目前，一个字符串参数（标记）被传递给这个函数，并解析字符串以确定它是一个数字还是一个命令。通过检查，我们可以看到，如果我们修改isNum()来识别并返回复数而不是浮点数，那么executeCommand()将适用于复数。最后，EnterNumber命令需要更新，以接受和存储一个complex<double>。</double></p>
<p>这样就解决了修改输入例程的问题，但我们如何修改输出例程呢？回想一下，Cli类是Stack的stackChanged()事件的（间接）观察者。每当Stack引发此事件时，Cli的stackChanged()函数将被调用以将当前堆栈输出到命令行。让我们看看Cli::stackChanged()是如何实现的。实际上，CLI回调堆栈使用以下函数调用填充顶部的nElements容器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> v = Stack::<span class="built_in">Instance</span>().<span class="built_in">getElements</span>(nElements);</span><br></pre></td></tr></table></figure>
<p>然后创建一个ostringstream，oss，并首先使用一些堆栈元数据填充它，然后使用以下代码填充堆栈元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> j&#123; v.<span class="built_in">size</span>() &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = v.<span class="built_in">rbegin</span>(); i != v.<span class="built_in">rend</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  oss &lt;&lt; j &lt;&lt; <span class="string">&quot;:\t&quot;</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  -- j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，oss的底层字符串被发布到CLI。令人惊讶的是，一旦Stack的getElements()函数修改为返回vector&lt;complex<double>&gt;，仅通过重新编译，Cli的stackChanged()函数将按预期工作。由于我们使用了auto，以及因为operator&lt;&lt;()已经为std::complex重载，只要我们对复数的标准格式满意，我们的输出修改就在不做任何事情的情况下完成了！这就是精心设计和实现的代码的美丽之处。</double></p>
<h4 id="8-2-1-2-修改Stack">8.2.1.2 修改Stack</h4>
<p>在第3章中，我们最初设计了计算器的堆栈，只对双精度变量进行操作。显然，这种限制意味着现在必须重构Stack类以处理复数。当时，我们质疑了为堆栈硬编码目标数据类型的逻辑，并建议不要设计通用Stack类。我建议通常不要设计通用接口，直到明确建立第一个重用案例。</p>
<p>设计好的通用接口通常比设计特定类型更难，而且，根据我的个人经验，我发现代码的意外重用很少实现。然而，对于我们的Stack类，重用这个数据结构的时机已经到来，现在是将Stack接口转换为通用接口而不是仅将类重构为为复数硬编码的时机。</p>
<p>使Stack类通用几乎和您预期的一样简单。第一步是使接口本身通用，用我们的通用类型T替换double的显式使用。接口变成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> : <span class="keyword">private</span> Publisher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Stack&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T, <span class="type">bool</span> suppressChangeEvent = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">pop</span><span class="params">(<span class="type">bool</span> suppressChangeEvent = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swapTop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;T&gt; <span class="title">getElements</span><span class="params">(<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getElements</span><span class="params">(<span class="type">size_t</span> n, std::vector&lt;T&gt;&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">using</span> Publisher::attach;</span><br><span class="line">  <span class="keyword">using</span> Publisher::detach;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用通用接口时，不再需要使用pimpl模式。回想一下，使用pimpl模式使我们能够通过间接引用一个仅在源文件中定义的实现类指针来隐藏类的实现。然而，为了使Stack通用，它的实现也必须是通用的（因为它必须存储任何类型的T，而不是已知类型的double）。这意味着StackImpl也需要进行模板化。C++规则要求当Stack<T>实例化为特定的T时，StackImpl<T>的定义必须是可见的，因此要求StackImpl<T>的定义在Stack<T>之前出现在头文件中。一旦我们失去了使StackImpl<T>私有的能力，我们就没有理由使用pimpl模式，而是直接在Stack<T>类中定义堆栈的实现。</T></T></T></T></T></T></p>
<p>通常，所需的实现更改非常简单。double的用法替换为T，实现本身移动到头文件。在pdCalc中使用Stack类的代码显然必须重构为使用通用而不是非模板接口。</p>
<p>需要修改的接口的最后一部分是在第7章中添加的五个全局extern &quot;C&quot;辅助函数，用于将堆栈命令导出到插件。因为这些函数必须具有C链接，所以我们不能将它们作为模板，也不能在双精度浮点数的位置返回C++复数类型。第一个问题并不像乍一看那么严重。虽然我们的目标是使Stack类通用和可重用，但堆栈的插件接口不需要通用。对于任何特定版本的pdCalc，无论是操作实数还是操作复数，系统中只会存在一个特定的Stack<T>实例，并且这个实例将具有特定的T实现。因此，pdCalc堆栈的C链接接口只需反映计算器中使用的T的选择。也就是说，容器被设计为通用和可重用，但插件接口不需要这种灵活性，因为一旦选择了计算器的数据格式，就不会重用它。</T></p>
<p>将复数<double>表示法替换为堆栈的C链接接口非常简单。我们有几个选项。首先，我们可以用两个双精度浮点数的序列替换每个双精度浮点数，一个表示实部，一个表示虚部。当然，由于一个函数不能返回两个双精度浮点数，我们必须修改返回堆栈值的函数，将指针参数用在它们的参数列表中来“返回”复数值。第二个选项是通过数组返回复数。考虑到我在可能的情况下消除接口中原始指针的偏好，我认为这个选项并不理想。最后一个解决方案，也是我首选的选择，是简单地定义一个结构，如下所示：</double></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> re;</span><br><span class="line">  <span class="type">double</span> im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用于补充接口函数，用Complex替换当前使用的double。虽然这个新的Complex结构确实重复了标准复数类的存储，但我们不能在纯C接口中使用标准复数类。</p>
<h4 id="8-2-1-3-修改命令">8.2.1.3 修改命令</h4>
<p>修改命令以适应复数实际上非常简单，因为C<ins>库为我们的计算器所需的所有数学运算提供了重载。在将Stack替换为Stack&lt;complex<double>&gt;（希望我们已经在某个地方对其进行了别名处理）和在BinaryCommand和UnaryCommand中将complex<double>替换为double的语法更改之外，大多数命令保持不变。例如，清除实数堆栈与清除复数堆栈是相同的。由于操作符重载，添加两个复数与添加两个实数是相同的。当然，我们可能想要添加其他命令，例如复共轭，但即使这个功能也是由C</double></double></ins>复数类提供的。如果您创建的命令使用了复数类本身不支持的算法，那么在修改命令以支持复数时，您可能会遇到比编程问题更多的数学问题。</p>
<h3 id="8-2-2-变量">8.2.2 变量</h3>
<p>在本章前面，我们实现了存储过程作为存储简单指令序列的方法。虽然存储过程对于只使用每个输入一次的简单操作（例如勾股定理）很好用，但在试图实现使用每个输入多次的更复杂公式（例如二次公式）时，你会很快遇到问题。要克服这个困难，你需要实现将参数存储在命名变量中的功能。</p>
<p>在pdCalc中实现变量将需要对现有组件进行几处修改，包括添加一个显著的新组件——符号表。为了简化示例代码，我已经恢复使用pdCalc的实数表示。然而，使用复数不会增加额外的设计复杂性。现在让我们探讨一些实现变量的可能设计思路。</p>
<h4 id="8-2-2-1-输入和新命令">8.2.2.1 输入和新命令</h4>
<p>显然，使用变量需要提供符号名称的一些手段。目前，我们的计算器只接受数字和命令作为输入。输入任何在CommandRepository中找不到的字符串都会导致错误。然而，请记住，这个错误是在CommandDispatcher中生成的，而不是在分词器中。因此，我们需要修改CommandDispatcher，让其不拒绝字符串，而是将它们放到堆栈中。目前，我们假设堆栈除了数字之外还可以接受字符串。在即将到来的部分中，我将讨论对Stack类的必要修改。再次强调，我将我们的讨论限制在命令行界面。图形用户界面带来的唯一额外复杂性是提供输入字符字符串以及数字的机制（可能是伴随虚拟数字键盘的虚拟键盘）。</p>
<p>从技术上讲，我们可以允许任何字符串表示变量。然而，我们可能更好地通过限制允许的语法到某个字符串子集来实现，可能用一个符号来区分变量名和命令。由于这个选择只是约定，您可以自由选择适合您或您的用户口味的规则。就我个人而言，我可能会选择诸如变量名必须以字母开头，可以包含任何字母、数字和可能的几个特殊符号（如下划线）的组合。为了消除变量名和命令之间的混淆，我会用单引号或双引号将变量括起来。</p>
<p>现在我们已经为变量建立了语法，我们仍然需要一个从堆栈中取出一个数字并将其存储到变量中的机制。完成此任务的最简单方法是提供一个新的二进制命令“store”，它从堆栈中移除一个数字和一个字符串，并在符号表中创建一个将此变量名链接到此数字的条目。例如，考虑堆栈：<br>
4.5<br>
2.9<br>
“x”</p>
<p>执行存储命令后，符号表中应该有一个x → 2.9的条目，剩余堆栈为4.5。在计算过程中，变量应隐式地转换为数字，但在堆栈上显示为名称。我们还应该提供一个显式命令“eval”，将符号名称转换为数字。例如，给定堆栈：<br>
“x”<br>
执行eval命令后，堆栈应变为2.9。</p>
<p>这样的命令应该有一个相当明显的实现：用符号表中的值替换堆栈顶部的变量。显然，请求评估不在符号表中的变量应导致错误。评估数字可以导致错误，或者更好地说，只返回数字。您可能会想到许多处理变量的花哨命令（例如，列出符号表）。然而，存储和eval命令组成了使用变量所需的最小命令集。</p>
<h4 id="8-2-2-2-数字表示和堆栈">8.2.2.2 数字表示和堆栈</h4>
<p>到目前为止，我们的堆栈只需要表示一个唯一的类型，要么是实数，要么是复数。然而，由于变量和数字都可以存储在堆栈上，我们需要堆栈同时存储两种类型的能力。我们立即排除了一个可以同时处理两种不同类型的堆栈的概念，因为这会很快导致混乱。相反，我们寻求一个能够通过单一接口处理数字和变量类型的统一表示。自然地，我们转向一个层次结构。</p>
<p>考虑图8-6中的类图所表达的设计。这个层次结构使得变量和数字都可以作为值互换使用。这种多态设计解决了我们已经遇到的三个问题。首先，变量和数字都可以在Stack&lt;Value*&gt;（可能使用更合适的智能指针存储方案）中统一存储。其次，当诸如Add或Sine之类的命令需要一个数字来执行操作时，它们可以从堆栈中弹出值，并通过虚拟evaluate()函数请求双精度数。显然，一个数字直接存储它表示的双精度数，而一个变量存储变量的名称，可以通过在变量符号表中查找将其转换为数值。最后，Value的子类可以返回其基础值的字符串表示（一个数字的数值或一个变量的名称）。这种字符串转换对于在I/O堆栈上显示是必要的。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/A454125_1_En_8_Fig6_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图 8-6 能够统一表示数字和变量的层次结构
  	</div>
</center>
<h4 id="8-2-2-3-符号表">8.2.2.3 符号表</h4>
<p>在本质上，符号表只是一个允许通过将键与值配对进行符号查找的数据结构（关联数组）。在这种情况下，变量名称作为键，数值作为值。C++标准库通过map或unordered_map直接提供这种服务，具体取决于所需的底层数据结构。然而，正如第3章中所建议的，我强烈建议不要直接在程序中使用标准库容器作为外部接口。相反，应该使用适配器模式将库容器封装在由应用程序本身定义的接口之后。这种模式不会给类的用户添加任何限制，但它确实允许设计者独立于底层库容器的接口限制、扩展或稍后修改组件的接口。</p>
<p>因此，符号表的推荐设计是创建一个SymbolTable类，将unordered_map&lt;string, double&gt;包装起来。这个底层哈希表为字符串形式的变量名和底层数值之间的映射提供了存储类型。SymbolTable类的公共接口为添加和（可选地，我们没有为清除变量指定命令）从符号表中删除变量提供了成员函数。由于我们在计算器中只需要一个符号表，所以SymbolTable可能应该实现为单例。</p>
<h4 id="8-2-2-4-一个微小的扩展：数值常量">8.2.2.4 一个微小的扩展：数值常量</h4>
<p>一旦我们建立了存储用户定义变量的机制，我们可以进行一个微小的扩展，提供用户定义的常量。常量只是一旦设置就不能更改的变量。常量可以在pdCalc中硬编码，通过读取常量文件在程序启动时添加，或在计算器执行过程中动态添加。</p>
<p>显然，为了存储一个常量，我们需要添加一个新命令；我们称之为cstore。cstore与store的工作方式完全相同，只是该命令通知符号表存储的变量不能更改。我们有两个明显的实现选项。首先，在SymbolTable类内部，我们添加一个表示给定名称是变量还是常量的第二个映射。这种方法的优点是添加额外映射将对现有代码进行最小的实现更改。缺点是这种方法需要每次调用符号表时进行两次独立查找。更好的方法是修改原始映射，将值类型存储为Entry而不是双精度数，其中Entry定义为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> val;</span><br><span class="line">  <span class="type">bool</span> isConst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，为了避免硬编码双精度类型，我们当然可以为SymbolTable和Entry都使用模板。</p>
<h4 id="8-2-2-5-由变量实现的功能">8.2.2.5 由变量实现的功能</h4>
<p>让我们看看变量能让我们做什么。考虑二次方程 ax^2+bx+c = 0，其根由下式给出：<br>
$$ r=\frac{-b\pm \sqrt{b^2-4 ac}}{2a} $$</p>
<p>在过去，我们无法为计算两个根编写存储过程，现在我们可以编写存储过程：<br>
“c” store “b” store “a” store “b” 2 pow 4 “a” “c” * * - sqrt “root” store<br>
“b” - “root” + 2 a * / “b” - “root” 2 a * /</p>
<p>这将从堆栈中取出代表系数a、b、c的三个条目，并返回代表二次方程根的两个条目。现在我们的计算器正在取得进展！</p>
<h2 id="8-3-一些有趣的自我探索扩展">8.3 一些有趣的自我探索扩展</h2>
<p>本章以列出一些你可能考虑自己尝试的有趣扩展的部分结束。与前一节相反，我没有提供任何设计思路来帮助你开始。我只提供了每个挑战的简短描述。</p>
<h3 id="8-3-1-高DPI缩放">8.3.1 高DPI缩放</h3>
<p>具有极高像素分辨率的显示器越来越普遍。考虑如何修改pdCalc的GUI以适当处理这些显示器的缩放。这个功能是否与操作系统无关，还是我们需要从第7章的PlatformFactory中找到另一个用途？自5.6版本起，Qt通过一个高DPI缩放接口来帮助你完成此任务。</p>
<h3 id="8-3-2-动态换肤">8.3.2 动态换肤</h3>
<p>在第6章中，介绍了一个类来管理GUI的外观和感觉。然而，所提供的实现仅将外观和感觉集中起来。它没有允许用户自定义。</p>
<p>用户经常想要自定义他们的应用程序的外观和感觉。允许这种更改的应用程序被认为是“可换肤的”，每种不同的外观和感觉被称为皮肤。考虑一个接口以及适当的LookAndFeel类实现更改，以便实现pdCalc的换肤功能。一些可能的选项包括一个自定义各个小部件的对话框或者从皮肤配置文件中选择皮肤的机制。拥有一个集中的类来处理应用程序的外观和感觉应该使这个更改变得简单。别忘了给LookAndFeel添加一个信号，这样其他GUI元素将知道何时需要用新的外观重绘自己！</p>
<h3 id="8-3-3-流程控制">8.3.3 流程控制</h3>
<p>通过变量，我们极大地增强了存储过程的灵活性。对于计算大多数公式，这个框架应该足够了。然而，如果我们想要实现一个递归公式，例如计算一个数的阶乘呢？虽然我们可以通过插件执行这种复杂的计算，但如果能将这种功能扩展给那些不是经验丰富的C++程序员的计算器用户就更好了。要完成这个任务，我们需要设计一种流程控制语法。最简单的设计至少能够处理循环和条件操作。将流程控制添加到pdCalc将是一个相当重要的增强，无论是在增加的功能还是实现工作方面。现在可能是时候使用一个真正的扫描器和解析器了！</p>
<h3 id="8-3-4-另一种GUI布局">8.3.4 另一种GUI布局</h3>
<p>pdCalc GUI目前具有垂直方向，灵感来自HP48S计算器。然而，现代屏幕分辨率往往比宽度更高，这使得垂直方向不够理想。硬编码水平方向并不比原来的垂直方向更具挑战性。相反，考虑如何重新设计pdCalc，在运行时能够在方向之间切换。也许垂直方向只是一个不同的皮肤选项？</p>
<h3 id="8-3-5-绘图计算器">8.3.5 绘图计算器</h3>
<p>HP48系列计算器不仅仅是科学计算器，它们还是绘图计算器。虽然在计算机上实现一个绘图计算器可能不太实际，因为已经存在复杂的独立绘图程序，但这个练习可能会很有趣。从5.7版本开始，Qt现在包含一个绘图模块，使这个任务比以前容易得多。鉴于这个绘图小部件集，最大的挑战可能仅仅是设计一种图形输入方法。如果你想回到20世纪70年代，可以考虑为CLI实现一个ASCII绘图计算器！</p>
<h3 id="8-3-6-插件管理系统">8.3.6 插件管理系统</h3>
<p>目前，插件在pdCalc启动时加载，加载哪些插件是通过从文本文件中读取共享库名称来确定的。插件一旦加载，就不能卸载。考虑实现一个动态插件管理系统，以便在运行时选择、加载和卸载插件。你甚至可以扩展插件接口，以便动态查询插件描述。我认为这里真正的问题将是如何处理卸载一个在撤销/重做堆栈中有一个命令的插件。</p>
<h3 id="8-3-7-移动设备界面">8.3.7 移动设备界面</h3>
<p>在我最初为创建这本书所做的构想中，我设想了一章描述如何将pdCalc扩展到iOS或Android平板。Qt库可以再次帮助你完成这个任务。我没有在这本书中包含这样一章的原因是，我没有任何实际的平板编程经验。我觉得试图教别人如何从我第一次涉足这个设计领域开始设计平板界面是不诚实的。好吧，这可能是一个糟糕设计的绝佳示例！尽管如此，将pdCalc扩展到平板或智能手机界面是一个值得尝试的挑战，也是我留给你们的最后一个挑战。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">漫艺海</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/">http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">漫艺海的blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Practical-C-Design-From-Programming-to-Architecture-1ed/">Practical C++ Design From Programming to Architecture 1ed</a></div><div class="post_share"><div class="social-share" data-image="/img/logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/" title="7. 插件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">7. 插件</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/" title="5. 命令行接口"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">5. 命令行接口</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/1.Defining-the-Case-Study/" title="1. 定义案例研究"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">1. 定义案例研究</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/2.Decomposition/" title="2. 分解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">2. 分解</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/" title="3. 堆栈"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">3. 堆栈</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/" title="5. 命令行接口"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">5. 命令行接口</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/" title="4. 命令分发器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">4. 命令分发器</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/6.The-Graphical-User-Interface/" title="6. 图形用户界面"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">6. 图形用户界面</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">漫艺海</div><div class="author-info__description">漫艺海的个人站，主要涉及C++知识共享、实践教程等方面</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">8. 新的需求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%AE%8C%E5%85%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text">8.1 完全设计的新功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.1.</span> <span class="toc-text">8.1.1 批处理操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">8.1.2 存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-1-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">8.1.2.1 用户界面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-2-%E5%91%BD%E4%BB%A4%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E6%9B%B4%E6%94%B9"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">8.1.2.2 命令调度器的更改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-3-%E8%AE%BE%E8%AE%A1StoredProcedure%E7%B1%BB"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">8.1.2.3 设计StoredProcedure类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-4-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">8.1.2.4 组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-5-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">8.1.2.5 第一次尝试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-6-StoredProcedure%E7%B1%BB%E7%9A%84%E6%9C%80%E7%BB%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">8.1.2.6 StoredProcedure类的最终设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%9B%B4%E6%9C%89%E7%94%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">8.2 更有用的计算器设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E5%A4%8D%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">8.2.1 复数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-1-%E4%BF%AE%E6%94%B9%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">8.2.1.1 修改输入和输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-2-%E4%BF%AE%E6%94%B9Stack"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">8.2.1.2 修改Stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-3-%E4%BF%AE%E6%94%B9%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">8.2.1.3 修改命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">8.2.2 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-1-%E8%BE%93%E5%85%A5%E5%92%8C%E6%96%B0%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">8.2.2.1 输入和新命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-2-%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A0%86%E6%A0%88"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">8.2.2.2 数字表示和堆栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-3-%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">8.2.2.3 符号表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-4-%E4%B8%80%E4%B8%AA%E5%BE%AE%E5%B0%8F%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%9A%E6%95%B0%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">8.2.2.4 一个微小的扩展：数值常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-5-%E7%94%B1%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">8.2.2.5 由变量实现的功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E8%87%AA%E6%88%91%E6%8E%A2%E7%B4%A2%E6%89%A9%E5%B1%95"><span class="toc-number">1.3.</span> <span class="toc-text">8.3 一些有趣的自我探索扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E9%AB%98DPI%E7%BC%A9%E6%94%BE"><span class="toc-number">1.3.1.</span> <span class="toc-text">8.3.1 高DPI缩放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E5%8A%A8%E6%80%81%E6%8D%A2%E8%82%A4"><span class="toc-number">1.3.2.</span> <span class="toc-text">8.3.2 动态换肤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">8.3.3 流程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-4-%E5%8F%A6%E4%B8%80%E7%A7%8DGUI%E5%B8%83%E5%B1%80"><span class="toc-number">1.3.4.</span> <span class="toc-text">8.3.4 另一种GUI布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-5-%E7%BB%98%E5%9B%BE%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">8.3.5 绘图计算器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-6-%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">8.3.6 插件管理系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-7-%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%95%8C%E9%9D%A2"><span class="toc-number">1.3.7.</span> <span class="toc-text">8.3.7 移动设备界面</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/27/CMake/cmake%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8qt%E7%9A%84windeployqt/" title="cmake配置自动调用qt的windeployqt并根据find_package设置的components拷贝动态库">cmake配置自动调用qt的windeployqt并根据find_package设置的components拷贝动态库</a><time datetime="2023-03-27T06:14:30.000Z" title="发表于 2023-03-27 14:14:30">2023-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/test/" title="9. 新的需求">9. 新的需求</a><time datetime="2023-03-26T12:29:12.427Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/" title="7. 插件">7. 插件</a><time datetime="2023-03-26T12:29:12.426Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/" title="8. 新的需求">8. 新的需求</a><time datetime="2023-03-26T12:29:12.426Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/" title="5. 命令行接口">5. 命令行接口</a><time datetime="2023-03-26T12:29:12.425Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 漫艺海</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">世上最幸运的事就是喜欢上一个人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>