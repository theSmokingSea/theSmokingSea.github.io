<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>4. 命令分发器 | 漫艺海的blog</title><meta name="author" content="漫艺海"><meta name="copyright" content="漫艺海"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="4. 命令分发器 命令分发器是计算器的核心。作为 MVC 框架中的控制器，命令分发器负责应用程序的整个业务逻辑。本章不仅讨论计算器的命令分发器模块的具体设计，还更广泛地讨论松散耦合命令基础设施的灵活设计。 4.1 命令分发器的分解 当我们分解堆栈时，第一个问题是：“堆栈应该划分为多少个组件？”现在我们也为命令分发器提出了同样的问题。为了回答这个问题，让我们考虑一下命令分发器必须封装的功能。命令分发">
<meta property="og:type" content="article">
<meta property="og:title" content="4. 命令分发器">
<meta property="og:url" content="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/index.html">
<meta property="og:site_name" content="漫艺海的blog">
<meta property="og:description" content="4. 命令分发器 命令分发器是计算器的核心。作为 MVC 框架中的控制器，命令分发器负责应用程序的整个业务逻辑。本章不仅讨论计算器的命令分发器模块的具体设计，还更广泛地讨论松散耦合命令基础设施的灵活设计。 4.1 命令分发器的分解 当我们分解堆栈时，第一个问题是：“堆栈应该划分为多少个组件？”现在我们也为命令分发器提出了同样的问题。为了回答这个问题，让我们考虑一下命令分发器必须封装的功能。命令分发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/logo.png">
<meta property="article:published_time" content="2023-03-26T12:29:12.424Z">
<meta property="article:modified_time" content="2023-03-26T12:29:12.424Z">
<meta property="article:author" content="漫艺海">
<meta property="article:tag" content="Practical C++ Design From Programming to Architecture 1ed">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/logo.png"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '4. 命令分发器',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-26 20:29:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="漫艺海的blog"><span class="site-name">漫艺海的blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">4. 命令分发器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-26T12:29:12.424Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-26T12:29:12.424Z" title="更新于 2023-03-26 20:29:12">2023-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Qt/">Qt</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="4. 命令分发器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>4. 命令分发器</h1>
<p>命令分发器是计算器的核心。作为 MVC 框架中的控制器，命令分发器负责应用程序的整个业务逻辑。本章不仅讨论计算器的命令分发器模块的具体设计，还更广泛地讨论松散耦合命令基础设施的灵活设计。</p>
<h2 id="4-1-命令分发器的分解">4.1 命令分发器的分解</h2>
<p>当我们分解堆栈时，第一个问题是：“堆栈应该划分为多少个组件？”现在我们也为命令分发器提出了同样的问题。为了回答这个问题，让我们考虑一下命令分发器必须封装的功能。命令分发器的功能是：</p>
<ol>
<li class="lvl-3">
<p>存储已知命令的集合，</p>
</li>
<li class="lvl-3">
<p>接收和解释这些命令的请求，</p>
</li>
<li class="lvl-3">
<p>调度命令请求（包括撤销和重做的能力），以及</p>
</li>
<li class="lvl-3">
<p>执行实际操作（包括更新计算器的状态）。</p>
</li>
</ol>
<p>在第二章中，我讨论了内聚原则。在类级别，为内聚性设计意味着每个类应该只做一件事，并且可以假定，做得很好。在最高分解层次上，命令分发器确实只做一件事：解释命令。然而，在任务层次上，从我们上面的功能列表中可以清楚地看出，它显然需要执行多个任务。因此，我们将命令分发器分解为几个不同的类，每个主要任务分配一个类。因此，我们有以下类：</p>
<ol>
<li class="lvl-3">
<p>CommandRepository：存储可用命令的列表</p>
</li>
<li class="lvl-3">
<p>CommandDispatcher：接收并解释执行命令的请求</p>
</li>
<li class="lvl-3">
<p>CommandManager：调度命令并管理撤销和重做</p>
</li>
<li class="lvl-3">
<p>Command hierarchy：执行命令</p>
</li>
</ol>
<p>本章余下部分致力于描述上述类和类层次结构的设计和显著实现细节。</p>
<h2 id="4-2-命令类">4.2 命令类</h2>
<p>在分解的这个阶段，我发现采用自下而上的设计方法更有用。在严格的自上而下的方法中，我们可能从接收和解释命令请求的 CommandDispatcher 类开始，然后一直深入到命令本身。然而，在这种自下而上的方法中，我们将从研究命令本身的设计开始。我们从被称为命令模式的抽象开始。</p>
<h3 id="4-2-1-命令模式">4.2.1 命令模式</h3>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/A454125_1_En_4_Fig1_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图4-1 命令模式的最简单层次结构
  	</div>
</center>
<p>从本质上讲，这种模式做了两件事。首先，它将命令的请求者与命令的调度者解耦。其次，它将对动作的请求（否则可能通过函数调用来实现）封装到一个对象中。这个对象可以携带状态，并在请求本身的即时生命周期之外具有延长的生命周期。</p>
<p>实际上，这两个特性给我们带来了什么？首先，由于请求者与调度者解耦，执行命令的逻辑不需要驻留在与执行命令的类相同的类或者相同的模块中。这显然降低了耦合度，但同时也提高了内聚性，因为可以为系统必须实现的每个独特命令创建一个独特的类。其次，由于请求现在被封装在与动作生命周期不同的命令对象中，命令既可以延迟执行（例如，排队命令），也可以撤销。撤销操作成为可能是因为已经执行的命令可以保留足够的数据以恢复到执行命令之前的状态。当然，将排队能力与撤销能力结合起来，允许为实现命令模式的所有请求创建无限制的撤销/重做功能。</p>
<h3 id="4-2-2-关于实现撤销-重做的更多内容">4.2.2 关于实现撤销/重做的更多内容</h3>
<p>pdCalc 的一个要求是实现无限撤销和重做操作。大多数书籍认为，通过仅在抽象命令接口中添加一个撤销命令，可以通过命令模式实现撤销。然而，这种简化处理忽略了正确实现撤销功能所需的实际细节。</p>
<p>实现撤销和重做涉及两个不同的步骤。首先（显然），在具体的命令类中必须正确实现撤销和重做。其次，必须实现一个数据结构来跟踪和存储分发的命令对象。自然地，这个数据结构必须保留命令执行的顺序，并能够分发撤销、重做或执行新命令的请求。在下面的第 4.4 节中详细描述了这个撤销/重做数据结构。现在讨论撤销和重做的实现。</p>
<p>实现撤销和重做操作本身通常是简单的。重做操作与命令的执行功能相同。只要在第一次执行命令之前和调用撤销之后系统的状态相同，那么实现重做命令本质上是免费的。这当然立即意味着，实现撤销实际上是要将系统的状态恢复到命令第一次执行之前。</p>
<p>撤销可以通过两种类似但略有不同的机制来实现，每种机制负责以不同的方式恢复系统的状态。第一种机制正如撤销的名称所暗示的：它接受系统的当前状态并真正地反转前进命令的过程。也就是说，从数学上讲，撤销是作为执行的逆操作来实现的。例如，如果前向操作是对栈顶数字取平方根，那么撤销操作将是对栈顶数字取平方。这种方法的优点是不需要存储额外的状态信息就能实现撤销。缺点是该方法不适用于所有可能的命令。让我们检查一下前面例子的相反情况。也就是说，考虑对栈顶数字进行平方。撤销操作将是对平方操作结果取平方根。然而，原始数字是平方的正根还是负根？在不保留额外状态信息的情况下，逆转方法会失效。</p>
<p>将撤销实现为逆操作的另一种方法是在命令首次执行之前保留系统的状态，然后将撤销实现为恢复到之前的状态。回到我们关于平方一个数的例子，前向操作既计算平方，又保存栈顶数字。然后，撤销操作通过从栈中删除结果并将保存的前向操作执行前的状态推送回来来实现。这个过程由命令模式启用，因为所有命令都实现为允许携带状态的具体命令类的实例。这种实现撤销的方法的一个有趣特点是操作本身不需要有数学逆。注意，在我们的例子中，撤销甚至不需要知道前向操作是什么。它只需要知道如何将栈顶元素替换为保存的状态。</p>
<p>在您的应用程序中使用哪种机制真的取决于您的应用程序执行的不同操作。当操作没有逆时，存储状态是唯一的选择。当逆操作计算成本过高时，存储状态通常是更好的实现。当存储状态的成本很高时，通过反转实现撤销是首选，假设存在逆操作。当然，由于每个命令都作为一个单独的类实现，整个系统不需要对如何实现撤销进行全局决策。针对特定操作的设计者可以自由选择适合该特定操作的方法，基于每个命令。在某些情况下，甚至混合方法（分别存储和反转操作的不同部分）可能是最佳的。在下一节中，我们将研究我为 pdCalc 做出的选择。</p>
<h3 id="4-2-3-将命令模式应用于计算器">4.2.3 将命令模式应用于计算器</h3>
<p>为了执行、撤销和重做计算器中的所有操作，我们将实现命令模式，每个计算器操作都将由派生自抽象 Command 类的自己的具体类封装。从上面关于命令模式的讨论中，我们可以看到，为了将模式应用于计算器，必须做出两个决定。首先，我们必须决定每个命令必须支持哪些操作。这组操作将定义 Command 基类的抽象接口。其次，我们必须选择如何支持撤销。准确地说，这个决定总是推迟到特定具体命令的实现者。然而，通过选择状态重构或命令反转，我们可以实现一些基础设施来简化命令实现者的撤销。我们将依次解决这两个问题。</p>
<h4 id="4-2-3-1-命令接口">4.2.3.1 命令接口</h4>
<p>选择在抽象Command类中包含哪些公共函数等同于为计算器中的所有命令定义接口。因此，这个决定不能轻率作出。虽然每个具体命令将执行不同的功能，但所有具体命令必须可以相互替代（回顾LSP）。因为我们希望接口最小但完整，我们必须确定能抽象地表示所有命令所需操作的最少函数数量。</p>
<p>首先要包括的两个命令是最明显且最容易定义的。它们分别是 execute() 和 undo()，分别用于执行命令的正向和逆向操作。这两个函数返回 void，不需要参数。不需要参数是因为计算器的所有数据都通过全局可访问的单例模式通过Stack类处理。此外，Command 类将需要一个构造函数和一个析构函数。因为这个类是带有虚拟函数的接口类，所以析构函数应该是虚拟的。Listing 4-1 展示了我们的第一次尝试接口。</p>
<p>Listing 4-1 命令接口的第一次尝试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Command</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 Listing 4-1 中，读者会立即注意到构造函数是受保护的，execute() 和 undo() 都是公共的且非虚拟的，并且存在单独的 executeImpl() 和 undoImpl() 虚拟函数。构造函数受保护的原因是向实现者发出信号，表示 Command 类不能直接实例化。当然，因为类包含纯虚拟函数，编译器无论如何都会阻止 Command 类的直接实例化。将构造函数设为受保护的有点多余。另一方面，使用虚拟和非虚拟函数组合定义公共接口值得更详细的解释。</p>
<p>通过公共非虚拟函数和私有虚拟函数的混合来为类定义公共接口是一种称为非虚拟接口（NVI）模式的设计原则。NVI模式规定，多态接口应始终使用非虚拟公共函数定义，这些函数将调用转发给私有虚拟函数。这个模式背后的原理非常简单。由于具有虚拟函数的基类充当接口类，客户端应该仅通过基类的接口通过多态访问派生类的功能。通过使公共接口非虚拟，基类实现者保留了在调度之前拦截虚拟函数调用的能力，以便为所有派生类实现的执行添加前置条件或后置条件。使虚拟函数私有会强制消费者使用非虚拟接口。在不需要前置条件或后置条件的简单情况下，非虚拟函数的实现简化为对虚拟函数的转发调用。坚持使用NVI模式，即使在简单的情况下，也是有道理的，因为它在零计算开销下保留了未来扩展的设计灵活性，因为转发函数调用可以内联。关于NVI模式的更深入的基本原理详见 Sutter [27]。</p>
<p>现在让我们考虑execute()和undo()是否需要前置条件或后置条件；我们从execute()开始。通过快速浏览第2章的用例，我们可以看到pdCalc必须完成的许多操作只有在满足一组前置条件后才能执行。例如，要将两个数相加，我们必须在栈上有两个数。显然，加法有一个前置条件。从设计角度来看，如果我们在命令执行之前捕获这个前置条件，我们可以在它们引起执行问题之前处理前置条件错误。在调用executeImpl()之前，我们肯定希望将检查前置条件作为基类execute()实现的一部分。</p>
<p>对于所有命令，必须检查哪些前置条件？也许，就像加法一样，所有命令都必须至少在栈上有两个数字？让我们再看一个用例。考虑求一个数的正弦值。这个命令只需要在栈上有一个数字。啊，前置条件是特定于命令的。关于通用处理前置条件的问题的正确答案是要求派生类通过让execute()首先调用一个checkPreconditionsImpl()虚拟函数来检查它们自己的前置条件。</p>
<p>关于execute()的后置条件怎么样呢？事实证明，如果满足每个命令的前置条件，那么所有命令在数学上都定义良好。很好，不需要进行后置条件检查！不幸的是，数学正确性不能确保浮点数计算没有错误。例如，即使加法在数学上定义良好，使用pdCalc所需的双精度数进行浮点加法也可能导致正溢出。然而，幸运的是，我们第一章的要求规定可以忽略浮点错误。因此，在技术上我们不需要处理浮点错误，最终也不需要进行后置条件检查。</p>
<p>为了保持代码相对简单，我选择遵循要求，在pdCalc中忽略浮点异常。如果我想在设计中积极捕获浮点错误，可以使用checkPostconditions()函数。因为浮点错误对所有命令都是通用的，所以后置条件检查可以在基类级别处理。</p>
<p>了解我们的前置条件和后置条件需求，使用NVI模式，我们能够编写如下图4-2所示的简单execute()实现。</p>
<p>Listing 4-2 execute()的简单实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Command::execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">checkPreconditionsImpl</span>();</span><br><span class="line">  <span class="built_in">executeImpl</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到checkPreconditionsImpl()和executeImpl()都必须被派生类连续调用和处理，我们能否将这两个操作合并到一个函数调用中？我们可以这样做，但这样的决策会导致次优的设计。首先，通过将这两个操作合并到一个executeImpl()函数调用中，我们将失去内聚性，因为要求一个函数执行两个不同的操作。其次，通过使用单独的checkPreconditionsImpl()调用，我们可以选择强制派生类实现者检查前置条件（通过使checkPreconditionsImpl()纯虚拟）或者为前置条件检查提供一个可选的默认实现。最后，谁能说checkPreconditionsImpl()和executeImpl()将分发给相同的派生类？请记住，层次结构可以有多个级别。</p>
<p>与execute()函数类似，人们可能会认为撤销命令需要进行前置条件检查。然而，事实证明，我们实际上不必检查撤销的前置条件，因为它们在构造过程中总是为真。也就是说，由于撤销命令只能在执行命令成功完成后调用，因此undo()的前置条件是确保满足的（当然，前提是execute()的正确实现）。与正向执行一样，undo()也不需要进行后置条件检查。</p>
<p>对execute()和undo()的前置条件和后置条件的分析仅导致在虚拟接口中添加了一个函数checkPreconditionImpl()。然而，为了使这个函数的实现完整，我们必须确定这个函数的正确签名。首先，函数的返回值应该是什么？我们可以选择使返回值为空并通过异常处理前置条件的失败，或者使返回值为一种可以表示前置条件未满足的类型（例如，在前置条件失败时返回false的布尔值或表示发生的故障类型的枚举）。对于pdCalc，我选择通过异常处理前置条件失败。这种策略具有更高的灵活性，因为错误不需要由直接调用者execute()函数处理。此外，可以设计异常以携带可由派生命令扩展的自定义描述性错误消息。这与使用枚举类型形成对比，后者必须由基类实现者完全定义。</p>
<p>我们在指定checkPreconditionImpl()的签名时必须解决的第二个问题是选择该函数应该是纯虚拟的还是具有默认实现。尽管大多数命令确实需要满足一些前置条件，但并非所有命令都是如此。例如，将新数字输入堆栈不需要前置条件。因此，checkPreconditionImpl()不应该是一个纯虚拟函数。相反，它被赋予一个默认实现，即什么也不做，这相当于声明前置条件已满足。</p>
<p>由于命令中的错误是通过checkPreconditionImpl()函数检查的，任何命令的正确实现都不应该从checkPreconditionImpl()之外抛出异常。因此，为了增加接口保护，Command类中的每个纯虚拟函数都应标记为noexcept。为了简洁起见，我在文本中经常省略这个关键字；然而，noexcept确实出现在实现中。这个说明符在实现插件命令时才真正重要，插件命令将在第7章中讨论。</p>
<p>接下来要添加到Command类中的一组函数是用于多态地复制对象的函数。这组函数包括一个受保护的复制构造函数，一个公共的非虚拟clone()函数和一个私有的cloneImpl()函数。在这一设计阶段，为什么命令必须是可复制的还不能得到充分的解释。然而，当我们审查CommandRepository的实现时，原因将变得清晰。然而，为了连贯性，我现在将讨论复制接口的实现。</p>
<p>对于为多态使用而设计的类层次结构，简单的复制构造函数是不够的，对象的复制必须通过克隆虚拟函数执行。考虑以下仅显示复制构造函数的简略命令层次结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Command</span>(<span class="type">const</span> Command&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Add</span>(<span class="type">const</span> Add&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们的目标是复制多态地使用的命令。让我们看下面的例子，我们通过一个Command指针持有一个Add对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command* p = <span class="keyword">new</span> Add;</span><br></pre></td></tr></table></figure>
<p>根据定义，复制构造函数将自身类类型的引用作为其参数。因为在多态设置中我们不知道底层类型，我们必须尝试调用复制构造函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> Command&#123;*p&#125;;</span><br></pre></td></tr></table></figure>
<p>上述构造是非法的，将无法编译。因为Command类是抽象的（且其复制构造函数受保护），编译器不允许创建Command对象。然而，并非所有层次结构都有抽象基类，因此在那些合法的情况下，人们可能会尝试这种构造。小心。这种构造会切断层次结构。也就是说，p2将作为一个Command实例而不是一个Add实例构造，p中的任何Add状态都将在复制中丢失。</p>
<p>既然我们不能直接使用复制构造函数，那么如何在多态环境中复制类呢？解决方案是提供一个虚拟克隆操作，可以如下使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command* p2 = p-&gt;<span class="built_in">clone</span>();</span><br></pre></td></tr></table></figure>
<p>这里，非虚拟clone()函数将克隆操作分派给派生类的cloneImpl()函数，其实现只是用解引用的this指针作为参数调用自己的复制构造函数。对于上面的示例，扩展的接口和实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Command* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">cloneImpl</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Command</span>(<span class="type">const</span> Command&amp;) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Command* <span class="title">cloneImpl</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Add</span>(<span class="type">const</span> Add&amp; rhs)</span><br><span class="line">        : Command &#123; rhs &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Add* <span class="title">cloneImpl</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Add &#123; *<span class="keyword">this</span> &#125;; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里唯一有趣的实现特性是cloneImpl()函数的返回类型。注意，基类将返回类型指定为Command*，而派生类将返回类型指定为Add*。这种构造称为返回类型协变，这是一条规则，它规定派生类中的覆盖函数可以返回比虚拟接口中的返回类型更具体的类型。协变允许克隆函数总是返回与调用克隆的层次结构级别相对应的特定类型。对于具有公共克隆函数并允许从层次结构的所有级别进行克隆调用的实现，这个特性非常重要。</p>
<p>我选择用帮助消息函数和相应的虚拟实现函数来完善命令接口。这个帮助函数的目的是强制单个命令实现者为用户界面中的帮助命令提供简要的文档。帮助函数对于命令的功能并非必要，将其作为设计的一部分是可选的。然而，即使在一个像计算器这样简单的程序中，提供一些内部文档来描述命令的用法总是很好的。</p>
<p>结合所有上述信息，我们终于可以为我们的Command类编写完整的抽象接口；请参见列表4-3。</p>
<p>列表4-3 Command类的完整抽象接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Command* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">helpMessage</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Command</span>();</span><br><span class="line">    <span class="built_in">Command</span>(<span class="type">const</span> Command&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">checkPreconditionsImpl</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Command* <span class="title">cloneImpl</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">helpMessageImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你查看Command.h中的源代码，你还会看到一个虚拟的deallocate()函数。这个函数专门用于插件，它在接口中的添加将在第7章中讨论。</p>
<hr>
<p>现代C++设计注意事项：override关键字</p>
<p>override关键字在C<ins>11中引入。从功能上讲，它可以防止一个常见的错误，这种错误通常让新的C</ins>程序员感到惊讶。请考虑以下代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Base* p = <span class="keyword">new</span> Derived;</span><br><span class="line">p-&gt;<span class="built_in">foo</span>(<span class="number">2.1</span>);</span><br></pre></td></tr></table></figure>
<p>哪个函数被调用？大多数初学者C++程序员认为应该调用Derived::foo()，因为他们期望Derived的foo()覆盖了Base的实现。然而，由于foo()函数在基类和派生类之间的签名不同，Base的foo()实际上隐藏了Derived的实现，因为重载不能跨范围边界进行。因此，调用p-&gt;foo()将调用Base的foo()，而不管参数的类型如何。有趣的是，出于相同的原因</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">d-&gt;<span class="built_in">foo</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>永远只能调用Derived的foo()。</p>
<p>在C<ins>03和C</ins>11中，上述代码以完全相同的令人困惑但技术上正确的方式运行。然而，从C++11开始，派生类可以选择使用override关键字标记覆盖函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，编译器将标记声明为错误，因为程序员明确声明派生函数应该覆盖。因此，添加override关键字可以防止一个令人困惑的错误发生，让程序员明确自己的意图。</p>
<p>从设计的角度来看，override关键字明确地将函数标记为覆盖。虽然这可能看起来不重要，但在处理大型代码库时非常有用。在实现一个基类位于代码的另一个独立部分的派生类时，不查看基类的声明就能知道哪些函数覆盖了基类函数，哪些没有，这是很方便的。</p>
<hr>
<h4 id="4-2-3-2-撤销策略">4.2.3.2 撤销策略</h4>
<p>定义了命令的抽象接口后，我们接下来要设计撤销策略。从技术上讲，因为我们接口中的undo()命令是纯虚拟的，我们可以简单地摆手表示撤销的实现是每个具体命令的问题。然而，这样既不优雅也不高效。相反，我们寻求所有命令（或者至少是命令分组）的一些功能共性，这可能使我们能够在比命令层次结构中的每个叶子节点更高的层次上实现撤销。</p>
<p>如前所述，撤销可以通过命令反演或状态重建（或两者的某种组合）来实现。命令反演已经被证明是有问题的，因为对于某些命令来说，逆问题是不适定的（具体来说，它有多个解）。因此，让我们来研究状态重建作为pdCalc的一种通用撤销策略。</p>
<p>我们通过考虑一个用例，加法操作来开始分析。加法从堆栈中移除两个元素，将它们相加，并返回结果。一个简单的撤销可以通过从堆栈中删除结果并恢复原始操作数来实现，前提是这些操作数是由execute()命令存储的。现在，考虑减法、乘法或除法。这些命令也可以通过删除它们的结果和恢复它们的操作数来撤销。难道对所有命令实现撤销就这么简单，我们只需要在execute()过程中存储堆栈顶部的两个值，并通过删除命令的结果和恢复存储的操作数来实现撤销吗？不是的。考虑正弦、余弦和正切。它们每个都从堆栈中取一个操作数并返回一个结果。考虑交换。它从堆栈中取两个操作数并返回两个结果（相反顺序的操作数）。在所有命令上实现一个完全统一的撤销策略是不可能的。话虽如此，我们也不应该放弃希望，回到为每个命令单独实现撤销。</p>
<p>仅仅因为我们的计算器中所有命令都必须从Command类继承，并不意味着这种继承必须是图4-1中所示的直接继承。相反，考虑图4-2中所示的命令层次结构。虽然有些命令仍然直接从Command基类继承，但我们已经创建了两个新的子类，从这些子类可以继承更专门的命令。事实上，如稍后将看到的，这两个新基类本身就是抽象的。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/A454125_1_En_4_Fig2_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图4-2 计算器命令模式的多级层次结构
  	</div>
</center>
<p>我们前面的用例分析确定了两个显著的操作子类别，这些子类别分别为其成员实现了统一的撤销操作：二元命令（接受两个操作数并返回一个结果的命令）和一元命令（接受一个操作数并返回一个结果的命令）。因此，我们可以通过通用地处理这两个类别的命令来显著简化我们的实现。虽然不属于一元或二元命令族的命令仍然需要单独实现undo()，但这两个子类别占计算器核心命令的约75%。创建这两个抽象将节省大量工作。</p>
<p>让我们来看一下UnaryCommand类。根据定义，所有一元命令都需要一个参数并返回一个值。例如，f(x) = sin(x)从堆栈中取一个数，x，并将结果f(x)返回到堆栈上。如前所述，将所有一元函数作为一个家族来考虑的原因是，无论函数如何，所有一元命令都以相同的方式实现前向执行和撤销操作，仅在f的功能形式上有所不同。此外，它们还必须至少满足相同的前提条件。也就是说，堆栈上必须至少有一个元素。</p>
<p>在代码中，通过在UnaryCommand基类中重写executeImpl()、undoImpl()和checkPreconditionsImpl()，并创建一个新的unaryOperation()纯虚函数将每个命令的精确实现委托给一个更进一步派生的类来强制执行一元命令的上述共性。结果是一个具有如下声明的UnaryCommand类，见列表4-4。</p>
<p>列表4-4 UnaryCommand类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnaryCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">UnaryCommand</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkPreconditionsImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="built_in">UnaryCommand</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">UnaryCommand</span>(<span class="type">const</span> UnaryCommand&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">unaryOperation</span><span class="params">(<span class="type">double</span> top)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> top_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了完整起见，让我们来看一下从Command重写的三个函数的实现。检查前提条件是微不足道的；我们确保堆栈上至少有一个元素。如果没有，则抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UnaryCommand::checkPreconditionsImpl</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Stack::<span class="built_in">Instance</span>().<span class="built_in">size</span>() &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> Exception&#123;<span class="string">&quot;Stack must have one element&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>executeImpl()命令也相当简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UnaryCommand::executeImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top_ = Stack::<span class="built_in">Instance</span>().<span class="built_in">pop</span>(<span class="literal">true</span>);</span><br><span class="line">  Stack::<span class="built_in">Instance</span>().<span class="built_in">push</span>( <span class="built_in">unaryOperation</span>(top_) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆栈顶部的元素被弹出并存储在UnaryCommand的状态中以便撤销。请记住，因为我们已经检查了前提条件，我们可以确保unaryOperation()将在没有错误的情况下完成。具有特殊前提条件的命令仍然需要实现checkPreconditionsImpl()，但它们至少可以将一元前提条件检查委托给UnaryCommand的checkPreconditionImpl()函数。然后，我们一举将一元函数操作分派到一个更派生的类，并将其结果推回堆栈。</p>
<p>UnaryCommand的executeImpl()函数中唯一的特殊之处是堆栈的pop命令的布尔参数。这个布尔值可选地抑制发出堆栈更改事件。因为我们知道接下来的push命令会立即再次更改堆栈，所以没有必要发出两个连续的堆栈更改事件。抑制这个事件允许命令实现者将命令的动作归为一个用户可见的事件。虽然这个布尔参数不是Stack的pop()的原始设计的一部分，但这个功能现在可以作为一个便利添加到Stack类中。请记住，设计是迭代的。</p>
<p>最后要检查的成员函数是undoImpl()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UnaryCommand::undoImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack::<span class="built_in">Instance</span>().<span class="built_in">pop</span>(<span class="literal">true</span>);</span><br><span class="line">    Stack::<span class="built_in">Instance</span>().<span class="built_in">push</span>(top_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数也具有预期的明显实现。一元操作的结果从堆栈中删除，而在执行executeImpl()期间存储在类的top_成员中的前一个顶部元素被恢复到堆栈。</p>
<p>作为使用UnaryCommand类的示例，我们展示了正弦命令的部分实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sine</span> : <span class="keyword">public</span> UnaryCommand &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">unaryOperation</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">sin</span>(t); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>显然，使用UnaryCommand作为基类而不是最高级别的Command类的优势在于，我们不再需要实现undoImpl()和checkPreconditionsImpl()，并用稍微简单的unaryOperation()替换了executeImpl()的实现。我们不仅需要更少的总体代码，而且由于所有一元命令的undoImpl()和checkPreconditionsImpl()的实现是相同的，我们还减少了代码重复，这总是一个好处。</p>
<p>二元命令的实现与一元命令类似。唯一的区别是执行操作的函数需要两个命令作为操作数，并相应地必须存储这两个值以进行撤销。BinaryCommand类的完整定义可以在GitHub存储库中的源代码中找到，与Command和UnaryCommand类一起位于Command.h头文件中。</p>
<h4 id="4-2-3-3-具体命令">4.2.3.3 具体命令</h4>
<p>定义了上述的Command、UnaryCommand和BinaryCommand类，完成了在计算器中使用命令模式的抽象接口。正确实现这些接口占据了命令设计的主要部分。然而，到目前为止，我们的计算器还没有一个具体的命令（除了部分正弦类实现）。本节将最终解决这个问题，我们的计算器的核心功能将开始成型。</p>
<p>计算器的核心命令都定义在CoreCommands.h文件中，它们的实现可以在相应的CoreCommands.cpp文件中找到。什么是核心命令？我将核心命令定义为从第1章中列出的要求中提炼出的功能的命令集。对于计算器必须执行的每个不同操作，都存在一个独特的核心命令。为什么我称之为核心命令？因为它们与计算器一起编译和链接，因此在计算器加载时立即可用。实际上，它们是计算器的内在组成部分。这与插件命令形成对比，插件命令可以在运行时动态地由计算器选择加载。插件命令将在第7章详细讨论。</p>
<p>虽然人们可能会怀疑我们现在需要进行分析以确定核心命令，但事实证明，这种分析已经完成。具体来说，核心命令是由第2章中用例描述的动作定义的。敏锐的读者甚至会记得，用例中的异常列表定义了每个命令的前提条件。因此，在必要时参考用例，人们可以轻松地推导出核心命令。为方便起见，它们都列在表4-1中。</p>
<p>表4-1 按照其直接抽象基类列出的核心命令</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>UnaryCommand</th>
<th>BinaryCommand</th>
</tr>
</thead>
<tbody>
<tr>
<td>EnterCommand</td>
<td>Sine</td>
<td>Add</td>
</tr>
<tr>
<td>SwapTopOfStack</td>
<td>Cosine</td>
<td>Subtract</td>
</tr>
<tr>
<td>DropTopOfStack</td>
<td>Tangent</td>
<td>Multiply</td>
</tr>
<tr>
<td>Duplicate</td>
<td>Arcsine</td>
<td>Divide</td>
</tr>
<tr>
<td>ClearStack</td>
<td>Arccosine</td>
<td>Power</td>
</tr>
<tr>
<td></td>
<td>Arctangent</td>
<td>Root</td>
</tr>
<tr>
<td></td>
<td>Negate</td>
<td></td>
</tr>
</tbody>
</table>
<p>在将上述核心命令列表与第2章的用例进行比较时，可以注意到撤消和重做作为命令的明显缺失，尽管它们都是用户可以要求计算器执行的操作。这两个“命令”很特殊，因为它们对系统中的其他命令起作用。出于这个原因，它们并没有按照命令模式的意义实现为命令。相反，它们由尚待讨论的 CommandManager 从内部处理，这个类负责请求命令、调度命令以及请求撤消和重做操作。撤消和重做操作（与每个命令定义的撤消和重做操作相对）将在下面的第4.4节中详细讨论。</p>
<p>每个核心命令的实现，包括前提条件的检查、正向操作和撤消实现，都相对简单。大多数命令类可以用大约20行代码实现。如果感兴趣的读者希望查看细节，可以参考存储库源代码。</p>
<h4 id="4-2-3-4-深度命令层次结构的替代方案">4.2.3.4 深度命令层次结构的替代方案</h4>
<p>为每个操作创建一个单独的 Command 类是实现命令模式的非常经典的方式。然而，现代C++为我们提供了一个非常引人注目的替代方案，使我们能够将层次结构展平。具体来说，我们可以使用 lambda 表达式（请参见边栏）来封装操作，而不是创建额外的派生类，然后在 UnaryCommand 或 BinaryCommand 级别使用标准函数类（请参见边栏）来存储这些操作。为了使讨论具体化，让我们考虑 BinaryCommand 类的另一种部分设计，如 Listing 4-5 所示。</p>
<p>Listing 4-5 另一种部分设计</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryCommandAlternative</span> <span class="keyword">final</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line">    <span class="keyword">using</span> BinaryCommandOp = <span class="built_in">double</span>(<span class="type">double</span>, <span class="type">double</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BinaryCommandAlternative</span>(<span class="type">const</span> string&amp; help, naryCommandOp&gt; f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkPreconditionsImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">helpMessageImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="type">double</span> top_;</span><br><span class="line">    <span class="type">double</span> next_;</span><br><span class="line">    string helpMsg_;</span><br><span class="line">    function&lt;BinaryCommandOp&gt; command_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，我们不是声明一个实现 executeImpl() 的抽象 BinaryCommand，并通过将其推迟到 binaryOperation() 虚拟函数，而是声明一个接受可调用目标的具体和最终（请参见边栏）类，并通过调用此目标来实现 executeImpl()。事实上，BinaryCommand 和 BinaryCommandAlternative 之间唯一的实质性区别是 executeImpl() 命令的实现方式有一个微妙的区别；参见 Listing 4-6。</p>
<p>Listing 4-6 一个微妙的区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryCommandAlternative::executeImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top_ = Stack::<span class="built_in">Instance</span>().<span class="built_in">pop</span>(<span class="literal">true</span>);</span><br><span class="line">    next_ = Stack::<span class="built_in">Instance</span>().<span class="built_in">pop</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// invoke callable target instead of virtual dispatch:</span></span><br><span class="line">    Stack::<span class="built_in">Instance</span>().<span class="built_in">push</span>(<span class="built_in">command_</span>(next_, top_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，举个例子，我们不是声明一个 Multiply 类并实例化一个 Multiply 对象，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mult = <span class="keyword">new</span> Multiply;</span><br></pre></td></tr></table></figure>
<p>我们创建一个能够执行乘法的 BinaryCommandAlternative，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mult = <span class="keyword">new</span> BinaryCommandAlternative&#123; <span class="string">&quot;help msg&quot;</span>,</span><br><span class="line">  [](<span class="type">double</span> d, <span class="type">double</span> f)&#123; <span class="keyword">return</span> d * f; &#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>为了完整起见，我要提到，因为没有类进一步派生自 BinaryCommandAlternative，我们必须在构造函数中直接处理帮助消息，而不是在派生类中处理。此外，如实现的那样，BinaryCommandAlternative 只处理二元前提条件。然而，可以通过类似于处理二元操作的方式处理额外的前提条件。也就是说，在 checkPreconditionImpl() 中测试两个堆栈参数之后，构造函数可以接受并存储一个执行前提条件测试的 lambda。</p>
<p>显然，一元命令可以通过创建 UnaryCommandAlternative 类类似地处理二元命令。通过足够的模板，我相信你甚至可以将二元命令和一元命令统一到一个类中。然而，请注意，过多的巧妙做法，虽然在办公室里令人印象深刻，但通常不会导致可维护的代码。在这个扁平化的命令层次结构中，为二元命令和一元命令保持单独的类可能会在简洁性和可理解性之间取得适当的平衡。</p>
<p>BinaryCommand 的 executeImpl() 和 BinaryCommandAlternative 的 executeImpl() 之间的实现差异相当小。然而，你不应该低估这种变化的重要性。最终结果是命令模式实现的显著设计差异。在一般情况下，一个比另一个好吗？我认为这种说法不能毫不含糊地做出；每种设计都有权衡。BinaryCommand 策略是命令模式的经典实现，大多数有经验的开发人员都会将其视为这样。源代码非常容易阅读、维护和测试。对于每个命令，创建一个执行一个操作的类。另一方面，BinaryCommandAlternative 非常简洁。与为 n 个操作创建 n 个类相比，只有一个类存在，每个操作由构造函数中的一个 lambda 定义。如果代码简洁是你的目标，这种替代风格是难以击败的。然而，因为 lambda 本质上是匿名对象，所以通过不在系统中为每个二元操作命名而失去了一些清晰度。</p>
<p>对于 pdCalc，深层命令层次结构还是浅层命令层次结构哪个策略更好？就我个人而言，我更喜欢深层命令层次结构，因为为每个对象命名带来的清晰度。然而，对于诸如加法和减法之类的简单操作，我认为可以认为减少的代码行数比通过匿名性损失的清晰度更能提高清晰度。由于我个人的喜好，我使用深层层次结构和 BinaryCommand 类实现了大多数命令。尽管如此，我确实通过 BinaryCommandAlternative 实现了乘法，以说明实践中的实现。在生产系统中，我强烈建议选择其中一种策略。在同一系统中实现两种模式肯定比采用一种更令人困惑，即使选择的那个被认为是次优的。</p>
<hr>
<p>现代 C++ 设计注意事项：Lambda、标准函数和 final 关键字</p>
<p>Lambda、标准函数和 final 关键字实际上是三个独立的现代 C++ 概念。因此，我将分别讨论它们。</p>
<p><b>Lambdas:</b></p>
<p>Lambda（更正式地说，lambda 表达式）可以被认为是匿名函数对象。理解 Lambda 的最简单方法是考虑它们的函数对象等价物。定义 Lambda 的语法如下所示：<br>
capture-list{function-body}</p>
<p>上述 Lambda 语法与通过构造函数将 capture-list 存储为成员变量的函数对象完全相等，并提供一个带有由 argument-list 提供的参数和由 function-body 提供的函数体的 operator() const 成员函数。 operator() 的返回类型通常从函数体中推导出来，但如果需要，可以使用替代函数返回类型语法（即，在参数列表和函数体之间使用 -&gt; ret）手动指定。</p>
<p>鉴于 Lambda 表达式和函数对象之间的等价性，Lambda 实际上并没有为 C++ 提供新功能。在 C<ins>11 中可以使用 Lambda 完成的任何操作，在 C</ins>03 中都可以使用不同的语法完成。然而，Lambda 提供的是一种引人注目、简洁的内联、匿名函数声明语法。 Lambda 的两个非常常见的用例是作为 STL 算法的谓词和 C++11 异步任务的目标。有人甚至认为 Lambda 语法如此引人注目，以至于在高级代码中不再需要编写 for 循环，因为它们可以用 Lambda 和算法替换。就我个人而言，我觉得这种观点太极端了。</p>
<p>在二元命令的替代设计中，您看到了 Lambda 的另一个用途。它们可以存储在对象中，然后根据需求调用，为实现算法提供不同的选项。在某些方面，这种范例编码了策略模式的微型应用。为了避免与命令模式混淆，我特意没有在正文中介绍策略模式。有兴趣的读者可以参考 Gamma 等人[6]的详细信息。</p>
<p><b>标准函数：</b></p>
<p>函数类是 C++ 标准库的一部分。这个类为任何可调用目标提供了一个通用的包装器，将这个可调用目标转换为一个函数对象。本质上，任何像函数一样可以被调用的 C++ 结构都是可调用目标。这包括函数、Lambda 和成员函数。</p>
<p>标准函数提供了两个非常有用的特性。首先，它为与任何可调用目标进行接口提供了通用设施。也就是说，在模板编程中，将可调用目标存储在函数对象中可以统一对目标的调用语义，而不依赖于底层类型。其次，函数可以存储其他难以存储的类型，如 Lambda 表达式。在设计 BinaryCommandAlternative 时，我们利用了函数类来存储 Lambda，以实现小算法，将策略模式覆盖到命令模式上。尽管实际上没有在 pdCalc 中使用，但函数类的通用性实际上使得 BinaryCommandAlternative 构造函数可以接受除 Lambda 之外的可调用目标。</p>
<p><b> final 关键字：</b></p>
<p>final 关键字在 C<ins>11 中引入，使类设计者可以声明一个类不能从中继承，或者一个虚拟函数不能再被重写。对于那些来自 C# 或 Java 的程序员来说，你会知道 C</ins> 在最后（顺便说一句，这是有意的）添加这个功能方面晚了一步。</p>
<p>在 C<ins>11 之前，需要使用恶心的黑客手段来防止类的进一步派生。从 C</ins>11 开始，final 关键字使编译器可以强制执行此约束。在 C<ins>11 之前，许多 C</ins> 设计者认为 final 关键字是不必要的。希望让一个类不可继承的设计者可以将析构函数设置为非虚拟的，从而暗示从这个类派生是在设计者的意图之外。任何看过从 STL 容器继承的代码的人都会知道，开发者在不受编译器强制执行的意图上遵循得有多好。你多久听到一位开发人员说：“当然，通常来说这是个坏主意，但是，别担心，对我这个特殊情况来说没问题。”这种经常被说出的评论几乎总是紧接着一周长的调试会议，以追踪到晦涩的错误。</p>
<p>你为什么可能想要防止从一个类继承或者重写先前声明的虚拟函数？可能是因为你遇到了一个情况，即使语言定义得很好，从逻辑上来说继承也没有意义。一个具体的例子是 pdCalc 的 BinaryCommandAlternative 类。虽然你可以尝试从它派生并重写 executeImpl() 成员函数（也就是说，没有 final 关键字），但这个类的目的是终止层次结构并通过可调用目标提供二元操作。从 BinaryCommandAlternative 继承是在其设计范围之外。因此，防止派生可能会防止微妙的语义错误。</p>
<hr>
<h2 id="4-3-命令仓库">4.3 命令仓库</h2>
<p>现在我们的计算器拥有了满足其需求的所有命令。然而，我们尚未定义存储命令并随后按需访问它们所需的基础设施。在本节中，我们将探讨存储和检索命令的几种设计策略。</p>
<h3 id="4-3-1-CommandRepository-类">4.3.1 CommandRepository 类</h3>
<p>乍一看，实例化一个新的命令似乎是一个很容易解决的问题。例如，如果用户要求两个数字相加，以下代码将执行此功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Command* cmd = <span class="keyword">new</span> Add;</span><br><span class="line">cmd-&gt;<span class="built_in">execute</span>();</span><br></pre></td></tr></table></figure>
<p>太好了！问题解决了，对吧？并非如此。这段代码是如何被调用的？这段代码出现在哪里？如果添加了新的核心命令（即需求发生变化）会怎么样？如果动态地添加新命令（如插件）会怎么样？看似容易解决的问题实际上比最初预期的要复杂得多。让我们通过回答上述问题来探讨可能的设计替代方案。</p>
<p>首先，我们提出如何调用代码的问题。计算器的需求之一是要有命令行界面（CLI）和图形用户界面（GUI）。显然，初始化命令的请求将在用户界面中响应用户操作时派生。让我们考虑一下用户界面如何处理减法。假设 GUI 有一个减法按钮，当这个按钮被点击时，将调用一个函数来初始化并执行减法命令（我们暂时忽略撤销功能）。现在考虑 CLI。当识别到减法符号时，会调用类似的函数。起初，人们可能会期望我们可以调用相同的函数，前提是它存在于业务逻辑层而不是用户界面层。然而，GUI 回调的机制使得这种做法变得不可能，因为它会强制在业务逻辑层中引入一个不需要的依赖关系，即依赖于 GUI 的小部件库（例如，在 Qt 中，按钮回调是一个类中的槽，需要回调的类是一个 Q_OBJECT）。另一种选择是，GUI 可以部署双重间接分派每个命令（每次按钮点击都会调用一个函数，这个函数会调用业务逻辑层中的一个函数）。这种情况既不优雅也不高效。</p>
<p>尽管上述策略看起来相当繁琐，但这种初始化方案的结构赤字比不方便要深得多。在我们为 pdCalc 采用的模型-视图-控制器架构中，视图不允许直接访问控制器。由于命令正确地属于控制器，所以 UI 对命令的直接初始化违反了我们的基本架构。</p>
<p>我们如何解决这个新问题？回想一下表 2-2 中的命令调度器的唯一公共接口是事件处理函数 commandEntered(const string&amp;)。实际上，这个认识回答了我们最初提出的前两个问题：初始化和执行代码是如何被调用的，以及它们位于哪里？这段代码必须通过来自 UI 到命令调度器的事件间接触发，并通过字符串对特定命令进行编码。代码本身必须驻留在命令调度器中。请注意，这个接口还具有在 CLI 和 GUI 之间创建新命令时消除重复的额外优点。现在，两个用户界面都可以简单地通过触发 commandEntered 事件并通过字符串指定命令来创建命令。分别在第 5 章和第 6 章中，你将看到每个用户界面如何实现触发这个事件。</p>
<p>从上述分析中，我们有动力在命令调度器中添加一个新类，负责拥有和分配命令。我们将这个类称为 CommandRepository。目前，我们假设命令调度器的另一部分（CommandDispatcher 类）接收 commandEntered() 事件，并从 CommandRepository 中请求适当的命令（通过 commandEntered() 的字符串参数），而命令调度器的另一个组件（CommandManager 类）随后执行命令（并处理撤销和重做）。也就是说，我们已经将命令的初始化和存储与它们的调度和执行分离开来。CommandManager 和 CommandDispatcher 类是即将到来的章节的主题。现在，我们将关注命令存储、初始化和检索。</p>
<p>我们从 CommandManager 类的以下基本接口开始：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandRepository</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">unique_ptr&lt;Command&gt; <span class="title">allocateCommand</span><span class="params">(<span class="type">const</span> string&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的接口我们可以看到，给定一个字符串参数，存储库分配相应的命令。接口使用智能指针返回类型明确表示调用者拥有新构建命令的内存。</p>
<p>现在让我们考虑一下 allocateCommand() 的实现可能是什么样子的。这个练习将帮助我们修改设计以获得更大的灵活性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Command&gt; <span class="title">CommandRepository::allocateCommand</span><span class="params">(<span class="type">const</span> string&amp; c)</span></span></span><br><span class="line"><span class="function">    <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Add&gt;();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Subtract&gt;();</span><br><span class="line">    <span class="comment">// ... all known commands ...</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的接口简单有效，但它的局限性在于需要预先知道系统中的每个命令。通常情况下，这样的设计将会因为几个原因而变得非常不受欢迎和不方便。首先，向系统添加新的核心命令需要修改存储库的初始化函数。其次，部署运行时插件命令需要一个完全不同的实现。第三，这种策略在特定命令的实例化和存储之间创建了不需要的耦合。相反，我们更喜欢一种设计，其中 CommandRepository 仅依赖于 Command 基类定义的抽象接口。</p>
<p>上述问题通过应用一个简单的模式来解决，即原型模式 [6]。原型模式是一种创建型模式，其中存储一个原型对象，通过复制原型创建这种类型的新对象。现在，考虑一种将我们的 CommandRepository 视为仅仅是命令原型容器的设计。此外，让所有原型都通过 Command 指针存储，比如在哈希表中，使用字符串作为键（可能是在 commandEntered() 事件中引发的相同字符串）。然后，通过添加（或删除）新的原型命令，可以动态地添加（或删除）新命令。为了实现这种策略，我们对 CommandRepository 类进行如下添加：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandRepository</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">unique_ptr&lt;Command&gt; <span class="title">allocateCommand</span><span class="params">(<span class="type">const</span> string&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerCommand</span><span class="params">(<span class="type">const</span> string&amp; name, unique_ptr&lt;Command&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> Repository = unordered_map&lt;string, unique_ptr&lt;Command&gt;&gt;;</span><br><span class="line">    Repository repository_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注册命令的实现非常简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CommandRepository::registerCommand</span><span class="params">(<span class="type">const</span> string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">    unique_ptr&lt;Command&gt; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (repository_.<span class="built_in">find</span>(name) != repository_.<span class="built_in">end</span>())</span><br><span class="line">        <span class="comment">// handle duplicate command error</span></span><br><span class="line">        <span class="keyword">else</span> repository_.<span class="built_in">emplace</span>(name, std::<span class="built_in">move</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们检查命令是否已经在存储库中。如果是，那么我们处理错误。如果不是，那么我们将命令参数移动到存储库中，命令成为命令名称的原型。注意，unique_ptr 的使用表明注册命令将原型的所有权转移到命令存储库。在实际使用中，核心命令都通过 CoreCommands.cpp 文件中的一个函数注册，每个插件内部也存在一个类似的函数来注册插件命令（我们将在第7章检查插件构建时看到这个接口）。这些函数分别在计算器初始化和插件初始化期间调用。可以选择使用一个注销命令来增强命令存储库，具有显而易见的实现。</p>
<p>使用我们的新设计，我们可以将 allocateCommand() 函数重写为以下内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Command&gt; CommandRepository ::<span class="built_in">allocateCommand</span>(<span class="type">const</span> string&amp; name)</span><br><span class="line">    <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = repository_.<span class="built_in">find</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (it != repository_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;Command&gt;(it-&gt;second-&gt;<span class="built_in">clone</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，如果在存储库中找到命令，则返回原型的副本。如果找不到命令，返回 nullptr（或者可以抛出异常）。原型的副本以 unique_ptr 形式返回，表示调用者现在拥有这个命令的副本。注意 Command 类中 clone() 函数的使用。clone 函数最初被添加到 Command 类中，以后会有合理的解释。如今显而易见，我们需要 clone() 函数以便为原型模式的实现多态地复制 Commands。当然，如果我们在设计 Command 类时没有预见到为所有命令实现克隆函数，现在可以很容易地添加。请记住，你不会在第一次尝试就完美地完成设计，所以习惯迭代设计的想法。</p>
<p>基本上，registerCommand() 和 allocateCommand() 实现了 CommandRepository 类的最小完整接口。然而，如果你查看这个类的包含的源代码，你会发现一些差异。首先，接口中添加了额外的函数。额外的函数主要是便利和语法糖。其次，整个接口都隐藏在一个 pimpl 后面。第三，我使用别名 CommandPtr，而不是直接使用 unique_ptr<Command>。对于本章的目的，只需将 CommandPtr 视为由以下 using 语句定义：</Command></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> CommandPtr = std::unique_ptr&lt;Command&gt;;</span><br></pre></td></tr></table></figure>
<p>实际上的别名，可以在 Command.h 中找到，稍微复杂一些。它将在第7章详细解释。相应地，我使用函数 MakeCommandPtr() 而不是 make_unique<Command>() 来创建 CommandPtrs。</Command></p>
<p>最后，从存储库代码中尚未讨论的接口部分，唯一影响设计的是使 CommandRepository 成为单例的选择。这个决定的原因很简单。无论系统中存在多少不同的命令调度器（有趣的是，我们最终会看到一个拥有多个命令调度器的案例），函数的原型永远不会改变。因此，使 CommandRepository 成为单例可以集中存储、分配和检索计算器的所有命令。</p>
<hr>
<p>现代 C++ 设计注意事项：统一初始化</p>
<p>你可能已经注意到我经常使用大括号进行初始化。对于长时间使用 C++ 编程的开发者来说，用大括号初始化类（即调用其构造函数）可能看起来有些奇怪。虽然我们习惯于使用列表语法初始化数组，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>但使用大括号初始化类是 C<ins>11 中的新特性。虽然仍然可以使用括号调用构造函数，但使用大括号的新语法，称为统一初始化，是现代 C</ins> 的首选语法。虽然这两种初始化机制在功能上执行相同的任务，但新语法有三个优势：</p>
<ol>
<li class="lvl-3">
<p>统一初始化是非收窄的：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="built_in">A</span>(<span class="type">int</span> a); &#125;;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">7.8</span>)</span></span>; <span class="comment">// ok, truncates</span></span><br><span class="line">A a&#123;<span class="number">7.8</span>&#125;; <span class="comment">// error, narrows</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>统一初始化（结合初始化器列表）允许用列表初始化用户定义的类型：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;<span class="type">double</span>&gt; v&#123; <span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span> &#125;; </span><br><span class="line"><span class="comment">// valid since C++11; initializes vector with 3 doubles</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>统一初始化永远不会被误解析为函数：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123; <span class="built_in">B</span>(); <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">()</span></span>; <span class="comment">// Are you declaring a function that returns a B?</span></span><br><span class="line">b.<span class="built_in">foo</span>(); <span class="comment">// error, requesting foo() in non-class type b</span></span><br><span class="line">B b2&#123;&#125;; <span class="comment">// ok, default construction</span></span><br><span class="line">b2.<span class="built_in">foo</span>(); <span class="comment">// ok, call B::foo()</span></span><br></pre></td></tr></table></figure>
<p>在使用统一初始化时，只有一个很大的警告：列表构造函数总是在任何其他构造函数之前被调用。典型的例子来自于 STL vector 类，它具有一个初始化列表构造函数和一个单独的构造函数，接受一个整数来定义向量的大小。因为如果使用大括号，初始化列表构造函数在任何其他构造函数之前被调用，所以有以下不同的行为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// vector, size 3, all elements initialized to 0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">3</span>&#125;; <span class="comment">// vector with 1 element initialized to 3</span></span><br></pre></td></tr></table></figure>
<p>幸运的是，上述情况并不经常发生。然而，当它发生时，你必须了解统一初始化和函数风格初始化之间的区别。</p>
<p>从设计角度来看，统一初始化的主要优势是用户定义的类型可以设计为接受用于构造的相同类型值的列表。因此，诸如向量之类的容器可以使用值列表进行静态初始化，而不是默认初始化后接连续赋值。这个现代 C++ 功能使得派生类型的初始化可以使用与内置数组类型相同的初始化语法，这是 C++03 缺失的语法特性。</p>
<h3 id="4-3-2-注册核心命令">4.3.2 注册核心命令</h3>
<p>现在我们已经定义了计算器的核心命令和一个用于按需加载和提供命令的类。然而，我们还没有讨论将核心命令加载到 CommandRepository 的方法。为了正常工作，所有核心命令的加载只能执行一次，并且必须在使用计算器之前执行。本质上，这为命令调度器模块定义了一个初始化需求。由于退出程序时不需要注销核心命令，因此不需要最终化函数。</p>
<p>在计算器的 main() 函数中调用命令调度器的初始化操作是最好的地方。因此，我们只需创建一个全局的 RegisterCoreCommands() 函数，在 CoreCommands.h 头文件中声明它，在 CoreCommands.cpp 文件中实现它，并从 main() 中调用它。之所以创建一个全局函数而不是在 CommandRepository 的构造函数中注册核心命令，是为了避免将 CommandRepository 与命令层次结构的派生类耦合在一起。当然，注册函数可以叫做像 InitCommandDispatcher() 这样的名字，但我更喜欢一个更具体描述功能的名字。</p>
<p>隐式地，我们刚刚扩展了命令调度器的接口（最初在表 2-2 中定义），尽管相当琐碎。我们应该能提前预料到这部分接口吗？可能不会。这个接口更新是由第 2 章的高级分解中明显更详细的设计决策所必需的。我发现在开发过程中稍微修改一个关键接口是设计程序的可接受方式。要求不变性的设计策略实在太死板了，不切实际。然而，请注意，在开发过程中轻易接受关键接口修改与在发布后接受关键接口修改之间的区别，这种决定应该只在深入考虑了这种更改将如何影响已经使用你的代码的客户端之后才做出。</p>
<h2 id="4-4-命令管理器">4.4 命令管理器</h2>
<p>设计了命令基础结构并为系统中的命令存储、初始化和检索创建了一个仓库后，我们现在准备设计一个负责按需执行命令并管理撤消和重做的类。这个类叫做 CommandManager。从本质上讲，它通过在每个命令上调用 execute() 函数并以适当的方式保留每个命令来管理命令的生命周期，以实现无限撤消和重做。我们将从定义 CommandManager 的接口开始，并通过讨论实现无限撤消和重做的策略来结束本节。</p>
<h3 id="4-4-1-接口">4.4.1 接口</h3>
<p>CommandManager 的接口非常简单直接。CommandManager 需要一个接受要执行的命令、撤消命令和重做命令的接口。此外，可以选择包括一个用于查询可用撤消和重做操作数量的接口，这对于实现 GUI 可能很重要（例如，对于重做大小等于零，使重做按钮变灰）。一旦命令传递给 CommandManager，CommandManager 就拥有命令的生命周期。因此，CommandManager 的接口应该强制使用所有权语义。结合起来，我们有以下 CommandManager 的完整接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">getUndoSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">getRedoSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">executeCommand</span><span class="params">(unique_ptr&lt;Command&gt; c)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">redo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在实际列在 CommandManager.h 中的代码中，接口还额外定义了一个用于在构造过程中选择撤消/重做策略的枚举类。我仅出于说明目的包含了这个选项。生产代码只需实现一个撤消/重做策略，而不需要在构造时使底层数据结构可定制。</p>
<h3 id="4-4-2-实现撤消和重做">4.4.2 实现撤消和重做</h3>
<p>要实现无限撤消和重做，我们必须有一个可动态增长的数据结构，能够以执行顺序存储和重新访问命令。尽管可以设计许多不同的数据结构来满足这个要求，但我们将研究两个同样优秀的策略。这两种策略都已经为计算器实现，并可以在 CommandManager.cpp 文件中看到。</p>
<p>考虑图 4-3 中的数据结构，我将其称为列表策略。执行命令后，将其添加到列表中（实现可以是列表、向量或其他适当的有序容器），并更新指向最后一个执行的命令的指针（或索引）。每当调用撤销时，当前指向的命令被撤销，指针向左移动（指向较早命令的方向）。当调用重做时，命令指针向右移动（指向较晚命令的方向），并执行新指向的命令。当当前命令指针到达最左边（没有更多命令可以撤销）或最右边（没有更多命令可以重做）时，存在边界条件。这些边界条件可以通过禁用使用户调用命令的机制（例如，分别使撤消或重做按钮变灰）来处理，或者简单地忽略导致指针越过边界的撤消或重做命令。当然，每次执行新命令时，在将新命令添加到撤消/重做列表之前，必须清空当前命令指针右侧的整个列表。清空列表是为了防止撤消/重做列表变成具有多个重做分支的树。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/A454125_1_En_4_Fig3_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        图 4-3 撤销/重做列表策略
  	</div>
</center>
<p>作为替代方案，请考虑图 4-4 中的数据结构，我将其称为堆栈策略。我们维护两个堆栈，一个用于撤销命令，一个用于重做命令，而不是按照执行顺序维护命令列表。执行新命令后，将其推入撤销堆栈。通过从撤销堆栈中弹出顶部条目，撤销命令，并将命令推入重做堆栈来撤销命令。通过从重做堆栈中弹出顶部条目，执行命令，并将命令推入撤销堆栈来重做命令。存在边界条件，可以通过堆栈大小轻松识别。执行新命令需要清空重做堆栈。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/A454125_1_En_4_Fig4_HTML.gif" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block; color: #999; padding: 2px;">
        Figure 4-4 The Undo/Redo Stack Strategy
        图 4-4 撤销/重做堆栈策略
  	</div>
</center>
<p>实际上，在通过堆栈或列表策略实现撤销和重做之间进行选择主要是个人喜好。列表策略只需要一个数据容器和较少的数据移动。然而，堆栈策略实现起来稍微容易一些，因为它不需要索引或指针移位。也就是说，两种策略都相当容易实现，且需要很少的代码。一旦你实现并测试了这两种策略中的任何一种，只要通过命令模式实现命令，未来需要撤销和重做功能的项目都可以轻松重用 CommandManager。为了更具通用性，CommandManager 可以在抽象的 Command 类上进行模板化。为了简单起见，我选择为之前讨论过的抽象 Command 类特别实现包含的 CommandManager。</p>
<h2 id="4-5-命令分发器">4.5 命令分发器</h2>
<p>命令分发器模块的最后一个组件是 CommandDispatcher 类本身。尽管这个类更恰当地被称为 CommandInterpreter，但我保留了 CommandDispatcher 这个名字，以强调这个类充当命令分发器模块与计算器其他部分之间的接口。也就是说，就其他模块而言，CommandDispatcher 类是命令分发器模块的全部。</p>
<p>如前所述，CommandDispatcher 类扮演了两个主要角色。第一个角色是作为命令分发器模块的接口。第二个角色是解释每个命令，从 CommandRepository 请求适当的命令，并将每个命令传递给 CommandManager 执行。我们依次解决这两个角色。</p>
<h3 id="4-5-1-接口">4.5.1 接口</h3>
<p>尽管命令分发器模块的实现相当复杂，但 CommandDispatcher 类的接口却非常简单（就像大多数优秀的接口一样）。如第 2 章所讨论的，命令分发器的接口完全由一个用于执行命令的单一功能组成；命令本身由一个字符串参数指定。这个功能自然是之前讨论过的 executeCommand() 事件处理程序。因此，CommandDispatcher 类的接口由以下内容给出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandDispatcher</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CommandDispatcher</span>(UserInterface&amp; ui);</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">executeCommand</span><span class="params">(<span class="type">const</span> string&amp; command)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unique_ptr&lt;CommandDispatcherImpl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回想一下，计算器的基本架构是基于模型-视图-控制器模式，而 CommandDispatcher 可以直接访问模型（栈）和视图（用户界面）。因此，CommandDispatcher 的构造函数接受一个抽象 UserInterface 类的引用，详细信息将在第 5 章中讨论。由于栈是作为单例实现的，因此不需要直接引用栈。按照我通常的惯例，CommandDispatcher 的实际实现被推迟到一个私有实现类 CommandDispatcherImpl。</p>
<p>上面的一种替代设计是使 CommandDispatcher 类直接成为一个观察者。如第 3 章所讨论的，我更喜欢使用中介事件观察者的设计。在第 5 章中，我将讨论 CommandIssuedObserver 代理类的设计和实现，以在用户界面和 CommandDispatcher 类之间进行事件代理。</p>
<p>4.5.2 实现细节</p>
<p>通常在这本书中，我不讨论 pimpl 类中包含的实现细节。但在这种情况下，CommandDispatcherImpl 类的实现尤其有启发性。CommandDispatcherImpl 类的主要功能是实现 executeCommand() 函数。此函数必须接收命令请求、解释这些请求、检索命令、请求执行命令以及优雅地处理未知命令。如果我们从自上而下地开始分解命令分发器模块，试图清晰地实现此功能将非常困难。然而，由于我们自下而上的方法，executeCommand() 的实现在很大程度上是将现有组件粘合在一起的练习。请考虑以下实现，其中 manager_ 对象是 CommandManager 类的一个实例，如 Listing 4-7 所示。</p>
<p>清单 4-7 executeCommand() 的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CommandDispatcher::CommandDispatcherImpl::<span class="built_in">executeCommand</span>(<span class="type">const</span> string&amp; command)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNum</span>(command, d))</span><br><span class="line">        manager_.<span class="built_in">executeCommand</span>(<span class="built_in">MakeCommandPtr</span>&lt;EnterNumber&gt;(d));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;undo&quot;</span>)</span><br><span class="line">        manager_.<span class="built_in">undo</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;redo&quot;</span>)</span><br><span class="line">        manager_.<span class="built_in">redo</span>();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> c = CommandRepository::<span class="built_in">Instance</span>().<span class="built_in">allocateCommand</span>(command);</span><br><span class="line">        <span class="keyword">if</span> (!c) &#123;</span><br><span class="line">            ostringstream oss;</span><br><span class="line">            oss &lt;&lt; <span class="string">&quot;Command &quot;</span> &lt;&lt; command &lt;&lt; <span class="string">&quot; is not a known command&quot;</span>;</span><br><span class="line">            ui_.<span class="built_in">postMessage</span>(oss.<span class="built_in">str</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                manager_.<span class="built_in">executeCommand</span>(std::<span class="built_in">move</span>(c));</span><br><span class="line">            &#125; <span class="built_in">catch</span> (Exception&amp; e) &#123;</span><br><span class="line">                ui_.<span class="built_in">postMessage</span>(e.<span class="built_in">what</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5-10 行处理特殊命令。特殊命令是指在命令存储库中未输入的任何命令。在上面的代码中，这包括输入新数字、撤消和重做。如果没有遇到特殊命令，则假定命令可以在命令存储库中找到。这个请求在第 13 行中进行。如果命令存储库返回 nullptr，则在 16-18 行处理错误。否则，命令由命令管理器执行。请注意，命令的执行在 try/catch 块中进行。通过这种方式，我们可以捕获由命令前置条件失败引起的错误，并在用户界面中报告这些错误。CommandManager 的实现确保未通过前置条件的命令不会进入撤销栈（按执行顺序进行）。</p>
<p>实际在 CommandDispatcher.cpp 中找到的 executeCommand() 的实现与上面的代码略有不同。首先，实际实现包括两个额外的特殊命令。这些额外特殊命令中的第一个是 help。help 命令可用于为当前在命令存储库中的所有命令打印简短的解释性消息。虽然实现通常将帮助信息打印到用户界面，但我只在 CLI 中公开了帮助命令（即，我的 GUI 的实现没有帮助按钮）。第二个特殊命令处理存储过程。存储过程在第 8 章中解释。此外，我将 try/catch 块放在其自己的函数中。这样做只是为了缩短 executeCommand() 函数并将命令解释的逻辑与命令执行分开。</p>
<h2 id="4-6-重新审视早期决策">4.6 重新审视早期决策</h2>
<p>此时，我们已经完成了计算器的两个主要模块：栈和命令调度器。让我们回顾一下我们最初的设计，讨论一个已经出现的重要细微偏差。</p>
<p>回顾第 2 章，我们最初的设计是通过在栈和命令调度器中引发事件来处理错误，这些事件将由用户界面处理。之所以做出这个决定，是为了保持一致性。虽然命令调度器具有对用户界面的引用，但栈没有。因此，我们决定让两个模块通过事件通知用户界面错误。然而，敏锐的读者会注意到，上面设计的命令调度器从未引发异常。相反，当错误发生时，它直接调用用户界面。那么我们是不是打破了有意设计到系统中的一致性呢？答案是否定的。实际上，在命令调度器的设计过程中，我们隐含地重新设计了系统的错误处理机制，使得栈和命令调度器都不再引发错误事件。让我们来看看原因。</p>
<p>正如我刚才所说，从实现来看，命令调度器显然没有引发错误事件，但栈事件发生了什么变化呢？我们没有更改 Stack 类的源代码，那么错误事件是如何被消除的呢？在最初的设计中，栈在发生错误时通过引发事件间接通知用户界面。两种可能的栈错误条件是弹出空栈和交换大小不足的栈的前两个元素。在设计命令时，我意识到，如果命令触发了这两种错误条件之一，用户界面会得到通知，但命令调度器不会（它不是栈事件的观察者）。在任何一种错误场景下，命令虽然执行失败，但都会被错误地放置在撤销栈上。然后我意识到，要么命令调度器必须捕获栈错误并阻止错误地放置到撤销栈上，要么命令不应被允许产生栈错误。正如最终设计所展示的，我选择了更简单、更干净的实现方式，即在执行命令之前使用前置条件来防止栈错误发生，从而隐式地抑制栈错误。</p>
<p>一个大问题是，为什么我没有修改描述原始设计的文本和相应的代码以反映错误报告的变化呢？简单地说，我希望读者看到错误确实会发生。设计是一个迭代过程，一个试图通过示例教授设计的书应该拥抱这个事实，而不是隐藏它。设计应该是有些流动性的（但也许具有较高的粘度）。在发现原始设计存在缺陷的证据后，尽早改变糟糕的设计决策要比坚持它更好。一个糟糕的设计被改变得越晚，修复它的成本就越高，而开发人员在尝试实现错误时会遇到更多的痛苦。至于改变代码本身，当我执行重构时，除非 Stack 类被设计为在另一个通过事件处理错误的程序中重用，否则我会从 Stack 类中移除多余的代码。毕竟，作为一个通用设计，通过引发事件来报告错误的机制并没有缺陷。事后来看，这种机制对于 pdCalc 来说并不合适。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">漫艺海</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/">http://example.com/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">漫艺海的blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Practical-C-Design-From-Programming-to-Architecture-1ed/">Practical C++ Design From Programming to Architecture 1ed</a></div><div class="post_share"><div class="social-share" data-image="/img/logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/6.The-Graphical-User-Interface/" title="6. 图形用户界面"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">6. 图形用户界面</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/1.Defining-the-Case-Study/" title="1. 定义案例研究"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">1. 定义案例研究</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/1.Defining-the-Case-Study/" title="1. 定义案例研究"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">1. 定义案例研究</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/" title="5. 命令行接口"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">5. 命令行接口</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/" title="3. 堆栈"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">3. 堆栈</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/2.Decomposition/" title="2. 分解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">2. 分解</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/" title="8. 新的需求"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">8. 新的需求</div></div></a></div><div><a href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/6.The-Graphical-User-Interface/" title="6. 图形用户界面"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">6. 图形用户界面</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">漫艺海</div><div class="author-info__description">漫艺海的个人站，主要涉及C++知识共享、实践教程等方面</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">4. 命令分发器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%91%BD%E4%BB%A4%E5%88%86%E5%8F%91%E5%99%A8%E7%9A%84%E5%88%86%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">4.1 命令分发器的分解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%91%BD%E4%BB%A4%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">4.2 命令类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">4.2.1 命令模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%85%B3%E4%BA%8E%E5%AE%9E%E7%8E%B0%E6%92%A4%E9%94%80-%E9%87%8D%E5%81%9A%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">4.2.2 关于实现撤销&#x2F;重做的更多内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%B0%86%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E4%BA%8E%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">4.2.3 将命令模式应用于计算器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-1-%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">4.2.3.1 命令接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-2-%E6%92%A4%E9%94%80%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">4.2.3.2 撤销策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-3-%E5%85%B7%E4%BD%93%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">4.2.3.3 具体命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-4-%E6%B7%B1%E5%BA%A6%E5%91%BD%E4%BB%A4%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">4.2.3.4 深度命令层次结构的替代方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%91%BD%E4%BB%A4%E4%BB%93%E5%BA%93"><span class="toc-number">1.3.</span> <span class="toc-text">4.3 命令仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-CommandRepository-%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">4.3.1 CommandRepository 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E6%B3%A8%E5%86%8C%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.2.</span> <span class="toc-text">4.3.2 注册核心命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%91%BD%E4%BB%A4%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">4.4 命令管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.4.1 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%AE%9E%E7%8E%B0%E6%92%A4%E6%B6%88%E5%92%8C%E9%87%8D%E5%81%9A"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.4.2 实现撤消和重做</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%91%BD%E4%BB%A4%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">4.5 命令分发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.5.1 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86%E6%97%A9%E6%9C%9F%E5%86%B3%E7%AD%96"><span class="toc-number">1.6.</span> <span class="toc-text">4.6 重新审视早期决策</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/27/CMake/cmake%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8qt%E7%9A%84windeployqt/" title="cmake配置自动调用qt的windeployqt">cmake配置自动调用qt的windeployqt</a><time datetime="2023-03-27T06:14:30.000Z" title="发表于 2023-03-27 14:14:30">2023-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/test/" title="9. 新的需求">9. 新的需求</a><time datetime="2023-03-26T12:29:12.427Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/" title="8. 新的需求">8. 新的需求</a><time datetime="2023-03-26T12:29:12.426Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/" title="7. 插件">7. 插件</a><time datetime="2023-03-26T12:29:12.426Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/" title="5. 命令行接口">5. 命令行接口</a><time datetime="2023-03-26T12:29:12.425Z" title="发表于 2023-03-26 20:29:12">2023-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 漫艺海</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">世上最幸运的事就是喜欢上一个人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>