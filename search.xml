<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cmake配置自动调用qt的windeployqt</title>
      <link href="/2023/03/27/CMake/cmake%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8qt%E7%9A%84windeployqt/"/>
      <url>/2023/03/27/CMake/cmake%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8qt%E7%9A%84windeployqt/</url>
      
        <content type="html"><![CDATA[<p>这cmake中直接配置windeploy.exe拷贝qt的动态库，可能会遇到有些模块在find_package配置了，而当前模块并没有使用的问题。那么用windeploy.exe拷贝的时候，会遗漏需要的qt库。</p><p>解决方法：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># qt_helper.cmake</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据find_package拷贝所需要的qt库（目标文件未依赖的）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据组件名获取库文件的目标</span></span><br><span class="line">function(get_qt_library_target component_name target_var)</span><br><span class="line">    if (TARGET Qt5::$&#123;component_name&#125;)</span><br><span class="line">        set($&#123;target_var&#125; Qt5::$&#123;component_name&#125; PARENT_SCOPE)</span><br><span class="line">    elseif (TARGET Qt6::$&#123;component_name&#125;)</span><br><span class="line">        set($&#123;target_var&#125; Qt6::$&#123;component_name&#125; PARENT_SCOPE)</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line">        message(FATAL_ERROR <span class="string">&quot;Unknown Qt component: $&#123;component_name&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line">endfunction()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目使用</span></span><br><span class="line">function(deployqt_qt_runtime arg_target)</span><br><span class="line">    get_target_property(qt_qmake_executable Qt5::qmake IMPORTED_LOCATION)</span><br><span class="line">    get_filename_component(qt_bin_directory <span class="string">&quot;$&#123;qt_qmake_executable&#125;&quot;</span> DIRECTORY)</span><br><span class="line"></span><br><span class="line">    find_program(qt_deployqt_executable NAMES windeployqt macdeployqt HINTS <span class="string">&quot;$&#123;qt_bin_directory&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    if (NOT EXISTS <span class="string">&quot;$&#123;qt_deployqt_executable&#125;&quot;</span>)</span><br><span class="line">        message(<span class="string">&quot;can not find the deployqt tools&quot;</span>)</span><br><span class="line">        return()</span><br><span class="line">    <span class="keyword">endif</span> ()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取组件参数列表</span></span><br><span class="line">    <span class="comment"># $&#123;ARGN&#125;是一个内置变量，表示传递给函数或宏的所有未命名参数</span></span><br><span class="line">    set(qt_components $&#123;ARGN&#125;)</span><br><span class="line"></span><br><span class="line">    if (WIN32)</span><br><span class="line">        add_custom_command(TARGET $&#123;arg_target&#125; POST_BUILD COMMAND</span><br><span class="line">            <span class="string">&quot;$&#123;qt_deployqt_executable&#125;&quot;</span></span><br><span class="line">            --libdir <span class="string">&quot;<span class="variable">$&lt;</span>TARGET_FILE_DIR:$&#123;arg_target&#125;&gt;&quot;</span></span><br><span class="line">            --plugindir <span class="string">&quot;<span class="variable">$&lt;</span>TARGET_FILE_DIR:$&#123;arg_target&#125;&gt;&quot;</span></span><br><span class="line">            --no-translations</span><br><span class="line">            --no-compiler-runtime</span><br><span class="line">            --no-system-d3d-compiler</span><br><span class="line">            --no-opengl-sw</span><br><span class="line">            --no-angle</span><br><span class="line">            --no-webkit2</span><br><span class="line">            <span class="variable">$&lt;</span><span class="variable">$&lt;</span>CONFIG:Debug&gt;:--pdb&gt;</span><br><span class="line">            <span class="string">&quot;<span class="variable">$&lt;</span>TARGET_FILE:$&#123;arg_target&#125;&gt;&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据find_package后面的component拷贝需要的动态库(防止遗漏)</span></span><br><span class="line">        foreach (component IN LISTS qt_components)</span><br><span class="line">            get_qt_library_target($&#123;component&#125; qt_component_target)</span><br><span class="line">            add_custom_command(TARGET $&#123;arg_target&#125; POST_BUILD COMMAND</span><br><span class="line">                $&#123;CMAKE_COMMAND&#125; -E copy_if_different</span><br><span class="line">                <span class="string">&quot;<span class="variable">$&lt;</span>TARGET_FILE:$&#123;qt_component_target&#125;&gt;&quot;</span></span><br><span class="line">                <span class="string">&quot;<span class="variable">$&lt;</span>TARGET_FILE_DIR:$&#123;arg_target&#125;&gt;&quot;</span></span><br><span class="line">                )</span><br><span class="line">        endforeach()</span><br><span class="line">    <span class="keyword">endif</span> ()</span><br><span class="line">endfunction()</span><br></pre></td></tr></table></figure><p>使用：</p><ol><li class="lvl-3"><p>项目根目录的CMakeLists.txt：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.21)</span><br><span class="line"></span><br><span class="line">project(XXXX)</span><br><span class="line">set(CMAKE_CXX_STANDARD 17)</span><br><span class="line"></span><br><span class="line">set(CMAKE_AUTOMOC ON)</span><br><span class="line">set(CMAKE_AUTORCC ON)</span><br><span class="line">set(CMAKE_AUTOUIC ON)</span><br><span class="line"></span><br><span class="line">set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line">set(Qt5_DIR /opt/homebrew/Cellar/qt@5/5.15.8_2/lib/cmake/Qt5)</span><br><span class="line"></span><br><span class="line">if(MSVC)</span><br><span class="line">    add_compile_options(&quot;/utf-8&quot;)</span><br><span class="line">    add_definitions(-DUNICODE -D_UNICODE)</span><br><span class="line">    add_compile_options(/MP)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line">set(qt_required_components Core Widgets Gui OpenGL Svg Xml Sql Network Charts)</span><br><span class="line">find_package(Qt5 COMPONENTS $&#123;qt_required_components&#125; LinguistTools REQUIRED)</span><br><span class="line"># 添加自己创建的cmake函数</span><br><span class="line">include(qt_helper.cmake)</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>子模块(需要add_library或者add_execute的地方)：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_library($&#123;PROJECT_NAME&#125; SHARED</span><br><span class="line">        XXXX.h</span><br><span class="line">        )</span><br><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125;</span><br><span class="line">        Qt5::Core Qt5::Widgets Qt5::Network</span><br><span class="line">        )        </span><br><span class="line"># 直接在文件最后加上这行就行</span><br><span class="line">deployqt_qt_runtime($&#123;PROJECT_NAME&#125; $&#123;qt_required_components&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. 新的需求</title>
      <link href="/2023/03/26/test/"/>
      <url>/2023/03/26/test/</url>
      
        <content type="html"><![CDATA[<p>未选：- [ ]</p><p>选中：- [x]</p><div class="tips"><p><strong>提示</strong><br>这是一个提示</p></div><div class="warning"><p><strong>注意</strong><br>这是一个警告</p></div><div class="danger"><p><strong>警告</strong><br>这是一个危险信号</p></div><div class="success"><p><strong>成功</strong><br>这是一个成功信号</p></div><p>markdown-it-emoji表情😃😃<br>markdown-it-footnote脚注参考文献[^1]参考文献1<br>markdown-it-ins下划线<ins>下划线</ins>下划线<br>markdown-it-mark突出显示<mark>标记</mark>标记<br>markdown-it-sub下标H<sub>2</sub>OH2O<br>markdown-it-sup上标X<sup>2</sup>X2<br>markdown-it-checkbox复选框未选：</p><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">blah blah blah.</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">pia pia pia.</label></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8. 新的需求</title>
      <link href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/"/>
      <url>/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/</url>
      
        <content type="html"><![CDATA[<h1>8. 新的需求</h1><p>这是一个美丽的星期一早晨，经过一个轻松的周末，你刚刚踏进了工作岗位。毕竟，你上周五刚刚完成了pdCalc项目，现在已经准备好发布了。然而，在你坐下来享用早晨的一杯咖啡之前，你的项目经理走进你的办公室，说：“我们还没有完成。客户要求添加一些新功能。”</p><p>上述情况在软件开发中非常普遍。虽然新功能可能不会在上线日期要求添加，但在你完成设计和实现的大部分工作之后，新功能几乎不可避免地会被要求添加。因此，在实际开发中，我们应尽量采取防御性开发策略，预测到可扩展性。我之所以说尽可能实用的防御性开发，而不是尽可能的防御性开发，是因为过于抽象的代码可能会对开发产生和过于具体的代码一样的负面影响。通常情况下，如果需要，重写不灵活的代码比维护高度灵活但无缘无故的代码更容易。在实践中，我们寻求在代码简单、可维护与可扩展性之间取得平衡。</p><p>在本章中，我们将探讨如何修改代码以实现超出原始需求设计的功能。本章对新功能的讨论范围从完整的设计和实现，到仅设计，再到仅为自我探索的建议。让我们从两个扩展开始，将它们从需求一直延伸到实现。</p><h2 id="8-1-完全设计的新功能">8.1 完全设计的新功能</h2><p>在本节中，我们将研究两个新功能：计算器的批处理操作和存储过程的执行。让我们从批处理操作开始。</p><h3 id="8-1-1-批处理操作">8.1.1 批处理操作</h3><p>对于那些不熟悉这个术语的人来说，任何程序的批处理操作只是在程序启动后，从开始到结束，不需要用户交互地执行程序。大多数桌面程序不是以批处理模式运行。然而，在许多编程领域，如科学计算，批处理操作仍然非常重要。也许对那些受雇于大公司的人来说，更有趣的是，你们的工资单可能是由一个以批处理模式运行的程序来生成的。</p><p>诚实地说，pdCalc的批处理操作除了可能用于测试之外，并不是一个非常有用的扩展。我之所以包含它，主要是因为它展示了一个设计良好的CLI可以如何轻松地扩展以添加批处理模式。</p><p>回顾第5章，pdCalc的CLI具有以下公共接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cli</span> : <span class="keyword">public</span> UserInterface</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">CliImpl</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cli</span>(istream&amp; in, ostream&amp; out);</span><br><span class="line">  ~<span class="built_in">Cli</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">bool</span> suppressStartupMessage = <span class="literal">false</span>, <span class="type">bool</span> echo = <span class="literal">false</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要使用CLI，该类使用cin和cout作为参数进行构造，然后使用空参数调用execute()：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cli cli&#123;cin, cout&#125;;</span><br><span class="line"><span class="comment">// setup other parts of the calculator</span></span><br><span class="line">cli.<span class="built_in">execute</span>();</span><br></pre></td></tr></table></figure><p>我们如何修改Cli类以启用批处理操作？令人惊讶的是，我们根本不需要修改类的代码！从设计上讲，CLI本质上是一个解析器，它只需从输入流中获取用空格分隔的字符输入，通过计算器处理数据，然后将字符输出生成到输出流。因为我们预先考虑到不要将这些输入和输出流硬编码为cin和cout，我们可以通过将输入和输出流转换为文件流来将CLI转换为批处理处理器，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifstream fin&#123;inputFile&#125;;</span><br><span class="line">ofstream fout&#123;outputFile&#125;;</span><br><span class="line">Cli cli&#123;fin, fout&#125;;</span><br><span class="line"><span class="comment">// setup other parts of the calculator</span></span><br><span class="line">cli.<span class="built_in">execute</span>(<span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>其中inputFile和outputFile是可以通过pdCalc命令行参数获取的文件名。回想一下，execute()函数的参数只是用来抑制启动横幅并将命令回显到输出。</p><p>是的，这确实就是它（但请参见main.cpp中的一些实现技巧）。我们的CLI最初是这样构建的，以便它可以通过简单地更改其构造函数参数来转换为批处理处理器。当然，你可以辩称，作为作者的我，有意以这种方式设计Cli类，因为我知道计算器会以这种方式进行扩展。然而，事实上，我只是将所有的CLI接口用流输入构造，而不是硬编码输入，因为这种设计使CLI在几乎没有额外认知负担的情况下变得更加灵活。</p><p>在离开本节之前，我想快速指出，事实上，pdCalc的CLI在操作系统的协助下已经具备了批处理模式。通过在命令行中重定向输入和输出，我们可以实现相同的结果：<br>my_prompt&gt; cat inputFile | pdCalc – cli &gt; outputFile</p><p>对于Windows，只需将Linux的cat命令替换为Windows的type命令。</p><h3 id="8-1-2-存储过程">8.1.2 存储过程</h3><p>承认吧，将批处理模式添加到pdCalc是一个有些做作的例子。新增的功能并不是特别有用，而代码更改非常简单。在本节中，我们将研究一个更有趣的功能扩展：存储过程。</p><p>什么是存储过程？在pdCalc中，存储过程是一组存储在当前栈上操作的可重复操作序列。存储过程提供了一种扩展计算器功能的技术，通过从现有计算器原语创建用户定义的函数。你可以将执行存储过程看作是运行一个非常简单的计算器程序。要理解这个概念，最简单的方法是考虑一个例子。</p><p>假设你需要经常计算三角形的斜边。对于图8-1中所示的直角三角形，我们可以使用勾股定理计算斜边c的长度：$$ c=\sqrt{a<sup>2+{b}</sup>2} $$。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/A454125_1_En_8_Fig1_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">          图8-1 直角三角形  </div></center><p>假设我们有一个三角形，边长a = 4，b = 3，这些值输入到pdCalc的堆栈中。在CLI中，你会看到以下内容：</p><p>堆栈顶部的2个元素（大小 = 2）：</p><p>2:      3</p><p>1:      4</p><p>为了计算这个三角形的c值，我们将实现以下指令序列：dup * swap dup * + 2 root。按下回车后，最终结果将是：</p><p>堆栈顶部元素（大小 = 1）：</p><p>1:      5</p><p>如果将命令一个接一个地输入，每次按下回车时，我们都会看到中间的结果堆栈。如果我们将所有命令输入在一行，然后按下回车，pdCalc将在显示最终结果之前显示每个中间堆栈。当然，请注意，这个命令序列并不是唯一的。例如，使用命令序列 2 pow swap 2 pow + 2 root 也可以得到相同的结果。</p><p>如果你和我一样，在pdCalc中反复计算斜边时，你可能会在第一次手动计算后想要自动化该操作。这正是存储过程允许的。自动化不仅节省时间，而且因为封装了许多连续命令的存储过程可以编写、测试和随后重用，所以也更不容易出错。只要操作可以从pdCalc原语（包括插件函数）组合而成，存储过程就可以在不需要编写任何C++代码的情况下扩展计算器的功能，计算简单的公式。现在我们只需要设计和实现这个新功能。</p><h4 id="8-1-2-1-用户界面">8.1.2.1 用户界面</h4><p>pdCalc既有GUI，也有CLI，所以添加任何面向用户的功能都需要对这两个用户界面组件进行一定的修改。对于存储过程，用户界面的修改非常小。首先，存储过程只是一个包含pdCalc指令有序序列的文本文件。因此，用户可以使用任何纯文本编辑器创建存储过程。因此，除非你想提供一个带有语法高亮的存储过程文本编辑器，否则存储过程的用户界面就是简化为从CLI和GUI执行它们。</p><p>首先，让我们讨论在CLI中整合存储过程。如前所述，存储过程只是文件系统中的文本文件。回顾一下，CLI是通过对空格分隔的输入进行标记化，然后将每个标记单独传递给命令调度器来处理事件。因此，访问存储过程的一个简单方法就是将存储过程文件名传递给CLI。然后，这个文件名将像任何其他命令或数字一样进行标记化，并传递给命令调度器进行处理。为确保命令调度器将文件名解释为存储过程而不是命令，我们只需在文件名前加上符号proc：并更改命令调度器的解析器。例如，对于名为hypotenuse.psp的存储过程，我们将向CLI发出命令proc:hypotenuse.psp。我采用文件扩展名psp作为pdCalc存储过程的缩写。当然，文件本身是一个包含用于计算直角三角形斜边的命令序列的普通ASCII文本文件，你可以使用.txt扩展名，如果你喜欢的话。</p><p>回想一下，GUI被设计成像CLI一样将命令传递给命令调度器。因此，要使用存储过程，我们添加一个按钮，打开一个对话框，浏览文件系统以找到存储过程。一旦选择了存储过程，我们在文件名前加上proc：并引发CommandEntered事件。显然，您可以根据需要制作您的存储过程选择对话框。我选择了一种简单的设计，允许将文件名键入可编辑的组合框中。为了方便使用，组合框预先填充了当前目录中所有具有.psp扩展名的文件。</p><h4 id="8-1-2-2-命令调度器的更改">8.1.2.2 命令调度器的更改</h4><p>清单8-1是CommandDispatcher的executeCommand()函数的简略清单，包括解析存储过程所需的逻辑。省略的代码部分出现在第4.5.2节。</p><p>清单8-1 CommandDispatcher的executeCommand()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CommandDispatcher::CommandDispatcherImpl::<span class="built_in">executeCommand</span>(<span class="type">const</span> string&amp; command)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// handle numbers, undo, redo, help in nested if</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(command.<span class="built_in">size</span>() &gt; <span class="number">6</span> &amp;&amp; command.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>) == <span class="string">&quot;proc:&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> filename = command.<span class="built_in">substr</span>(<span class="number">5</span>, command.<span class="built_in">size</span>() - <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">handleCommand</span>( <span class="built_in">MakeCommandPtr</span>&lt;StoredProcedure&gt;(ui_, filename) );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// else statement to handle Commands from CommandRepository</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看到实现只是从字符串命令参数中剥离proc：以创建存储过程文件名，创建一个新的StoredProcedure Command子类，并执行这个类。目前，我们将假设使StoredProcedure类成为Command类的子类是最佳设计。我将在下面的章节中讨论为什么这种策略是首选，并检查其实现。然而，在我们到达那里之前，让我们讨论一下这个新的MakeCommandPtr()函数的重载。</p><p>在第7.2.1节中，我们首次看到了由以下实现给出的MakeCommandPtr版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">CommandDeleter</span><span class="params">(Command* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p-&gt;<span class="built_in">deallocate</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> CommandPtr = std::unique_ptr&lt;Command, <span class="keyword">decltype</span>(&amp;CommandDeleter)&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">MakeCommandPtr</span><span class="params">(Command* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> CommandPtr&#123;p, &amp;CommandDeleter&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数是一个辅助函数，用于从原始Command指针创建CommandPtrs。这种形式的函数用于从克隆现有命令创建CommandPtr（例如，如CommandRepository::allocateCommand()中）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">MakeCommandPtr</span>( command-&gt;<span class="built_in">clone</span>() );</span><br></pre></td></tr></table></figure><p>然而，在CommandDispatcherImpl::executeCommand()中，我们看到了一个完全不同的用法，即构造一个派生自Command的类的实例。当然，我们可以用现有的MakeCommandPtr原型满足这个用例。例如，我们可以创建一个StoredProcedure，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> c = <span class="built_in">MakeCommandPtr</span>(<span class="keyword">new</span> StoredProcedure&#123;ui, filename&#125;);</span><br></pre></td></tr></table></figure><p>然而，只要有可能，最好不要在高级代码中使用裸露的new。因此，我们寻求实现一个可以为我们执行此构造的重载辅助函数。它的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">MakeCommandPtr</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> CommandPtr&#123;<span class="keyword">new</span> T&#123;std::forward&lt;Args&gt;(args)...&#125;, &amp;CommandDeleter&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C<ins>11之前，没有简单而高效的技术可以使用可变数量的构造函数参数构造通用类型，这是创建可能从Command类派生的任何一个类所必需的，每个类都有不同的构造函数参数。然而，现代C</ins>使用可变模板和完美转发提供了一个优雅的解决方案。这个构造是下面边栏的主题。</p><hr><p>现代C++设计注意事项：可变模板和完美转发</p><p>可变模板和完美转发分别解决了C<ins>中的不同问题。可变模板允许使用未知数量的类型参数进行类型安全的通用函数调用。完美转发允许在模板函数内部将参数正确地转发给底层函数。可以在您最喜欢的C</ins>11参考文本中（例如[23]）学习这些技术的机制。此侧边栏展示了一种类型安全的、通用的设计技术，用于构造需要不同数量构造函数参数的具体对象。这种技术是通过可变模板和完美转发的组合实现的。由于缺乏命名创意，我将这种模式命名为通用完美转发构造器（GPFC）。让我们首先介绍GPFC解决的基本问题。</p><p>让我们考虑每个作者最喜欢的过于简化的面向对象编程示例，形状层次结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Circle</span>(<span class="type">double</span> r) : r_&#123;r&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.14159</span> * r_ * r_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> r_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Rectangle</span>(<span class="type">double</span> l, <span class="type">double</span> w) : l_&#123;l&#125;, w_&#123;w&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> l_ * w_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> l_, w_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在C++中，可替代性（实现为虚拟分派）解决了需要通过基类指针调用派生类型的特定实现的问题，使用基类保证的接口。在形状示例中，可替代性意味着能够按如下方式计算面积：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(<span class="type">const</span> Shape&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s.<span class="built_in">area</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于任何派生自Shape的类。虚拟函数的确切接口是完全规定的，包括任何函数参数的数量和类型（即使在这个示例中area()函数的空实例中）。然而，问题在于对象构造永远无法以这种方式“虚拟化”，即使它可以，它也无法工作，因为构造对象所需的信息（其参数）很频繁地从一个派生类到另一个派生类都是不同的。</p><p>进入通用完美转发构造器模式。在这种模式下，我们使用可变模板提供一个类型安全的接口，该接口可以接受任意数量的不同类型的构造函数参数。第一个模板参数始终是我们要构造的类型。然后，完美转发用于确保参数以正确的类型传递给构造函数。为什么完美转发在这种情况下是必要的，源于模板中类型的推导方式，这已超出了本讨论的范围（有关详细信息，请参见[19]）。对于我们的形状示例，应用GPFC模式得到以下实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">MakeShape</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;T&gt;(forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码说明了如何使用MakeShape()函数创建具有不同构造函数参数数量的不同类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> c = <span class="built_in">MakeShape</span>&lt;Circle&gt;(<span class="number">4.0</span>);</span><br><span class="line"><span class="keyword">auto</span> r = <span class="built_in">MakeShape</span>&lt;Rectangle&gt;(<span class="number">3.0</span>, <span class="number">5.0</span>);</span><br></pre></td></tr></table></figure><p>请注意，GPFC模式也适用于创建在继承层次结构中彼此不相关的类。事实上，标准库中的make_unique()函数使用GPFC模式以高效、通用的方式创建unique_ptrs，而不需要使用裸new。虽然严格来说它们是不同的，但我喜欢将GPFC模式视为工厂方法的通用类比。</p><hr><h4 id="8-1-2-3-设计StoredProcedure类">8.1.2.3 设计StoredProcedure类</h4><p>现在我们回到设计StoredProcedure类的棘手问题。我们首先要问的问题是我们是否需要一个类。我们已经有了一个解析单个命令、执行它们并将它们放在撤消/重做堆栈上的设计。也许正确的答案是将存储过程视为与批处理输入类似的处理方式。也就是说，在交互式会话（GUI或CLI）期间，通过读取存储过程文件、解析它并批量执行命令（如我们在CLI中带有多个命令的长行中所做的那样）处理存储过程，而不引入新的StoredProcedure类。</p><p>在考虑以下非常简单的示例之后，上述设计几乎可以立即被驳回。假设您实现了一个计算三角形面积的存储过程。存储过程的输入将是堆栈上的三角形底边和高度。triangleArea.psp如下所示：<br>*<br>0.5<br>*</p><p>如果我们没有StoredProcedure类，那么triangleArea.psp中的每个命令将被执行并按顺序输入到撤消/重做堆栈中。对于I/O堆栈上的值4和5，存储过程的正向执行将产生正确的结果10和一个撤消堆栈，如图8-2所示。基于此撤消堆栈，如果用户尝试撤消，而不是撤消三角形面积存储过程，用户只会撤消堆栈顶部的最后一个操作，即最后的乘法。I/O堆栈将读取<br>4<br>5<br>0.5<br>（撤消堆栈将在5和0.5之间有一个*）而不是<br>4<br>5</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/A454125_1_En_8_Fig2_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图8-2 没有StoredProcedure类的撤消堆栈  </div></center><p>要完全撤消一个存储过程，用户需要按n次撤消，其中n等于存储过程中的命令数量。重做操作也存在相同的不足。在我看来，撤消存储过程的预期行为应该是撤消整个过程，并将I/O堆栈保持在执行存储过程之前的状态。因此，不使用StoredProcedure类的处理存储过程的设计无法正确实现撤消和重做操作，因此必须被抛弃。</p><h3 id="8-1-2-4-组合模式">8.1.2.4 组合模式</h3><p>本质上，为了解决存储过程中的撤销/重做问题，我们需要一个特殊的命令来封装多个命令，但它的行为就像一个单独的命令。幸运的是，组合模式解决了这个难题。根据Gamma等人[6]的说法，组合模式“让客户端可以统一对待单个对象和对象的组合”。通常，组合模式是指树形数据结构。我更喜欢一个较宽松的定义，其中模式可以应用于允许统一处理复合对象的任何数据结构。</p><p>图8-3以其通用形式说明了组合模式。Component类是一个抽象类，需要执行某些操作。这个操作可以由Leaf节点单独执行，也可以由称为Composite的一组Components执行。客户端通过Component接口以多态的方式与组件层次结构中的对象进行交互。从客户端的角度来看，Leaf节点和Composite节点都能无差别地处理doSomething()请求。通常，Composites通过简单地调用它所持有的Components（Leafs或嵌套Composites）的doSomething()命令来实现doSomething()。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/A454125_1_En_8_Fig3_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图8-3 组合模式的一般形式  </div></center><p>在我们的具体情况下，Command类扮演Component的角色，诸如Add或Sine这样的具体命令扮演Leaf节点的角色，StoredProcedure类是复合体。doSomething()命令被替换为executeImpl()和undoImpl()这一对纯虚函数。我怀疑以这种方式将命令和组合模式结合在一起相当常见。</p><p>此前，我们了解到为了正确实现存储过程的撤销/重做策略，需要一个类设计。如上所述，应用组合模式激发了将StoredProcedure类子类化为Command类。</p><p>现在让我们设计一个StoredProcedure类，并将其作为组合模式的具体应用来检查其实现。</p><h4 id="8-1-2-5-第一次尝试">8.1.2.5 第一次尝试</h4><p>实现组合模式的常见方法是通过递归。Composite类包含一组Component，通常是通过一个简单的向量或者更复杂的结构，例如二叉树中的节点。Composite的doSomething()函数只需遍历这个集合，为集合中的每个Component调用doSomething()。Leaf节点的doSomething()函数实际上会执行某些操作并终止递归。尽管不是必需的，但Component类中的doSomething()函数通常是纯虚函数。</p><p>让我们考虑上述方法，用于实现pdCalc中StoredProcedure的组合模式。我们已经确定pdCalc的Command类是Component，而具体的命令类（如Add）是Leaf类。因此，我们只需要考虑StoredProcedure类本身的实现。注意，由于当前Component和Leaf类的实现可以直接使用，组合模式可以简单地应用于扩展现有代码库的功能。</p><p>考虑以下StoredProcedure类的框架设计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StoredProcedure</span> : <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">  vector&lt;unique_ptr&lt;CommandPtr&gt;&gt; components_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>executeImpl()命令将按如下方式实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoredProcedure::executeImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : components_)</span><br><span class="line">    i-&gt;<span class="built_in">execute</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>undoImpl()将以类似的方式实现，但是要在component_集合上进行反向迭代。</p><p>上述设计是否解决了之前在没有StoredProcedure类的情况下将存储过程命令直接输入到撤销/重做堆栈时遇到的撤销/重做问题？考虑我们之前检查过的triangleArea.psp示例中的撤销堆栈，如图8-4所示。存储过程在撤销堆栈中显示为一个对象，而不是表示其组成命令的单个对象。因此，当用户发出撤销命令时，CommandManager将通过调用存储过程的undoImpl()函数将存储过程作为单个命令进行撤销。这个存储过程的undoImpl()函数反过来通过对其Command容器的迭代撤销单个命令。这种行为正是我们所期望的，这种组合模式的应用确实解决了手头的问题。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/A454125_1_En_8_Fig4_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图8-4 使用StoredProcedure类的撤销堆栈  </div></center><p>为了完成StoredProcedure类的实现，我们需要解析存储过程文件的字符串命令（带有错误检查），并用它们填充StoredProcedure的components_向量。这个操作可以在StoredProcedure的构造函数中编写，实现将是有效的和完整的。现在我们将拥有一个StoredProcedure类，可以将字符串命令转换为Commands，将它们存储在容器中，并根据需要执行和撤销这些存储的Commands。换句话说，我们将重写命令调度器！相反，让我们考虑一种实现StoredProcedure类的替代设计，通过重用CommandDispatcher类。</p><h4 id="8-1-2-6-StoredProcedure类的最终设计">8.1.2.6 StoredProcedure类的最终设计</h4><p>这个设计的目标是重用CommandDispatcher类。放宽此约束并修改CommandDispatcher的代码可以稍微清理实现，但无论哪种方式，设计的本质是相同的。考虑以下修改后的StoredProcedure类的框架设计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StoredProcedure</span> : <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">  std::unique_ptr&lt;Tokenizer&gt; tokenizer_;</span><br><span class="line">  std::unique_ptr&lt;CommandDispatcher&gt; ce_;</span><br><span class="line">  <span class="type">bool</span> first_ = first;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目前的设计几乎与我们之前的设计相同，只是components_vector被CommandDispatcher替换，而且需要明确标记器。幸运的是，我们在第5章中编写的标记器是可重用的！</p><p>现在我们准备查看executeImpl()和undoImpl()的完整实现。请注意，虽然下面的实现没有使用上面看到的模式的规范版本，但这个StoredProcedure类的实现仍然只是组合模式的一个应用。首先，让我们看一下executeImpl()：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoredProcedure::executeImpl</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(first_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : *tokenizer_)</span><br><span class="line">    &#123;</span><br><span class="line">      ce_-&gt;<span class="built_in">commandEntered</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    first_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; tokenizer_-&gt;<span class="built_in">nTokens</span>(); ++i)</span><br><span class="line">      ce_-&gt;<span class="built_in">commandEntered</span>(<span class="string">&quot;redo&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executeImpl()第一次被调用时，必须从标记器中提取标记并由StoredProcedure自己的CommandDispatcher执行。随后对executeImpl()的调用只需请求StoredProcedure的CommandDispatcher重做存储过程命令的前向执行。请记住，StoredProcedure的executeImpl()函数本身将由pdCalc的CommandDispatcher调用；因此，我们的设计需要嵌套的CommandDispatchers。图8-5展示了这个三角形区域存储过程示例的设计，其中CD表示CommandDispatcher。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/A454125_1_En_8_Fig5_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图8-5 使用嵌套的CommandDispatchers的撤销堆栈  </div></center><p>StoredProcedure的undoImpl()的实现非常简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoredProcedure::undoImpl</span> <span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; tokenizer_-&gt;<span class="built_in">nTokens</span>(); ++i)</span><br><span class="line">    ce_-&gt;<span class="built_in">commandEntered</span>(<span class="string">&quot;undo&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>撤销是通过请求底层CommandDispatcher撤销存储过程中的命令数量来实现的。</p><p>在结束对最终StoredProcedure类的讨论之前，我们应该考虑在StoredProcedure类中对命令进行标记化。StoredProcedure的标记化过程涉及两个步骤。首先要打开并读取存储过程文件，然后对文本流进行实际的标记化。这个过程只需要在StoredProcedure实例化时的初始化阶段执行一次。因此，标记化的自然位置是在StoredProcedure的构造函数中。然而，在StoredProcedure的构造函数中进行标记化会导致与pdCalc命令错误处理程序的不一致。具体来说，pdCalc假设命令可以构造，但不一定会执行，而不会失败。如果一个命令无法执行，预期是通过检查命令的前提条件来处理这个错误。标记化可以失败吗？当然可以。例如，如果无法打开存储过程文件，标记化将失败。因此，为了保持错误处理的一致性，我们在StoredProcedure的checkPreconditionsImpl()函数中实现标记化，该函数将在pdCalc的CommandDispatcher首次尝试执行存储过程时调用。由于标记化需要执行一次，我们只在checkPreconditionsImpl()函数的第一次执行中执行此操作。完整的实现可以在StoredProcedure.cpp文件中找到。</p><h2 id="8-2-更有用的计算器设计">8.2 更有用的计算器设计</h2><p>到目前为止，关于pdCalc的所有讨论都集中在设计和实现一个可从GitHub下载的完整代码。然而，本章剩余部分标志着这种风格的转变。从现在开始，我们将仅讨论扩展的想法以及如何修改pdCalc以适应这些新功能的建议。这里不仅没有提供工作代码，而且在编写这些部分之前也没有创建工作代码。因此，我即将讨论的设计尚未经过测试，冒险的读者选择完成这些扩展可能会发现待讨论的想法是次优的，或者，敢于说，错误的。欢迎来到从空白设计功能的野蛮西部！将需要进行实验和迭代。</p><h3 id="8-2-1-复数">8.2.1 复数</h3><p>计算器的原始设计规范要求使用双精度数，并且我们专门设计和实现了计算器以处理双精度数。然而，需求会发生变化。假设您的同事，一位电气工程师，顺便来到您的办公室，爱上了您的计算器，但需要能处理复数（虚数）的计算器。这是一个合理的请求，因此让我们看看如何重构我们的计算器以满足这个新功能。</p><p>向pdCalc添加复数需要对其进行四个主要修改：内部使用复数表示而不是将数字表示为双精度，更改输入和输出（以及相应的解析）以适应复数，修改pdCalc的堆栈以存储复数而不是双精度数，以及修改命令以对复数执行计算而不是实值输入。第一个更改，找到复数的C++表示非常简单；我们将使用std::complex<double>。只有实部的数字将被存储为具有虚部设置为0的complex<double>。其他三个更改则不那么简单。现在让我们更深入地看一些能够适应这些更改的设计选项。</double></double></p><h4 id="8-2-1-1-修改输入和输出">8.2.1.1 修改输入和输出</h4><p>在所有必需的更改中，修改I/O例程实际上是最简单的。首先要解决的问题是复数将如何解释和表示。例如，我们是否希望复数c表示为c = re + im * i（也许虚数应该是j，因为特性请求来自电气工程师）。也许我们更喜欢使用c = (re, im)或使用尖括号或方括号的变体。这个问题没有正确的答案。虽然有些选择可能比其他选择更容易实现，但由于这个选择只是一个约定，在实践中，我们会将解决方案推迟给客户。对于我们的案例研究，我们将简单地采用约定c = (re, im)。</p><p>我将仅讨论修改命令行版本的I/O。一旦为CLI提供处理复数的基础设施，适应GUI应该相当简单。我们遇到的第一个问题是Tokenizer类。这个类的原始设计仅通过在空格上拆分输入进行标记化。然而，对于复数，这种方案是不够的。例如，根据逗号后是否插入空格，复数的标记化方式会有所不同。</p><p>在某个时候，输入变得足够复杂，您需要使用一种语言语法并将简单的输入例程迁移到一个“真正”的扫描器和解析器（可能使用像lex和yacc这样的库）。有些人可能会说，通过添加复数，我们已经达到了这种复杂程度。然而，我认为，如果我们修改tokenize()例程以扫描(标记并为包括开括号和闭括号之间的任何内容创建一个“数字”标记，我们可能可以使用现有的简单输入标记器。显然，我们需要进行一些基本的错误检查以确保正确的格式。另一种选择是根据正则表达式匹配对输入流进行分解。这本质上就是lex的工作方式，我会在从头编写复杂的扫描器之前调查使用lex或类似的库。</p><p>我们遇到的下一个输入问题是在CommandDispatcherImpl的executeCommand()函数中解析数字。目前，一个字符串参数（标记）被传递给这个函数，并解析字符串以确定它是一个数字还是一个命令。通过检查，我们可以看到，如果我们修改isNum()来识别并返回复数而不是浮点数，那么executeCommand()将适用于复数。最后，EnterNumber命令需要更新，以接受和存储一个complex<double>。</double></p><p>这样就解决了修改输入例程的问题，但我们如何修改输出例程呢？回想一下，Cli类是Stack的stackChanged()事件的（间接）观察者。每当Stack引发此事件时，Cli的stackChanged()函数将被调用以将当前堆栈输出到命令行。让我们看看Cli::stackChanged()是如何实现的。实际上，CLI回调堆栈使用以下函数调用填充顶部的nElements容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> v = Stack::<span class="built_in">Instance</span>().<span class="built_in">getElements</span>(nElements);</span><br></pre></td></tr></table></figure><p>然后创建一个ostringstream，oss，并首先使用一些堆栈元数据填充它，然后使用以下代码填充堆栈元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> j&#123; v.<span class="built_in">size</span>() &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = v.<span class="built_in">rbegin</span>(); i != v.<span class="built_in">rend</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  oss &lt;&lt; j &lt;&lt; <span class="string">&quot;:\t&quot;</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  -- j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，oss的底层字符串被发布到CLI。令人惊讶的是，一旦Stack的getElements()函数修改为返回vector&lt;complex<double>&gt;，仅通过重新编译，Cli的stackChanged()函数将按预期工作。由于我们使用了auto，以及因为operator&lt;&lt;()已经为std::complex重载，只要我们对复数的标准格式满意，我们的输出修改就在不做任何事情的情况下完成了！这就是精心设计和实现的代码的美丽之处。</double></p><h4 id="8-2-1-2-修改Stack">8.2.1.2 修改Stack</h4><p>在第3章中，我们最初设计了计算器的堆栈，只对双精度变量进行操作。显然，这种限制意味着现在必须重构Stack类以处理复数。当时，我们质疑了为堆栈硬编码目标数据类型的逻辑，并建议不要设计通用Stack类。我建议通常不要设计通用接口，直到明确建立第一个重用案例。</p><p>设计好的通用接口通常比设计特定类型更难，而且，根据我的个人经验，我发现代码的意外重用很少实现。然而，对于我们的Stack类，重用这个数据结构的时机已经到来，现在是将Stack接口转换为通用接口而不是仅将类重构为为复数硬编码的时机。</p><p>使Stack类通用几乎和您预期的一样简单。第一步是使接口本身通用，用我们的通用类型T替换double的显式使用。接口变成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> : <span class="keyword">private</span> Publisher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Stack&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T, <span class="type">bool</span> suppressChangeEvent = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">pop</span><span class="params">(<span class="type">bool</span> suppressChangeEvent = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swapTop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;T&gt; <span class="title">getElements</span><span class="params">(<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getElements</span><span class="params">(<span class="type">size_t</span> n, std::vector&lt;T&gt;&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">using</span> Publisher::attach;</span><br><span class="line">  <span class="keyword">using</span> Publisher::detach;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用通用接口时，不再需要使用pimpl模式。回想一下，使用pimpl模式使我们能够通过间接引用一个仅在源文件中定义的实现类指针来隐藏类的实现。然而，为了使Stack通用，它的实现也必须是通用的（因为它必须存储任何类型的T，而不是已知类型的double）。这意味着StackImpl也需要进行模板化。C++规则要求当Stack<T>实例化为特定的T时，StackImpl<T>的定义必须是可见的，因此要求StackImpl<T>的定义在Stack<T>之前出现在头文件中。一旦我们失去了使StackImpl<T>私有的能力，我们就没有理由使用pimpl模式，而是直接在Stack<T>类中定义堆栈的实现。</T></T></T></T></T></T></p><p>通常，所需的实现更改非常简单。double的用法替换为T，实现本身移动到头文件。在pdCalc中使用Stack类的代码显然必须重构为使用通用而不是非模板接口。</p><p>需要修改的接口的最后一部分是在第7章中添加的五个全局extern &quot;C&quot;辅助函数，用于将堆栈命令导出到插件。因为这些函数必须具有C链接，所以我们不能将它们作为模板，也不能在双精度浮点数的位置返回C++复数类型。第一个问题并不像乍一看那么严重。虽然我们的目标是使Stack类通用和可重用，但堆栈的插件接口不需要通用。对于任何特定版本的pdCalc，无论是操作实数还是操作复数，系统中只会存在一个特定的Stack<T>实例，并且这个实例将具有特定的T实现。因此，pdCalc堆栈的C链接接口只需反映计算器中使用的T的选择。也就是说，容器被设计为通用和可重用，但插件接口不需要这种灵活性，因为一旦选择了计算器的数据格式，就不会重用它。</T></p><p>将复数<double>表示法替换为堆栈的C链接接口非常简单。我们有几个选项。首先，我们可以用两个双精度浮点数的序列替换每个双精度浮点数，一个表示实部，一个表示虚部。当然，由于一个函数不能返回两个双精度浮点数，我们必须修改返回堆栈值的函数，将指针参数用在它们的参数列表中来“返回”复数值。第二个选项是通过数组返回复数。考虑到我在可能的情况下消除接口中原始指针的偏好，我认为这个选项并不理想。最后一个解决方案，也是我首选的选择，是简单地定义一个结构，如下所示：</double></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> re;</span><br><span class="line">  <span class="type">double</span> im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用于补充接口函数，用Complex替换当前使用的double。虽然这个新的Complex结构确实重复了标准复数类的存储，但我们不能在纯C接口中使用标准复数类。</p><h4 id="8-2-1-3-修改命令">8.2.1.3 修改命令</h4><p>修改命令以适应复数实际上非常简单，因为C<ins>库为我们的计算器所需的所有数学运算提供了重载。在将Stack替换为Stack&lt;complex<double>&gt;（希望我们已经在某个地方对其进行了别名处理）和在BinaryCommand和UnaryCommand中将complex<double>替换为double的语法更改之外，大多数命令保持不变。例如，清除实数堆栈与清除复数堆栈是相同的。由于操作符重载，添加两个复数与添加两个实数是相同的。当然，我们可能想要添加其他命令，例如复共轭，但即使这个功能也是由C</double></double></ins>复数类提供的。如果您创建的命令使用了复数类本身不支持的算法，那么在修改命令以支持复数时，您可能会遇到比编程问题更多的数学问题。</p><h3 id="8-2-2-变量">8.2.2 变量</h3><p>在本章前面，我们实现了存储过程作为存储简单指令序列的方法。虽然存储过程对于只使用每个输入一次的简单操作（例如勾股定理）很好用，但在试图实现使用每个输入多次的更复杂公式（例如二次公式）时，你会很快遇到问题。要克服这个困难，你需要实现将参数存储在命名变量中的功能。</p><p>在pdCalc中实现变量将需要对现有组件进行几处修改，包括添加一个显著的新组件——符号表。为了简化示例代码，我已经恢复使用pdCalc的实数表示。然而，使用复数不会增加额外的设计复杂性。现在让我们探讨一些实现变量的可能设计思路。</p><h4 id="8-2-2-1-输入和新命令">8.2.2.1 输入和新命令</h4><p>显然，使用变量需要提供符号名称的一些手段。目前，我们的计算器只接受数字和命令作为输入。输入任何在CommandRepository中找不到的字符串都会导致错误。然而，请记住，这个错误是在CommandDispatcher中生成的，而不是在分词器中。因此，我们需要修改CommandDispatcher，让其不拒绝字符串，而是将它们放到堆栈中。目前，我们假设堆栈除了数字之外还可以接受字符串。在即将到来的部分中，我将讨论对Stack类的必要修改。再次强调，我将我们的讨论限制在命令行界面。图形用户界面带来的唯一额外复杂性是提供输入字符字符串以及数字的机制（可能是伴随虚拟数字键盘的虚拟键盘）。</p><p>从技术上讲，我们可以允许任何字符串表示变量。然而，我们可能更好地通过限制允许的语法到某个字符串子集来实现，可能用一个符号来区分变量名和命令。由于这个选择只是约定，您可以自由选择适合您或您的用户口味的规则。就我个人而言，我可能会选择诸如变量名必须以字母开头，可以包含任何字母、数字和可能的几个特殊符号（如下划线）的组合。为了消除变量名和命令之间的混淆，我会用单引号或双引号将变量括起来。</p><p>现在我们已经为变量建立了语法，我们仍然需要一个从堆栈中取出一个数字并将其存储到变量中的机制。完成此任务的最简单方法是提供一个新的二进制命令“store”，它从堆栈中移除一个数字和一个字符串，并在符号表中创建一个将此变量名链接到此数字的条目。例如，考虑堆栈：<br>4.5<br>2.9<br>“x”</p><p>执行存储命令后，符号表中应该有一个x → 2.9的条目，剩余堆栈为4.5。在计算过程中，变量应隐式地转换为数字，但在堆栈上显示为名称。我们还应该提供一个显式命令“eval”，将符号名称转换为数字。例如，给定堆栈：<br>“x”<br>执行eval命令后，堆栈应变为2.9。</p><p>这样的命令应该有一个相当明显的实现：用符号表中的值替换堆栈顶部的变量。显然，请求评估不在符号表中的变量应导致错误。评估数字可以导致错误，或者更好地说，只返回数字。您可能会想到许多处理变量的花哨命令（例如，列出符号表）。然而，存储和eval命令组成了使用变量所需的最小命令集。</p><h4 id="8-2-2-2-数字表示和堆栈">8.2.2.2 数字表示和堆栈</h4><p>到目前为止，我们的堆栈只需要表示一个唯一的类型，要么是实数，要么是复数。然而，由于变量和数字都可以存储在堆栈上，我们需要堆栈同时存储两种类型的能力。我们立即排除了一个可以同时处理两种不同类型的堆栈的概念，因为这会很快导致混乱。相反，我们寻求一个能够通过单一接口处理数字和变量类型的统一表示。自然地，我们转向一个层次结构。</p><p>考虑图8-6中的类图所表达的设计。这个层次结构使得变量和数字都可以作为值互换使用。这种多态设计解决了我们已经遇到的三个问题。首先，变量和数字都可以在Stack&lt;Value*&gt;（可能使用更合适的智能指针存储方案）中统一存储。其次，当诸如Add或Sine之类的命令需要一个数字来执行操作时，它们可以从堆栈中弹出值，并通过虚拟evaluate()函数请求双精度数。显然，一个数字直接存储它表示的双精度数，而一个变量存储变量的名称，可以通过在变量符号表中查找将其转换为数值。最后，Value的子类可以返回其基础值的字符串表示（一个数字的数值或一个变量的名称）。这种字符串转换对于在I/O堆栈上显示是必要的。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/8.New-Requirements/A454125_1_En_8_Fig6_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图 8-6 能够统一表示数字和变量的层次结构  </div></center><h4 id="8-2-2-3-符号表">8.2.2.3 符号表</h4><p>在本质上，符号表只是一个允许通过将键与值配对进行符号查找的数据结构（关联数组）。在这种情况下，变量名称作为键，数值作为值。C++标准库通过map或unordered_map直接提供这种服务，具体取决于所需的底层数据结构。然而，正如第3章中所建议的，我强烈建议不要直接在程序中使用标准库容器作为外部接口。相反，应该使用适配器模式将库容器封装在由应用程序本身定义的接口之后。这种模式不会给类的用户添加任何限制，但它确实允许设计者独立于底层库容器的接口限制、扩展或稍后修改组件的接口。</p><p>因此，符号表的推荐设计是创建一个SymbolTable类，将unordered_map&lt;string, double&gt;包装起来。这个底层哈希表为字符串形式的变量名和底层数值之间的映射提供了存储类型。SymbolTable类的公共接口为添加和（可选地，我们没有为清除变量指定命令）从符号表中删除变量提供了成员函数。由于我们在计算器中只需要一个符号表，所以SymbolTable可能应该实现为单例。</p><h4 id="8-2-2-4-一个微小的扩展：数值常量">8.2.2.4 一个微小的扩展：数值常量</h4><p>一旦我们建立了存储用户定义变量的机制，我们可以进行一个微小的扩展，提供用户定义的常量。常量只是一旦设置就不能更改的变量。常量可以在pdCalc中硬编码，通过读取常量文件在程序启动时添加，或在计算器执行过程中动态添加。</p><p>显然，为了存储一个常量，我们需要添加一个新命令；我们称之为cstore。cstore与store的工作方式完全相同，只是该命令通知符号表存储的变量不能更改。我们有两个明显的实现选项。首先，在SymbolTable类内部，我们添加一个表示给定名称是变量还是常量的第二个映射。这种方法的优点是添加额外映射将对现有代码进行最小的实现更改。缺点是这种方法需要每次调用符号表时进行两次独立查找。更好的方法是修改原始映射，将值类型存储为Entry而不是双精度数，其中Entry定义为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> val;</span><br><span class="line">  <span class="type">bool</span> isConst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，为了避免硬编码双精度类型，我们当然可以为SymbolTable和Entry都使用模板。</p><h4 id="8-2-2-5-由变量实现的功能">8.2.2.5 由变量实现的功能</h4><p>让我们看看变量能让我们做什么。考虑二次方程 ax^2+bx+c = 0，其根由下式给出：<br>$$ r=\frac{-b\pm \sqrt{b^2-4 ac}}{2a} $$</p><p>在过去，我们无法为计算两个根编写存储过程，现在我们可以编写存储过程：<br>“c” store “b” store “a” store “b” 2 pow 4 “a” “c” * * - sqrt “root” store<br>“b” - “root” + 2 a * / “b” - “root” 2 a * /</p><p>这将从堆栈中取出代表系数a、b、c的三个条目，并返回代表二次方程根的两个条目。现在我们的计算器正在取得进展！</p><h2 id="8-3-一些有趣的自我探索扩展">8.3 一些有趣的自我探索扩展</h2><p>本章以列出一些你可能考虑自己尝试的有趣扩展的部分结束。与前一节相反，我没有提供任何设计思路来帮助你开始。我只提供了每个挑战的简短描述。</p><h3 id="8-3-1-高DPI缩放">8.3.1 高DPI缩放</h3><p>具有极高像素分辨率的显示器越来越普遍。考虑如何修改pdCalc的GUI以适当处理这些显示器的缩放。这个功能是否与操作系统无关，还是我们需要从第7章的PlatformFactory中找到另一个用途？自5.6版本起，Qt通过一个高DPI缩放接口来帮助你完成此任务。</p><h3 id="8-3-2-动态换肤">8.3.2 动态换肤</h3><p>在第6章中，介绍了一个类来管理GUI的外观和感觉。然而，所提供的实现仅将外观和感觉集中起来。它没有允许用户自定义。</p><p>用户经常想要自定义他们的应用程序的外观和感觉。允许这种更改的应用程序被认为是“可换肤的”，每种不同的外观和感觉被称为皮肤。考虑一个接口以及适当的LookAndFeel类实现更改，以便实现pdCalc的换肤功能。一些可能的选项包括一个自定义各个小部件的对话框或者从皮肤配置文件中选择皮肤的机制。拥有一个集中的类来处理应用程序的外观和感觉应该使这个更改变得简单。别忘了给LookAndFeel添加一个信号，这样其他GUI元素将知道何时需要用新的外观重绘自己！</p><h3 id="8-3-3-流程控制">8.3.3 流程控制</h3><p>通过变量，我们极大地增强了存储过程的灵活性。对于计算大多数公式，这个框架应该足够了。然而，如果我们想要实现一个递归公式，例如计算一个数的阶乘呢？虽然我们可以通过插件执行这种复杂的计算，但如果能将这种功能扩展给那些不是经验丰富的C++程序员的计算器用户就更好了。要完成这个任务，我们需要设计一种流程控制语法。最简单的设计至少能够处理循环和条件操作。将流程控制添加到pdCalc将是一个相当重要的增强，无论是在增加的功能还是实现工作方面。现在可能是时候使用一个真正的扫描器和解析器了！</p><h3 id="8-3-4-另一种GUI布局">8.3.4 另一种GUI布局</h3><p>pdCalc GUI目前具有垂直方向，灵感来自HP48S计算器。然而，现代屏幕分辨率往往比宽度更高，这使得垂直方向不够理想。硬编码水平方向并不比原来的垂直方向更具挑战性。相反，考虑如何重新设计pdCalc，在运行时能够在方向之间切换。也许垂直方向只是一个不同的皮肤选项？</p><h3 id="8-3-5-绘图计算器">8.3.5 绘图计算器</h3><p>HP48系列计算器不仅仅是科学计算器，它们还是绘图计算器。虽然在计算机上实现一个绘图计算器可能不太实际，因为已经存在复杂的独立绘图程序，但这个练习可能会很有趣。从5.7版本开始，Qt现在包含一个绘图模块，使这个任务比以前容易得多。鉴于这个绘图小部件集，最大的挑战可能仅仅是设计一种图形输入方法。如果你想回到20世纪70年代，可以考虑为CLI实现一个ASCII绘图计算器！</p><h3 id="8-3-6-插件管理系统">8.3.6 插件管理系统</h3><p>目前，插件在pdCalc启动时加载，加载哪些插件是通过从文本文件中读取共享库名称来确定的。插件一旦加载，就不能卸载。考虑实现一个动态插件管理系统，以便在运行时选择、加载和卸载插件。你甚至可以扩展插件接口，以便动态查询插件描述。我认为这里真正的问题将是如何处理卸载一个在撤销/重做堆栈中有一个命令的插件。</p><h3 id="8-3-7-移动设备界面">8.3.7 移动设备界面</h3><p>在我最初为创建这本书所做的构想中，我设想了一章描述如何将pdCalc扩展到iOS或Android平板。Qt库可以再次帮助你完成这个任务。我没有在这本书中包含这样一章的原因是，我没有任何实际的平板编程经验。我觉得试图教别人如何从我第一次涉足这个设计领域开始设计平板界面是不诚实的。好吧，这可能是一个糟糕设计的绝佳示例！尽管如此，将pdCalc扩展到平板或智能手机界面是一个值得尝试的挑战，也是我留给你们的最后一个挑战。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Practical C++ Design From Programming to Architecture 1ed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. 插件</title>
      <link href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/"/>
      <url>/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/</url>
      
        <content type="html"><![CDATA[<h1>7. 插件</h1><p>您可能已经读过本章的标题，所以您已经知道这一章是关于插件的，具体来说是关于插件的设计和实现。此外，插件还将为我们提供一个机会，让我们探讨隔离平台特定功能的设计技巧。然而，在深入了解细节之前，让我们先定义一下插件是什么。</p><h2 id="7-1-什么是插件？">7.1 什么是插件？</h2><p>插件是一种软件组件，使得在程序的初始编译之后向程序添加新功能成为可能。在这一章中，我们将专注于运行时插件，也就是以共享库（例如，POSIX .so 或 Windows .dll 文件）的形式构建的、在运行时可以发现和加载的插件。</p><p>插件在应用程序中有很多不同的用途。这里只列举了一些例子。首先，插件允许最终用户在不需要重新编译的情况下为现有程序添加功能。通常，这些是原始应用程序开发者完全没有预料到的新功能。其次，在架构上，插件使得程序可以分成多个可选的部分，这些部分可以单独与程序一起发布。例如，考虑一个程序（如网络浏览器），它附带一些基本功能，但允许用户添加特殊功能（如广告拦截器）。第三，插件可以用于设计一个可以根据特定客户进行定制的应用程序。例如，考虑一个电子健康记录系统，根据软件部署在医院还是医生的个人诊所，需要不同的功能。不同的模块可以通过插件形式捕获必要的定制，并插入核心系统。当然，还可以想到许多其他插件的应用场景。</p><p>在 pdCalc 的上下文中，插件是提供新计算器命令的共享库，以及可选的新 GUI 按钮。这个任务有多困难？在第 4 章中，我们创建了许多命令，并发现添加新命令相当简单。我们只需从 Command 类（或其派生类，如 UnaryCommand 或 BinaryCommand）继承，实例化命令，并将其注册到 CommandRepository。例如，正弦命令在 CoreCommands.h 中声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sine</span> : <span class="keyword">public</span> UnaryCommand &#123;</span><br><span class="line">    <span class="comment">// implement Command virtual members</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并在 CoreCommands.cpp 中通过以下行注册</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">registerCommand</span>( ui, <span class="string">&quot;sin&quot;</span>, <span class="built_in">MakeCommandPtr</span>&lt;Sine&gt;() );</span><br></pre></td></tr></table></figure><p>结果证明，插件命令几乎可以完全按照这个配方进行，除了一个关键步骤。由于在编译时 pdCalc 不知道插件命令的类名，我们无法使用插件类的名称进行分配。</p><p>这个看似简单的难题导致了我们需要为插件解决的第一个问题。具体来说，我们需要建立一个抽象接口，使得插件命令可以被 pdCalc 发现并在其中注册。一旦我们就插件接口达成一致，我们将迅速遇到第二个基本的插件问题，即如何动态加载一个插件，甚至让共享库中的名称对 pdCalc 可用。为了使我们的生活更加复杂，这第二个问题的解决方案取决于平台，所以我们将寻求一种尽量减少平台依赖痛苦的设计策略。我们将遇到的最后一个问题是动态更新现有代码以添加新命令和按钮。也许令人惊讶的是，这最后一个问题是最容易解决的。然而，在我们开始解决这三个问题之前，我们需要考虑一下 C++ 插件的一些规则。</p><h3 id="7-1-1-C-插件的规则">7.1.1 C++ 插件的规则</h3><p>插件在概念上并不是 C++ 语言的一部分。相反，插件是操作系统动态加载和链接共享库的体现（因此插件的平台特性）。对于任何非平凡大小的项目，应用程序通常被划分为一个可执行文件和几个共享库（传统上，在 Unix 中是 .so 文件，在 Mac OS X 中是 .dylib 文件，在 MS Windows 中是 .dll 文件）。</p><p>通常情况下，作为 C++ 程序员，我们对这种结构涉及的细微差别一无所知，因为可执行文件和库是在一个统一的构建环境中构建的（即，相同的编译器和标准库）。然而，在实际的插件接口中，我们不能做出这样的保证。相反，我们必须采取防御性编程，并假设最糟糕的情况，即插件是在与主应用程序不同但兼容的环境中构建的。在这里，我们将做一个相对较弱的假设，即这两个环境至少具有相同的对象模型。具体来说，我们要求这两个环境在处理虚拟函数指针（vptr）的布局上是相同的。如果您不熟悉虚拟函数指针的概念，可以在 Lippman [13] 中找到所有详细信息。虽然原则上，C++ 编译器作者可以选择不同的 vptr 布局，但在实践中，编译器通常使用兼容的布局，尤其是相同编译器的不同版本。如果没有这种共享对象模型的假设，我们将被迫开发一个仅使用 C 语言的插件结构。请注意，我们还必须假设主应用程序和插件中所有类型 T 的 sizeof(T) 大小相同。这排除了例如具有 32 位应用程序和 64 位插件的情况，因为这两个平台具有不同的指针大小。</p><p>在异构环境中编程如何影响我们可以使用的编程技术？在最糟糕的情况下，主应用程序可能会使用不同的编译器和不同的标准库构建。这一事实有几个严重的影响。首先，我们不能假设插件和应用程序之间的内存分配和释放是兼容的。这意味着在插件中分配的任何内存必须在相同的插件中释放。其次，我们不能假设来自标准库的代码在任何插件和主应用程序之间是兼容的。因此，我们的插件接口不能包含任何标准容器。尽管库不兼容可能看起来有点奇怪（这是标准库，对吧？），但请记住，标准指定的是接口，而不是实现（受到某些限制，例如向量占用连续内存）。例如，不同的标准库实现通常具有不同的字符串实现。有些人更喜欢小字符串优化，而另一些人更喜欢使用写时复制。第三，虽然我们已经假设了对象中 vptr 的兼容布局，但我们不能假设相同的对齐方式。因此，如果主应用程序中使用了这些成员变量，插件类不应该继承具有基类中定义的成员变量的主应用程序类。这是因为如果每个编译器使用不同的对齐方式，主应用程序的编译器可能会为成员变量使用与插件编译器定义的不同内存偏移量。第四，由于不同编译器之间名称改编的差异，导出的接口必须指定 extern “C” 连接。连接要求是双向的。插件不应该在没有 extern “C” 连接的情况下调用应用程序函数，应用程序也不应该在没有 extern “C” 连接的情况下调用插件函数。请注意，由于非内联、非虚成员函数需要跨编译单元链接（与虚函数相反，虚函数通过虚函数表中的偏移量通过 vptr 调用），应用程序只应通过虚函数调用插件代码，插件代码不应调用在主应用程序中编译的基类非内联、非虚函数。最后，异常在主程序和插件之间的二进制接口上很少是可移植的，所以我们不能在插件中抛出异常并尝试在主应用程序中捕获它们。</p><p>这实在是说得太多了。让我们通过列举C++插件的规则来回顾一下：</p><ol><li class="lvl-3"><p>在插件中分配的内存必须在相同的插件中释放。</p></li><li class="lvl-3"><p>标准库组件不能在插件接口中使用。</p></li><li class="lvl-3"><p>假设不兼容的对齐方式。如果变量在主应用程序中使用，避免插件继承具有成员变量的主应用程序类。</p></li><li class="lvl-3"><p>从插件导出的函数（由主应用程序调用）必须指定extern &quot;C&quot;连接。从主应用程序导出的函数（由插件调用）必须指定extern &quot;C&quot;连接。</p></li><li class="lvl-3"><p>主应用程序应通过虚函数专门与插件派生类通信。插件派生类不应调用非内联、非虚拟的主应用程序基类函数。</p></li><li class="lvl-3"><p>不要让插件抛出的异常传播到主应用程序。</p></li></ol><p>牢记这些规则，让我们回到为了设计插件必须解决的三个基本问题。</p><h2 id="7-2-问题1：插件接口">7.2 问题1：插件接口</h2><p>插件接口负责几个项目。首先，它必须实现新命令和新GUI按钮的发现。我们将看到，通过类接口最有效地实现这一功能。其次，插件必须支持用于分配和释放上述插件类的C连接接口。第三，pdCalc应该提供一个从Command派生的PluginCommand类，以协助正确编写插件命令。从技术上讲，PluginCommand类是可选的，但提供这样一个接口有助于用户遵守插件规则3和6。第四，插件接口提供查询插件支持的API版本的功能是值得的。最后，pdCalc必须为插件调用的任何函数提供C连接。具体来说，插件命令必须能够访问堆栈。我们将按顺序解决这些问题，从发现命令的接口开始。</p><h3 id="7-2-1-发现命令的接口">7.2.1 发现命令的接口</h3><p>我们面临的第一个问题是如何从插件中分配命令，而我们既不知道插件提供的命令，也不知道我们需要实例化的类的名称。我们将通过创建一个所有插件都必须遵循的抽象接口来解决这个问题，该接口可以导出命令及其名称。首先，让我们讨论一下我们需要的功能。</p><p>回想一下第4章，为了将新命令加载到计算器中，我们必须将其注册到CommandRepository中。按设计，CommandRepository是专门用于承认动态分配命令的，这正是我们为插件命令所需的功能。现在，我们假设插件管理系统可以访问注册命令（我们将在第7.4节解决这个问题）。CommandRepository的注册功能需要一个字符串名称和一个作为命令原型的unique_ptr。由于pdCalc事先对插件中的命令名称一无所知，插件接口必须首先使名称可发现。其次，由于C++缺少反射这种语言特性，插件接口必须提供一种方法来创建一个与每个发现的名称相关联的原型命令。再次，根据设计，抽象的Command接口通过clone()虚成员函数支持原型模式。让我们看看这两个先前的设计决策如何有效地启用插件。</p><p>基于上述C<ins>插件规则，我们实现命令发现的唯一手段是将其封装为一个纯虚接口，所有插件都必须遵循这个接口。理想情况下，我们的虚函数将返回一个由字符串键控的unique_ptr<CommandPtr>值的关联容器。然而，我们的C</CommandPtr></ins>插件规则也规定我们不能使用标准容器，因此排除了string、map、unordered_map和unique_ptr。与其（糟糕地）重新实现这些容器的自定义版本，我们只是使用一个通常避免的低级功能：指针数组。</p><p>通过创建一个插件类来强制执行上述设计，所有插件都必须遵循这个类。这个抽象类的目的是标准化插件命令发现。类声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plugin</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Plugin</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Plugin</span>();</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PluginDescriptor</span> &#123;</span><br><span class="line">        <span class="type">int</span> nCommands;</span><br><span class="line">        <span class="type">char</span>** commandNames;</span><br><span class="line">        Command** commands;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> PluginDescriptor&amp; <span class="title">getPluginDescriptor</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们有了一个抽象的插件接口，当进行特化时，需要一个派生类返回一个描述符，该描述符提供了可用命令的数量、这些命令的名称以及命令本身的原型。显然，命令名称的顺序必须与命令原型的顺序相匹配。不幸的是，对于原始指针和原始数组，命令名称和命令原型的内存归属变得模糊。我们无法使用标准容器，使我们陷入了一个不幸的设计：通过注释约定。因为我们的规则规定插件中分配的内存必须由相同的插件释放，所以最好的策略是规定插件负责释放PluginDescriptor及其组成部分。如前所述，内存约定是通过注释“强制执行”的。</p><p>太好了，我们的问题解决了。我们创建一个插件，叫做MyPlugin，继承自Plugin。在下面的第7.3节中，我们将了解如何分配和释放插件。在MyPlugin内部，我们像往常一样通过继承Command来创建新的命令。由于插件知道自己的命令名称，与主程序不同，插件可以使用new操作符分配其命令原型。然后，为了注册插件的所有命令，我们简单地分配一个带有命令名称和命令原型的插件描述符，通过覆盖getPluginDescriptor()函数返回描述符，并让pdCalc注册命令。因为Commands必须实现一个clone()函数，pdCalc可以通过这个虚函数复制插件命令原型，将它们注册到CommandRepository。简单地说，可以从commandNames数组中创建用于注册的字符串名称。对于已分配的Plugin* p，pdCalc中的以下代码可以实现注册：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Plugin::PluginDescriptor&amp; d = p-&gt;<span class="built_in">getPluginDesciptor</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.nCommands; ++i)</span><br><span class="line">    CommandRepository::<span class="built_in">Instance</span>().<span class="built_in">registerCommand</span>(d.commandNames[i],</span><br><span class="line">        <span class="built_in">MakeCommandPtr</span>(d.commands[i]-&gt;<span class="built_in">clone</span>()));</span><br></pre></td></tr></table></figure><p>在这一点上，您可能会认识到我们的插件面临的困境。命令在插件中分配，在主程序的CommandRepository中通过clone()调用注册时复制，最后在CommandRepository的析构函数执行时由主程序删除。更糟糕的是，每次执行命令时，CommandRepository会克隆它的原型，通过插件中的Command的clone()函数触发一个新的语句。这个执行命令的生命周期由CommandManager通过它的撤消和重做堆栈来管理。具体来说，当一个命令从这些堆栈中清除时，当保存命令的unique_ptr被销毁时，主程序中会调用delete。至少，在没有一些调整的情况下就是这样工作的。正如第4章中提到的，CommandPtr不仅仅是unique_ptr<Command>的简单别名。现在我终于要描述CommandPtr别名和MakeCommandPtr()函数背后的机制，这些机制允许正确地管理插件命令内存。</Command></p><p>从根本上说，我们首先需要一个函数在适当的编译单元中调用delete。解决这个问题的最简单方法是将一个deallocate()虚函数添加到Command类中。这个函数的职责是在命令被销毁时在正确的编译单元中调用delete。对于所有核心命令，正确的行为只是在主程序中删除类。因此，我们不将deallocate()函数设置为纯虚函数，我们为其提供以下默认实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Command::deallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于插件命令，deallocate()的重写具有相同的定义，只是定义出现在插件的编译代码中（例如，在特定插件中的命令使用的基类中）。因此，当在主应用程序中的Command指针上调用deallocate()时，虚拟函数分派确保从正确的编译单元调用delete。现在我们只需要一个机制来确保在回收Commands时调用deallocate()而不是直接调用delete。幸运的是，就像他们设计unique_ptr时标准委员会完美地预料到了我们的需求一样。让我们回到CommandPtr别名，看看unique_ptr如何用来解决我们的问题。</p><p>只需要很少的几行代码就可以定义一个CommandPtr别名，并实现一个能够调用deallocate()而不是delete的MakeCommandPtr()函数。代码利用了unique_ptr的删除器对象（见侧边栏），该对象在调用unique_ptr的析构函数时启用自定义例程来回收unique_ptr所持有的资源。让我们看看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">CommandDeleter</span><span class="params">(Command* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">deallocate</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> CommandPtr = unique_ptr&lt;Command, <span class="keyword">decltype</span>(&amp;CommandDeleter)&gt;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">MakeCommandPtr</span><span class="params">(Command* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CommandPtr&#123;p, &amp;CommandDeleter&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面密集代码的简短解释是有必要的。CommandPtr只是一个unique_ptr的别名，它包含一个在析构时通过调用CommandDeleter()函数回收的Command指针。unique_ptr调用的CommandDeleter()函数是一个简单的内联函数，它调用之前定义的虚拟deallocate()函数。为了减轻创建CommandPtrs的语法负担，我们引入了一个内联MakeCommandPtr()辅助函数，它从Command指针构造一个CommandPtr。就是这样。现在，就像以前一样，unique_ptrs自动管理Commands的内存。然而，unique_ptr的析构函数不是直接在底层的Command上调用delete，而是调用CommandDeleter函数，该函数调用deallocate()，在正确的编译单元上对底层的Command发出delete。</p><p>如果您查看MakeCommandPtr()的源代码，除了上面看到的接受Command指针参数的函数版本外，您还会看到一个使用可变模板和完美转发的非常不同的重载。由于MakeCommandPtr()在构建存储过程中具有不同的语义用法，这个重载函数必须存在。我们将在第8章中重新审视函数的两种形式背后的原因。如果悬念无法忍受，请随时跳到第8.1.2节。</p><hr><p>现代C++设计注意事项：Unique_Ptr析构语义</p><p>unique_ptr&lt;T,D&gt; 类模板是一种智能指针，它模拟对资源的唯一所有权。最常见的用法仅指定第一个模板参数，T，它声明要拥有的指针类型。第二个参数，D，指定在析构 unique_ptr 期间调用的自定义删除可调用对象。让我们看一个 unique_ptr 析构函数的概念模型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D = default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr &#123;</span><br><span class="line">    T* p_;</span><br><span class="line">    D d_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">unique_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">d_</span>(p_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>unique_ptr 的析构函数不直接调用 delete，而是使用函数调用语义将所拥有的指针传递给删除器。从概念上讲，default_delete 的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是说，default_delete 只是删除 unique_ptr 包含的底层指针。然而，通过在构造过程中指定一个自定义删除器可调用对象（D模板参数），unique_ptr 可用于释放需要自定义释放语义的资源。作为一个简单的例子，结合一个 lambda 表达式，unique_ptr 的删除语义允许我们创建一个简单的 RAII（资源获取即初始化）容器类，MyObj，由 malloc() 分配：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyObj* m = <span class="built_in">static_cast</span>&lt;MyObj*&gt;( <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(MyObj) ) );</span><br><span class="line"><span class="keyword">auto</span> d = [](MyObj* p)&#123; <span class="built_in">free</span>(p); &#125;;</span><br><span class="line"><span class="keyword">auto</span> p = unique_ptr&lt;MyObj, <span class="keyword">decltype</span>(d)&gt;&#123;m, d&#125;;</span><br></pre></td></tr></table></figure><p>当然，我们为 pdCalc 设计的另一个实例也显示了 unique_ptr 自定义删除语义的有用性。应该指出的是，shared_ptr 也以类似的方式接受自定义删除器。</p><hr><h3 id="7-2-2-添加新GUI按钮的接口">7.2.2 添加新GUI按钮的接口</h3><p>从概念上讲，动态添加按钮与动态添加命令没有太大区别。主应用程序不知道需要从插件中导入哪些按钮，因此Plugin接口必须提供一个提供按钮描述符的虚拟函数。然而，与命令不同，插件实际上不需要分配按钮本身。回顾第6章，GUI CommandButton 部件只需要文本进行构造。具体来说，它需要 push button 的显示文本（可选的，shifted状态文本）和与 clicked() 信号一起发出的命令文本。因此，即使对于插件命令，相应的 GUI 按钮本身也完全位于主应用程序中；插件只需提供文本。这导致了Plugin类中以下简单的接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plugin</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PluginButtonDescriptor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nButtons;</span><br><span class="line">        <span class="type">char</span>** dispPrimaryCmd; <span class="comment">// primary command label</span></span><br><span class="line">        <span class="type">char</span>** primaryCmd;     <span class="comment">// primary command</span></span><br><span class="line">        <span class="type">char</span>** dispShftCmd;    <span class="comment">// shifted command label</span></span><br><span class="line">        <span class="type">char</span>** shftCmd;        <span class="comment">// shifted command</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> PluginButtonDescriptor* <span class="title">getPluginButtonDescriptor</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再次强调，由于我们必须遵循插件的规则，接口必须由低级字符数组组成，而不能是更高级的STL结构。</p><p>getPluginButtonDescriptor() 函数相对于 getPluginDescriptor() 的一个有趣的方面是决定返回指针而不是引用。这个选择背后的理由是插件编写者可能希望编写一个导出没有相应 GUI 按钮的命令的插件（即，仅CLI命令）。反过来，当然是无意义的。也就是说，我无法想象为什么有人会编写一个导出不存在命令的按钮的插件。这种实用性体现在两个描述符函数的返回类型中。由于这两个函数都是纯虚的，插件专门化必须实现它们。因为getPluginDescriptor()返回一个引用，它必须导出一个非空描述符。然而，通过返回描述符的指针，getPluginButtonDescriptor()允许返回一个空指针，表示插件没有导出任何按钮。有人可能会争辩说，getPluginButtonDescriptor() 函数不应该是纯虚的，而应该提供一个默认实现，返回一个空指针。这个决定在技术上是可行的。然而，通过坚持插件作者手动实现getPluginButtonDescriptor()，接口强制显式地做出决策。</p><h3 id="7-2-3-插件分配和释放">7.2.3 插件分配和释放</h3><p>我们最初的问题是主程序不知道插件命令的类名，因此无法通过调用 new 分配它们。我们通过创建一个抽象的 Plugin 接口来解决这个问题，该接口负责导出命令原型、命令名称以及 GUI 创建按钮所需的足够信息。当然，要实现这个接口，插件必须从 Plugin 类派生，从而创建一个特化，其名称主应用程序无法预先知道。看似我们没有取得进展，又回到了最初的问题。</p><p>我们的新问题，尽管与原问题相似，实际上要容易得多解决。解决问题的方法是在每个插件中创建一个 extern “C” 分配/释放函数对，预先指定的名称通过基类指针分配/释放 Plugin 特化类。为了满足这些要求，我们在插件接口中添加了以下两个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span>* <span class="title">AllocPlugin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">DeallocPlugin</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br></pre></td></tr></table></figure><p>显然，AllocPlugin() 函数分配 Plugin 特化并将其返回给主应用程序，而 DeallocPlugin() 函数在主应用程序完成使用插件后对其进行释放。有趣的是，AllocPlugin() 和 DeallocPlugin() 函数使用 void 指针而不是 Plugin 指针。这个接口是保持 C 链接所必需的，因为 extern “C” 接口必须符合 C 类型。维护 C 链接的一个不幸后果是必须进行类型转换。在使用它之前，主应用程序必须将 void* 转换为 Plugin*，在调用 delete 之前，共享库必须将 void* 转换回 Plugin*。请注意，我们不需要具体 Plugin 的类名。因此，AllocPlugin()/DeallocPlugin() 函数对解决了我们的问题。</p><h3 id="7-2-4-插件命令接口">7.2.4 插件命令接口</h3><p>从技术上讲，不需要特殊的插件命令接口。但是，提供这样一个接口有助于编写遵循 C++ 插件规则的插件命令。具体来说，通过创建一个 PluginCommand 接口，我们为插件开发者提供了两个关键特性。首先，我们提供了一个接口，确保插件命令不会从具有任何状态（避免对齐问题）的命令类继承。这个属性在构造时是显而易见的。其次，我们调整 checkPreconditionsImpl() 函数以在插件边界上创建一个无异常的接口。根据这个指导思想，这里是 PluginCommand 接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PluginCommand</span> : <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PluginCommand</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">checkPluginPreconditions</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> PluginCommand* <span class="title">clonePluginImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkPreconditionsImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> <span class="keyword">final</span></span>;</span><br><span class="line">    <span class="function">PluginCommand* <span class="title">cloneImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然在第 4 章中只简要提及，但 Command 类中的所有纯虚函数都标记为 noexcept，除了 c heckPreconditionsImpl() 和 cloneImpl()（请参阅关于 noexcept 关键字的侧边栏）。因此，为确保插件命令不产生异常，我们只需在 PluginCommand 层次结构中实现 checkPreconditionsImpl() 和 cloneImpl() 函数，并为其派生类创建新的、无异常的纯虚函数来实现。PluginCommand 类中的 checkPreconditionsImpl() 和 cloneImpl() 都标记为 final，以防止特化意外地覆盖这两个函数。checkPreconditionsImpl() 的实现可以简单地写为如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PluginCommand::checkPreconditionsImpl</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = <span class="built_in">checkPluginPreconditions</span>();</span><br><span class="line">    <span class="keyword">if</span>(p) </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Exception</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，上述实现背后的关键思想是 PluginCommand 类的实现位于主应用程序的编译单元中，而该类的任何特化都位于插件的编译单元中。因此，通过虚拟调度，调用 checkPreconditionsImpl() 在主应用程序的编译单元中执行，此函数反过来调用位于插件编译单元中的无异常 checkPluginPreconditions() 函数。如果发生错误，checkPreconditionsImpl() 函数通过 nullptr 返回值接收错误，并从主应用程序的编译单元而不是插件的编译单元产生异常。</p><p>类似的简单实现对于 cloneImpl() 可以在 Command.cpp 中找到。从 PluginCommand 而不是 Command、UnaryCommand 或 BinaryCommand 继承的插件命令更有可能避免违反任何 C++ 插件规则，因此不太可能产生难以诊断的插件特定运行时错误。</p><hr><p>现代 C++ 设计注解：Noexcept</p><p>C++98 标准允许使用异常规范。例如，以下规范表示函数 foo() 不抛出任何异常（抛出规范为空）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>不幸的是，C++98 异常规范存在许多问题。虽然它们是指定函数可能抛出的异常的高尚尝试，但它们通常并不表现如预期。例如，编译器从不在编译时保证异常规范，而是通过运行时检查来强制执行此约束。更糟糕的是，声明一个不抛出异常的规范可能会影响代码性能。出于这些原因和其他原因，许多编码标准规定应该简单地避免异常规范（例如，请参见 [27] 中的标准 75）。</p><p>虽然指定函数可以抛出哪些异常规范事实证明并不是非常有用，但指定函数不能抛出任何异常可能是一个重要的接口考虑。幸运的是，C++11 标准通过引入 noexcept 关键字来解决异常规范混乱的问题。关于 noexcept 说明符的用途的深入讨论，请参见 [19] 中的项目 14。在我们的讨论中，我们将关注这个关键字在设计中的实用性。</p><p>性能优化不考虑，将 noexcept 用于函数规范的选择主要是个人喜好问题。对于大多数函数，没有异常规范是常规的。即使函数的代码本身不发出异常，也很难静态地确保函数内的嵌套函数调用不发出任何异常。因此，noexcept 在运行时强制执行，而不是在编译时保证。因此，我的个人建议是将 noexcept 说明符的使用保留在需要对函数的意图进行强烈声明的特定实例中。pdCalc 的 Command 层次结构说明了不抛出异常对于正确操作非常重要的几种情况。这个要求在接口中编码，以告知开发人员抛出异常将导致运行时故障。</p><hr><h3 id="7-2-5-API-版本控制">7.2.5 API 版本控制</h3><p>在一个长寿命应用程序的生命周期中，插件的规范可能会发生变化。这意味着在某个时间点编写的插件可能无法与更新后的 API 版本一起使用。对于作为单个单元交付的应用程序，组成整体的组件（即多个共享库）通过开发计划进行同步。对于完整的应用程序，版本控制用于向外部世界表示整个应用程序已发生更改。然而，由于插件被设计为与主应用程序的开发独立，插件发布与应用程序发布之间的同步可能是不可能的。此外，插件 API 可能会或可能不会随着每个应用程序版本的发布而改变。因此，为确保兼容性，我们必须将插件 API 单独从主应用程序进行版本控制。虽然您可能不预料到将来会更改插件 API，但是如果您没有将查询插件支持的 API 版本作为 API 本身的一部分添加到前端，则您将不得不稍后引入一个突破性的更改以添加此功能。根据您的要求，这样的重大更改可能不可行，您将永远无法添加 API 版本控制。因此，即使最初没有使用，也应该将查询插件支持的 API 版本的功能添加到插件接口中，将其视为隐含的要求。希望现在大家明白，API 版本与应用程序版本是不同的。</p><p>实际的 API 版本编号方案可以简单或复杂，具体取决于认为合适的程度。在简单的一面，它可以是一个整数。在更复杂的一面，它可以是一个包含主要版本、次要版本等多个整数的结构。对于 pdCalc，我选择了一个简单的结构，只使用主版本和次版本号。接口代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plugin</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ApiVersion</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> major;</span><br><span class="line">        <span class="type">int</span> minor;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ApiVersion <span class="title">apiVersion</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为 pdCalc 是第一个版本，主应用程序不需要比检查插件是否使用 API 版本 1.0 更复杂的算法。如果违反了这个约束，就不会加载有问题的插件。</p><h3 id="7-2-6-提供堆栈功能">7.2.6 提供堆栈功能</h3><p>插件接口的一部分包括让插件及其命令对 pdCalc 可发现。pdCalc 的插件接口的另一部分包括让 pdCalc 的必要功能部分对插件可用。具体来说，新命令的实现需要访问 pdCalc 的堆栈。</p><p>正如我们在开发核心命令时看到的，命令只需要非常基本的访问堆栈功能。具体来说，它们需要将元素压入堆栈、从堆栈弹出元素以及可能从堆栈检查元素（以实现前提条件）的能力。我们为核心命令提供这些功能的策略是将 Stack 类作为具有包括 push、pop 和检查成员函数的公共接口的单例来实现。然而，这种设计无法扩展到插件命令，因为它违反了 C++ 插件规则中的两条。即，我们当前的接口不符合 C 链接（堆栈提供 C++ 类接口），当前的检查函数通过 STL 向量返回堆栈元素。</p><p>解决这个问题的方法相当简单。我们只需在堆栈上添加一个新接口（最好是在专门指定的头文件中），该接口由一组全局（在 pdCalc 命名空间之外）的 extern “C” 函数组成，这些函数在 C 链接和 C++ 类链接之间进行转换（再次使用适配器模式）。请记住，由于 Stack 类是作为单例实现的，因此插件和全局辅助函数都不需要拥有 Stack 引用或指针。辅助函数通过其 Instance() 函数直接访问 Stack。我选择在单独的 StackPluginInterface.h 头文件中实现以下五个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">StackPush</span><span class="params">(<span class="type">double</span> d, <span class="type">bool</span> suppressChangeEvent)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">double</span> <span class="title">StackPop</span><span class="params">(<span class="type">bool</span> suppressChangeEvent)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">size_t</span> <span class="title">StackSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">double</span> <span class="title">StackFirstElement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">double</span> <span class="title">StackSecondElement</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>为了简单起见，由于我的示例插件不需要比前两个元素更深入地访问堆栈，我只创建了两个检查函数，StackFirstElement() 和 StackSecondElement() ，用于获取堆栈的前两个元素。如果需要，可以实现一个返回堆栈中任何深度的元素的函数。为了保持 extern “C” 链接，实现这样一个功能的人需要记住使用原始 double 数组而不是 STL 向量。</p><p>上述五个函数的完整、简单实现出现在 StackPluginInterface.cpp 文件中。作为示例，给出了 StackSize() 函数的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">StackSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pdCalc::Stack::<span class="built_in">Instance</span>().<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-问题-2：加载插件">7.3 问题 2：加载插件</h2><p>如前所述，插件是特定于平台的，从本质上讲，加载插件需要特定于平台的代码。在本节中，我们将考虑两个主题。首先，我们将解决加载库及其各自符号所需的特定于平台的代码。在这里，我们将查看两个平台接口：POSIX（Linux、UNIX、Mac OS X）和win32（MS Windows）。其次，我们将探讨一种设计策略，以减轻常常因使用特定于平台的代码而产生的源代码混乱。</p><h3 id="7-3-1-特定于平台的插件加载">7.3.1 特定于平台的插件加载</h3><p>为了使用插件，我们只需要三个特定于平台的函数：一个用于打开共享库的函数，一个用于关闭共享库的函数，以及一个用于从打开的共享库中提取符号的函数。表7-1按平台列出了这些函数及其关联的头文件。让我们看看如何使用这些函数。</p><p>Table 7-1 Plugin functions for different platforms<br>表7-1 不同平台的插件函数</p><table><thead><tr><th></th><th>FunPOSIXctions</th><th>win32</th></tr></thead><tbody><tr><td>header</td><td>dlfcn.h</td><td>windows.h</td></tr><tr><td>load library</td><td>dlopen()</td><td>LoadLibrary()</td></tr><tr><td>close library</td><td>dlclose()</td><td>FreeLibrary()</td></tr><tr><td>get library symbol</td><td>dlsym()</td><td>GetProcAddress()</td></tr></tbody></table><h3 id="7-3-2-加载、使用和关闭共享库">7.3.2 加载、使用和关闭共享库</h3><p>使用插件的第一步是要求运行时系统打开库，并使其可导出符号可用于当前的工作程序。每个平台上的打开命令都需要要打开的共享库的名称（POSIX 还需要一个指定符号绑定的标志，要么是延迟的，要么是立即的），它返回一个不透明的库句柄，该句柄用于在后续函数调用中引用库。在 POSIX 系统上，句柄类型为 void*，而在 win32 系统上，句柄类型为 HINSTANCE（经过一些拆解，这是一个 void* 的 typedef）。例如，以下代码在 POSIX 系统上打开一个插件库，<a href="http://libPlugin.so">libPlugin.so</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* handle = <span class="built_in">dlopen</span>(<span class="string">&quot;libPlugin.so&quot;</span>, RTLD_LAZY);</span><br></pre></td></tr></table></figure><p>其中 RTLD_LAZY 选项告诉运行时系统执行延迟绑定，这将在引用它们的代码被执行时解析符号。另一种选择是 RTLD_NOW，它会在 dlopen() 返回之前解析库中的所有未定义符号。如果打开失败，则返回空指针。简单的错误处理方案跳过从空插件加载任何功能，警告用户打开插件失败。</p><p>除了不同的函数名称外，打开插件的主要特定于平台的区别是不同平台采用的规范命名约定。例如，在 Linux 上，共享库以 lib 开头，具有 .so 文件扩展名。在 Windows 上，共享库（通常称为动态链接库，或简称 DLL）没有特定的前缀，具有 .dll 文件扩展名。在 Mac OS X 上，共享库通常以 lib 为前缀，具有 .dylib 扩展名。从本质上讲，这种命名约定仅在两个地方有关系。首先，构建系统应为各个平台创建具有适当名称的插件。其次，打开插件的调用应使用正确的格式指定名称。由于插件名称在运行时指定，我们需要确保由提供插件的用户正确指定插件名称。</p><p>一旦插件被打开，我们需要从共享库中导出符号，以便调用插件中包含的函数。这可以通过调用 dlopen() 或 LoadLibrary()（取决于平台）来实现，它们中的任何一个都使用插件函数的字符串名称将插件函数绑定到函数指针。然后在主应用程序中通过获得的函数指针间接调用绑定的插件函数。</p><p>为了绑定共享库中的符号，我们需要有一个插件句柄（打开插件的返回值），知道我们要调用的插件中的函数的名称，以及我们要调用的函数的签名。对于 pdCalc，我们需要调用的第一个插件函数是 AllocPlugin()，用于分配嵌入式 Plugin 类（请参见上面的第 7.2.3 节）。因为这个函数是作为插件接口的一部分声明的，所以我们知道它的名称和签名。举例来说，在 Windows 上，对于一个已经加载的插件，由 HINSTANCE 句柄指向，我们将插件的 AllocPlugin() 函数绑定到一个函数指针，使用以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function pointer of AllocPlugin &#x27;s type:</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123; <span class="keyword">typedef</span> <span class="type">void</span>* (*PluginAllocator)(<span class="type">void</span>); &#125;</span><br><span class="line"><span class="comment">// bind the symbol from the plugin</span></span><br><span class="line"><span class="keyword">auto</span> alloc = <span class="built_in">GetProcAddress</span>(handle, <span class="string">&quot;AllocPlugin&quot;</span>);</span><br><span class="line"><span class="comment">// cast the symbol from void* (return of GetProcAddress)</span></span><br><span class="line"><span class="comment">// to the function pointer type of AllocPlugin</span></span><br><span class="line">PluginAllocator allocator&#123; <span class="built_in">reinterpret_cast</span>&lt;PluginAllocator&gt;(alloc) &#125;;</span><br></pre></td></tr></table></figure><p>随后，通过以下方式分配插件的 Plugin 专门化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only dereference if the function was bound properly</span></span><br><span class="line"><span class="keyword">if</span>(allocator)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// dereference the allocator, call the function,</span></span><br><span class="line">    <span class="comment">// cast the void* return to a Plugin*</span></span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">static_cast</span>&lt;Plugin*&gt;((*allocator)());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，具体的插件已经可以通过抽象的插件接口来使用（例如，加载插件命令，查询支持的插件API）。</p><p>/redo stack in the CommandManager.</p><p>在插件释放时，需要绑定并执行插件的DeallocPlugin()函数，这需要类似的代码序列。有兴趣的读者可以参考GitHub仓库中的平台特定代码了解详细信息。请记住，在释放插件之前，由于插件分配的命令驻留在主应用程序的内存中（但必须在插件中回收），插件在释放所有命令之前不得关闭。驻留在主应用程序内存空间中的插件命令示例包括CommandRepository中的命令原型以及CommandManager中的撤消/重做堆栈上的命令。</p><p>由于插件是一个获取的资源，当我们不再使用它时，应该释放它。这个操作在POSIX平台上通过调用dlclose()来完成，在win32平台上通过调用FreeLibrary()来完成。例如，以下代码用于关闭在POSIX系统上使用dlopen()打开的共享库（句柄）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only try to close a non-null library</span></span><br><span class="line"><span class="keyword">if</span>(handle) <span class="built_in">dlclose</span>(handle);</span><br></pre></td></tr></table></figure><p>现在我们已经讨论了打开、使用和关闭插件的平台特定机制，让我们把注意力转向一种设计策略，以减轻处理多平台源代码所固有的复杂性。</p><h3 id="7-3-3-多平台代码的设计">7.3.3 多平台代码的设计</h3><p>跨平台的可移植性对于任何软件项目来说都是值得称赞的目标。然而，在保持代码库可读的同时实现这一目标需要认真考虑。在本节中，我们将探讨一些在保持可读性的同时实现平台可移植性的设计技巧。</p><h4 id="7-3-3-1-显而易见的解决方案：库">7.3.3.1 显而易见的解决方案：库</h4><p>显而易见（也是首选）的解决可移植性问题的方法是使用一个为您抽象平台依赖性的库。在任何开发场景中使用高质量的库总是可以节省为您的项目设计、实现、测试和维护所需功能的努力。对于跨平台开发，使用库还有一个额外的好处，即在一个平台无关的API后面隐藏平台特定的代码。这种API当然允许您在不用预处理器指令污染源代码的情况下，维护一个在多个平台上无缝工作的单一代码库。尽管我在第6章中没有明确讨论这些优点，但Qt的工具包抽象提供了一个用于构建GUI的平台无关的API，而这本来是一个依赖于平台的任务。在pdCalc中，我们使用Qt构建了一个在Windows和Linux（以及可能是OS X，尽管我没有验证这一点）上编译和执行的GUI，而不需要在平台之间更改源代码的任何一行。</p><p>然而，显而易见的解决方案并不总是可行。很多原因导致项目无法采用库。首先，许多库不是免费的，库的成本可能过高，特别是如果许可证除了开发费用外还有使用费用。其次，库的许可证可能与项目的许可证不兼容。例如，也许您正在构建一个封闭源代码，但唯一可用的库具有不兼容的开源许可证（反之亦然）。第三，库通常在没有源代码的情况下发布。缺少源代码使得扩展库的功能变得不可能。第四，您可能需要库的支持，但供应商可能不提供。第五，库可能会随着与您自己不兼容的升级周期发布。第六，库可能与您的工具链不兼容。最后，您正在寻求的功能可能根本没有相应的库。因此，尽管通常使用库是实现可移植性的首选，但还有足够多的反例使我们有必要讨论如何在不使用库的情况下实现可移植性。</p><h4 id="7-3-3-2-原始预处理器指令">7.3.3.2 原始预处理器指令</h4><p>在尝试实现跨平台代码时，使用原始预处理器指令无疑是首先尝试的方法。几乎所有编写过可移植代码的人可能都是从这种方法开始的。简单地说，在出现平台相关代码的地方，将平台特定部分用预处理器#ifdef指令包围起来。以Linux和Windows中共享库的运行时加载为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> POSIX</span></span><br><span class="line"><span class="type">void</span>* handle = <span class="built_in">dlopen</span>(<span class="string">&quot;libPlugin.so&quot;</span>, RTLD_LAZY);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> WIN32</span></span><br><span class="line">HINSTANCE handle = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;Plugin.dll&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>不要忘记也要围绕头文件使用预处理器指令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> POSIX</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>对于少量的平台或很少的实例，使用原始预处理器指令是可以忍受的。然而，这种技术扩展性很差。一旦平台数量或需要平台相关代码的代码位置数量增加，使用原始预处理器指令很快就会变得混乱。代码变得难以阅读，当添加新平台时，找到所有平台相关位置变得非常困难。即使在一个中等规模的项目中，源代码中充斥着#ifdefs也很快变得难以维护。</p><h4 id="7-3-3-3-（稍微）更聪明的预处理器指令">7.3.3.3 （稍微）更聪明的预处理器指令</h4><p>在平台API在名称上有所不同，但在函数调用参数上相同（这比您预期的更常见，因为类似的功能，不足为奇地，需要类似的定制）的情况下，我们可以在使用预处理器时更加聪明一些。我们可以创建依赖于平台的宏名称，并在集中位置定义它们，而不是将预处理器指令放在每个平台相关的函数调用和类型声明的位置。通过一个例子来更好地解释这个想法。让我们看一下在Linux和Windows上关闭共享库：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some common header defining all platform dependent analogous symbols</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> POSIX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE void*</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOSE_LIBRARY dlclose</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOSE_LIBRARY FreeLibrary</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE HINSTANCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// in the code, for some shared library HANDLE handle</span></span><br><span class="line"><span class="built_in">CLOSE_LIBRARY</span>(handle);</span><br></pre></td></tr></table></figure><p>与在每个函数调用中使用#ifdefs的简单方法相比，这种技术要干净得多。然而，它仅适用于具有相同参数的函数调用，其局限性很大。显然，对于打开共享库的调用，我们仍然需要在调用位置使用#ifdef，因为POSIX调用需要两个参数，而Windows调用只需要一个。当然，借助C++的抽象功能，我们可以做得更好。</p><h4 id="7-3-3-4-构建系统解决方案">7.3.3.4 构建系统解决方案</h4><p>一开始看起来很有吸引力的一个有趣想法是将特定于平台的代码分离到特定于平台的源文件中，然后使用构建系统根据平台选择正确的文件。让我们考虑一个例子。将所有Unix特定的代码放在一个名为UnixImpl.cpp的文件中，将所有Windows特定的代码放在一个名为WindowsImpl.cpp的文件中。在每个相应的平台上，编写构建脚本以仅编译适当的平台特定文件。使用这种技术，不需要平台预处理器指令，因为任何给定的源文件只包含一个平台的源代码。</p><p>上述方案存在两个明显的缺点。首先，该方法只有在您在所有平台的所有平台特定文件中保持相同的接口（例如，函数名、类名、参数列表）时才有效。这个壮举说起来容易做起来难，尤其是当您有独立的团队在每个平台上工作和测试时。更糟糕的是，由于编译器在任何给定时间只能看到一个平台的代码，因此没有语言机制（例如类型系统）来强制执行这些跨平台接口约束。其次，实现跨平台兼容性的机制对于在单个平台上检查源代码的任何开发者来说是完全不透明的。在任何一个平台上，只有一个平台相关的源文件真正存在，而这个源文件没有提供其他文件存在的任何提示。当然，这后一个问题加剧了前一个问题，因为缺乏跨平台源代码透明性以及缺乏对该技术的语言支持使得维护接口一致性几乎不可能。因此，纯构建系统解决方案是棘手的。</p><p>在注意到这种技术的缺点之后，我们必须小心不要抛弃可取之处，因为我们最终解决方案的核心在于一个由语言支持的机制，既包括预处理器解决方案，也包括构建系统解决方案。这种设计技术将在以下部分进行讨论。</p><h4 id="7-3-3-5-平台工厂函数">7.3.3.5 平台工厂函数</h4><p>在代码中随处使用预处理器宏以实现平台特定功能类似于使用整数标志和switch语句执行特定于类型的代码。并非巧合的是，两个问题都有相同的解决方案，即构建一个抽象类层次结构并通过多态性执行特定功能。</p><p>我们将分两步构建设计一个通用跨平台架构的解决方案。首先，我们将设计一个用于处理动态加载的平台层次结构。其次，我们将把这个特定的解决方案扩展成一个框架，将平台依赖抽象为一个平台无关的接口。在这两个步骤中，我们将采用一种混合解决方案，通过最小化使用特定于平台的预处理器指令，以类型安全的方式利用构建系统。在此过程中，我们将遇到两个额外的、重要的设计模式：工厂方法和抽象工厂。让我们从检查平台无关的插件动态加载开始。</p><p>为了解决我们的具体问题，我们首先定义一个平台无关的DynamicLoader基类的抽象接口。我们的DynamicLoader只需要做两件事：分配和释放插件。因此，基类可以简单地定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicLoader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DynamicLoader</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Plugin* <span class="title">allocatePlugin</span><span class="params">(<span class="type">const</span> string&amp; pluginName)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">deallocatePlugin</span><span class="params">(Plugin*)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述基类的设计意图是，层次结构将根据平台进行特化。</p><p>请注意，接口本身是平台无关的。平台相关的分配和释放是通过虚拟函数由该接口的平台特定派生类处理的实现细节。此外，因为每个平台特定的实现都完全包含在一个派生类中，所以将每个派生类放在一个单独的文件中，我们可以使用构建系统有选择地仅编译每个平台相关的文件，从而避免在层次结构中任何地方使用平台预处理器指令。更好的是，一旦分配了一个DynamicLoader，接口就会抽象出插件加载的平台特定细节，插件的使用者不需要关心插件加载的细节。加载就能正常工作。对于DynamicLoader派生类的实现者，编译器可以使用类型信息来强制执行跨平台的接口一致性，因为每个派生类必须符合抽象基类所指定的接口，这是所有平台通用的。设计总结如图7-1所示。pdCalc的源代码实现了针对POSIX兼容系统和Windows的平台特定加载器。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/A454125_1_En_7_Fig1_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图7-1 平台无关插件分配和回收的动态加载器层次结构    </div></center><p>上述设计将平台特定细节隐藏在抽象接口后面，减轻了插件使用者了解插件加载方式的需求。当然，这是基于插件使用者实例化正确的平台特定派生类，而这是DynamicLoader层次结构无法自动处理的。在这里，我们引入了一个新的设计模式，工厂函数，来解决实例化正确派生类的问题。简单来说，工厂函数是一种将类型创建与实例化的逻辑点分离的模式。</p><p>在继续之前，我应该指出工厂函数与Gang of Four[6]定义的工厂方法模式之间的语义差异。简单来说，工厂方法模式通过一个单独的类层次结构实现一个工厂。更一般地说，工厂是将特定派生类在层次结构中的选择与逻辑实例化点分离的任何机制。工厂函数是由单个函数组成的工厂，而不是单独的创建层次结构。</p><p>通常，工厂是通过调用一个函数实现的，该函数接受一个标志（整数、枚举、字符串等）来限定层次结构的特化，并返回一个基类指针。让我们来看一个人工示例。假设我们有一个由Circle、Triangle和Rectangle派生的Shapes层次结构。此外，假设我们定义了以下枚举类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShapeType</span> &#123;Circle, Triangle, Rectangle&#125;;</span><br></pre></td></tr></table></figure><p>以下工厂函数可以用于创建形状：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Shape&gt; <span class="title">shapeFactory</span><span class="params">(ShapeType t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> ShapeType::Circle:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Circle&gt;();</span><br><span class="line">        <span class="keyword">case</span> ShapeType::Triangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Triangle&gt;();</span><br><span class="line">        <span class="keyword">case</span> ShapeType::Rectangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Rectangle&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过以下函数调用创建一个Circle：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s = <span class="built_in">shapeFactory</span>(ShapeType::Circle);</span><br></pre></td></tr></table></figure><p>为什么上述构造比输入更有用呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s = <span class="built_in">make_unique</span>&lt;Circle &gt;();</span><br></pre></td></tr></table></figure><p>实际上，它并没有。然而，考虑一个接受字符串参数而不是枚举类型的工厂函数（用一系列if语句替换switch语句）。我们现在可以用以下语句构造一个Circle：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s = <span class="built_in">shapeFactory</span>(<span class="string">&quot;circle&quot;</span>);</span><br></pre></td></tr></table></figure><p>与直接使用类名实例化相比，上述构造更有用，因为可以将shapeFactory()的字符串参数的值发现推迟到运行时。简单工厂方法的典型用法如上所述，是使定义实例化哪个特化的条件出现在配置文件或输入文件中。</p><p>在我们的例子中，工厂更简单。由于我们的层次结构是根据平台进行特化的，因此我们不需要传入一个标志来选择适当的派生类，而是通过使用预处理器指令进行选择，如清单7-1所示。</p><p>清单7-1 动态加载器工厂函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;DynamicLoader&gt; <span class="title">dynamicLoaderFactory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> POSIX</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;PosixDynamicLoader&gt;();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> WIN32</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;WindowsDynamicLoader&gt;();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将dynamicLoaderFactory()函数编译到它自己的源文件中，我们可以通过将一组预处理器指令隔离在一个源文件中实现平台无关的插件创建。然后调用工厂函数，在需要插件分配或释放的地方返回正确类型的DynamicLoader。通过让工厂返回一个unique_ptr，我们不需要担心内存泄漏。以下代码片段说明了DynamicLoader的平台无关用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Question: What plaform?</span></span><br><span class="line"><span class="keyword">auto</span> loader = <span class="built_in">dynamicLoaderFactory</span>();</span><br><span class="line"><span class="comment">// Answer: Who cares?</span></span><br><span class="line"><span class="keyword">auto</span> plugin = (loader ? loader-&gt;<span class="built_in">allocatePlugin</span>(pluginName) : <span class="literal">nullptr</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于pdCalc的目的，我们可以使用DynamicLoader层次结构和简单的工厂函数来停止。我们只需要抽象一个依赖于平台的特性（插件的分配和释放），上面的代码就足够了。然而，我们已经走到这一步，值得再迈出一步，看看适用于需要多个不同平台相关特性的情况的平台独立性的通用实现，即使我们的案例研究并不特别需要它。</p><h4 id="7-3-3-6-用于通用平台无关代码的抽象工厂">7.3.3.6 用于通用平台无关代码的抽象工厂</h4><p>作为软件开发人员，我们经常面临由于平台依赖性而导致的设计挑战。以下是C<ins>开发人员常见的平台特定编程任务的不完全列表：插件加载、进程间通信、文件系统导航（在C</ins>17中标准化）、图形、线程（在C<ins>11中标准化）、持久设置、二进制序列化、内置数据类型的sizeof()、计时器（在C</ins>11中标准化）和网络通信。此列表中的大部分（如果不是全部）功能都可以通过诸如boost或Qt这样的库中的平台无关API获得。对我个人而言，导致最多麻烦的平台特定功能是简单的目录分隔符（在Posix系统上是/，在Windows系统上是\）。</p><p>假设我们的计算器需要具有读取、写入和保存持久自定义设置的功能（请参阅第8章了解计算器可能需要这个功能的一些原因）。通常，Linux系统将设置保存在文本文件中（例如，在Ubuntu上，用户设置保存在家目录的.config目录中的文件中），而在Windows系统上，持久设置保存在系统注册表中。实际上，最好的解决方案是使用已经实现了这种抽象的现有库（例如，Qt的QSettings类）。为了教学目的，我们假设没有外部库可用，我们将研究一种在现有动态加载器旁边添加持久设置（或任意数量的平台相关功能）的设计。我们关注的是抽象，而不是每个平台上设置实现的细节。</p><p>简单的解决方案是依赖我们的动态加载器，并直接将必要的设置接口添加到DynamicLoader类中。当然，我们需要将类重命名为更通用的名称，例如OsSpecificFunctionality，以及派生类如LinuxFuntionality和WindowsFunctionality。这种方法简单、快速、很快就无法解决；它与内聚性背道而驰。对于任何大型代码，这种技术最终会导致无法控制的膨胀，从而导致接口的完全无法维护。尽管项目上的时间压力，我建议始终避免这种快速解决方案，因为它只会增加你的技术债务，并导致未来比现在使用合适的解决方案所经历的更长的延迟。</p><p>与其让我们现有的DynamicLoader类变得臃肿，我们不如从其设计中汲取灵感，创建一个单独的、类似的设置层次结构，如图7-2所示。同样，我们面临在每个独特平台上实例化特定于平台的派生类的问题。然而，我们不是添加一个额外的settingsLoaderFactory()函数来反映现有的dynamicLoaderFactory()函数，而是寻求一个通用解决方案，该解决方案能够在保留平台选择的单个代码点的同时实现无限的功能扩展。正如预期的那样，我们并不是第一批遇到这个特定问题的程序员，已经存在一个解决方案：抽象工厂模式。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/A454125_1_En_7_Fig2_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图7-2 针对平台无关持久设置的设置层次结构  </div></center><p>根据Gamma等人[6]，抽象工厂“提供了一个用于创建相关或依赖对象族的接口，而无需指定其具体类。”本质上，该模式可以分为两个步骤构建：</p><ol><li class="lvl-3"><p>为每个相关对象（例如，一个动态加载器层次结构和一个设置层次结构，它们通过平台依赖性关联）创建独立的层次结构（族）。</p></li><li class="lvl-3"><p>创建一个专门针对依赖关系（例如，平台）的层次结构，为每个族提供工厂函数。</p></li></ol><p>在没有具体示例的情况下，我发现上述抽象非常难以理解；因此，让我们考虑我们在pdCalc中试图解决的问题。当你浏览这个示例时，请参考图7-3中的（过于复杂的）类图。回顾一下，这个抽象的总体目标是创建一个单一的源位置，能够为创建任意数量的特定于平台的专门化提供平台无关的机制。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/7.Plugins/A454125_1_En_7_Fig3_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图7-3 将抽象工厂模式应用于pdCalc  </div></center><p>正如我们已经看到的，平台相关的功能可以抽象为并行的、独立的层次结构。这些层次结构使得通过多态性通过平台无关的基类接口访问平台相关的实现成为可能。对于pdCalc，这种模式转化为提供平台不可知的Settings和DynamicLoader层次结构，分别抽象持久性设置和动态加载。例如，我们可以通过抽象的DynamicLoader接口多态地分配和释放插件，前提是系统根据平台实例化正确的底层派生类（PosixDynamicLoader或WindowsDynamicLoader）。抽象工厂的这一部分由图7-3中的DynamicLoader层次结构表示。</p><p>现在的问题缩小为根据当前平台实例化正确的派生类。我们不是提供单独的工厂函数来实例化DynamicLoader和Settings对象（这是一种分散的方法，需要在每个工厂中分别使用平台的#ifdefs），而是创建一个层次结构，为创建DynamicLoader和Settings对象提供必要的工厂函数的抽象接口。然后，该抽象工厂层次结构（图7-3中的PlatformFactory层次结构）针对平台进行专门化，以便我们拥有工厂层次结构的平台特定派生类，创建功能层次结构的平台特定派生类。这种方案将平台依赖性集中到一个实例化正确的PlatformFactory专门化的工厂函数中。在pdCalc的实现中，我选择将PlatformFactory设为单例，从而在Instance()函数中“隐藏”PlatformFactory的工厂函数。</p><p>抽象工厂模式可能仍然没有多少意义，所以让我们看一些示例代码，从上到下查看抽象。归根结底，抽象工厂模式使我们能够在pdCalc中编写以下平台无关的高级代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PlatformFactory Instance returns either a PosixFactory or a</span></span><br><span class="line"><span class="comment">// WindowsFactory instance (based on the platform), which in turn</span></span><br><span class="line"><span class="comment">// creates the correct derived DynamicLoader</span></span><br><span class="line"><span class="keyword">auto</span> loader = PlatformFactory::<span class="built_in">Intance</span>().<span class="built_in">createDynamicLoader</span>();</span><br><span class="line"><span class="comment">// The correctly instantiated loader provides platform specific</span></span><br><span class="line"><span class="comment">// dynamic loading functionality polymorphically through a platform</span></span><br><span class="line"><span class="comment">// independent interface</span></span><br><span class="line"><span class="keyword">auto</span> plugin = loader-&gt;<span class="built_in">allocatePlugin</span>(pName);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">loader-&gt;<span class="built_in">deallocatePlugin</span>(plugin);</span><br><span class="line"><span class="comment">// Same principle for settings ...</span></span><br><span class="line"><span class="keyword">auto</span> settings = PlatformFactory::<span class="built_in">Instance</span>().<span class="built_in">createSettings</span>();</span><br><span class="line">settings-&gt;<span class="built_in">readSettingsFromDisk</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">settings-&gt;<span class="built_in">commitSettingsToDisk</span>();</span><br></pre></td></tr></table></figure><p>深入挖掘，我们首先要检查的是PlatformFactory的Instance()函数，根据平台返回PosixFactory或WindowsFactory。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PlatformFactory&amp; <span class="title">PlatformFactory::Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> POSIX</span></span><br><span class="line"><span class="type">static</span> PosixFactory instance;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> WIN32</span></span><br><span class="line"><span class="type">static</span> WindowsFactory instance;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数在执行一些微妙但聪明的操作，这是一个值得了解的技巧。从客户端的角度来看，PlatformFactory看起来像一个普通的单例类。调用Instance()函数，返回一个PlatformFactory引用。然后，客户端像使用任何其他单例类一样使用PlatformFactory的公共接口。然而，由于Instance()成员函数返回一个引用，我们可以自由地多态地使用该实例。由于PosixFactory和WindowsFactory都继承自PlatformFactory，实例化的实例变量是与由实现中的#ifdef定义的平台匹配的专门化。我们巧妙地掩饰了一个实现细节，抽象工厂模式的机制，从类的用户中。除非客户端注意到PlatformFactory中的工厂函数是纯虚函数，否则他可能不会意识到他正在使用面向对象的层次结构。当然，目标不是在一个邪恶的计划中向用户隐藏任何东西以模糊实现。相反，这种信息隐藏是为了减轻PlatformFactory客户端的复杂性负担。</p><p>接下来我们检查PosixFactory和WindowsFactory类中createDynamicLoader()函数的简单实现（注意函数的协变返回类型）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;DynamicLoader&gt; <span class="title">PosixFactory::createDynamicLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;PosixDynamicLoader&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">unique_ptr&lt;DynamicLoader&gt; <span class="title">WindowsFactory::createDynamicLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;WindowsDynamicLoader&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面，我们仅仅用一个类层次结构替换了动态加载器工厂函数（见清单7-1），用多态性替换了平台的#ifdefs。对于只有一个功能依赖于平台的情况，用抽象工厂替换工厂函数肯定是过犹不及。然而，在我们的示例中，我们有独立的DynamicLoader和Settings家族，它们都依赖于相同的平台标准（原则上，我们可以有任意数量的这样的层次结构），抽象工厂模式允许我们将平台依赖性集中在一个位置（这里是PlatformFactory的Instance()函数），而不是将其分散在多个独立的工厂函数中。从维护的角度来看，价值主张类似于多态性优于switch语句。</p><p>谜题的最后一部分是DynamicLoader和Settings层次结构的实现。幸运的是，这些实现与第7.3.3节中概述的想法相同，我在这里不需要重复它们的实现。实际上，抽象工厂模式并不增加对平台相关功能实现的固有复杂性。该模式仅在一个工厂层次结构中添加了通过单个工厂层次结构而不是一系列工厂函数实例化这些类的机制。</p><p>在pdCalc的代码库中的源代码中，没有Settings层次结构（或者其在PlatformFactory中关联的readSettingsFromDisk()和commitSettingsToDisk()函数）的实现，因为就像编写的pdCalc一样，没有需要持久设置抽象。Settings层次结构仅仅是作为一个合理的例子来具体展示抽象工厂模式的机制和相关性。也就是说，我确实选择在pdCalc的代码中为DynamicLoader单独包含一个完整的抽象平台工厂实现，只是为了说明抽象工厂模式的实际实现，尽管一个更简单的单一工厂函数就足够了，而且更适合生产代码。</p><h2 id="7-4-问题3：重构pdCalc">7.4 问题3：重构pdCalc</h2><p>现在我们来看最后一个插件问题，即重构已开发的类和接口以适应动态添加计算器功能。这个问题与插件管理无关。相反，我们在这里要解决的问题是扩展pdCalc的模块接口以接受插件功能。本质上，第7.2节定义了如何在插件中发现命令和按钮，这一节描述了如何将这些新发现的命令整合到pdCalc中。</p><p>让我们首先创建一个接口，以便在注入新发现的插件命令时启用。回顾第4章，当应用程序启动时，核心命令是如何加载到CommandRepository中的。首先，主应用程序调用RegisterCoreCommands()函数。其次，在此函数中，对于每个核心命令，调用CommandRepository类的registerCommand()函数，将命令的名称和命令原型注册到CommandRepository。在第7.2节中，我们开发了一个用于从插件中导出命令名称和命令原型的接口。显然，要注册这些插件命令，我们只需扩展命令调度模块的接口，包括registerCommand()函数。然而，这种接口扩展引发了一个有趣的问题。在C++这样一个没有正式模块定义的语言中，扩展模块接口意味着什么？</p><h4 id="7-4-1-模块接口">7.4.1 模块接口</h4><p>迄今为止，我们尚未严格定义实现或描述模块的机制。我们只是宽松地声明某些类是某些模块的一部分（例如，CommandRepository是命令调度器模块的一部分）。但这实际上意味着什么？C++语言，就目前而言，并未实现模块概念。因此，模块本质上是一种元语言概念，而语言本身在强制执行模块接口方面提供了很少的帮助。然而，我们确实有一些基本的选项来定义模块及其接口。首先，将不直接作为接口的所有类封装在一个源文件中，并仅在单个头文件中公开有限的模块接口。其次，将每个模块构建到一个单独的DLL中，并使用DLL符号导出机制来有选择性地导出接口函数。第三，通过文档和注释中的声明隐式地定义模块边界。让我们来探讨这些选项。</p><h4 id="7-4-1-1-源代码隐藏">7.4.1.1 源代码隐藏</h4><p>让我们从讨论C程序员一直可用的封装模型开始：在源文件中隐藏非公共接口类和函数，不在头文件中公开它们的接口。这是C++为真正隐藏符号提供的唯一机制（请记住，访问修饰符，如private，不能用于类本身，就像在Java或C#中可能的那样）。您已经在pimpl模式背后看到了这种机制用于隐藏类细节。</p><p>在模块级别，这种封装方案意味着一个模块的所有源代码必须驻留在一个单独的源文件中，只有模块接口的公共部分会出现在一个单独的模块头文件中。例如，对于pdCalc的命令调度模块，只有CommandDispatcher和Command接口会出现在一个单独的头文件中，而CommandDispatcher类的定义以及所有具体命令、CommandRepository和CommandManager的声明和定义将驻留在一个单独的源文件中。源代码隐藏的最大缺点是，对于复杂的模块，它可能导致非常大的单个文件。大型文件由于体积庞大而难以阅读，并且由于模块中的任何更改都需要重新编译所有代码，因此即使是最小的更改也会导致漫长的编译时间。这种技术的优点是它可以在C++语言中原生实现，而且不需要每个模块驻留在一个单独的动态链接库中。</p><p>我亲自见过至少一个开源软件包采用这种策略。从技术角度看，虽然它确实实现了模块接口的隐藏，但结果是整个库分布在一个单独的头文件和一个单独的源文件中。头文件超过3000行，源文件接近20000行。我无法想象这种解决方案在可读性或可维护性方面是否被优化设计。据我所知，这个开源软件包只有一个作者。因此，对于一个开发者团队来说，可读性和可维护性不太可能是他的主要目标。</p><h4 id="7-4-1-2-DLL隐藏">7.4.1.2 DLL隐藏</h4><p>如果您使用C++，拥有大型代码库，并希望真正隐藏模块接口，使用DLL隐藏是最合理的选择。当然，使用这个选项超出了C++语言本身的范畴。DLL隐藏基于操作系统的库格式，并通过编译器指令实现。本质上，程序员用特殊的编译器指令修饰类或函数，以指示是否要从DLL中导入或导出函数。编译器然后创建一个只公开导出适当标记的符号的DLL，链接到DLL的代码必须指定它打算导入的符号。由于在编译DLL时，同一个头文件需要标记为导出，而在编译使用DLL的代码时需要标记为导入，因此实现通常是通过使用特定于编译器/操作系统的预处理器指令来完成的。例如，在Windows中，会使用以下代码（或类似的变体）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declspec .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BUILDING_DLL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLSPEC __declspec(export)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLSPEC __declspec(import)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>我们想要从DLL中导出的函数foo()的声明应该写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Declspec.h&quot;</span></span></span><br><span class="line"><span class="function">DECLSPEC <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>当构建DLL时，预处理器宏BUILDING_DLL被定义；因此，DECLSPEC宏展开为__declspec(export)。当使用DLL时，BUILDING_DLL宏未定义，DECLSPEC宏展开为__declspec(import)。任何未用DECLSPEC宏修饰的函数或类都保持为DLL的私有。GCC使用略有不同的语法实现类似的机制。</p><p>大多数Windows程序员非常熟悉用于控制模块接口的DLL隐藏机制，因为在Visual Studio中，全局隐藏DLL中的符号是默认范例。如果一个符号没有修饰，它将不会从DLL中导出。因此，为了制作一个可以从外部调用的DLL（还有其他种类吗？），Windows程序员必须使用__declspec指令手动导出符号。然而，许多UNIX程序员对DLL隐藏并不熟悉，因为默认的共享库实现公开导出所有符号。也就是说，在典型的UNIX或Linux系统中，共享库代码中没有必要将符号修饰为导出或导入，因为当共享库加载时，链接器会将共享库中的所有符号公开提供给调用程序。如果需要，编译器命令行选项可以将默认可见性从公共更改为私有，并且可以手动标记符号以类似于Windows构建的方式导入或导出。</p><p>我开始这一节时说，如果你想要真正隐藏大型C<ins>代码库中模块接口，使用DLL隐藏是最合理的选择。只要你愿意为每个模块分配一个单独的DLL，它可以为模块访问控制提供非常精细的粒度。这种技术的主要缺点在于可读性、可维护性和可移植性。使用这种技术确实需要为每个可导出的函数使用编译器和操作系统特定的装饰器，这些装饰器并不是C</ins>语言的一部分。尽管对于每个函数或类来说，额外的DECLSPEC宏并不是难以忍受的，但在考虑多个操作系统或多个编译器时，宏的定义可能很快变得难以处理。此外，当构建或使用DLL时忘记定义正确的预处理器宏可能会让初学者感到困惑。最后，在模板代码存在的情况下正确实现DLL导入和导出可能并非易事。</p><h4 id="7-4-1-3-隐式或文档隐藏">7.4.1.3 隐式或文档隐藏</h4><p>我所说的隐式隐藏技术实际上就是通过不记录接口来隐藏它。实际操作中，这意味着什么呢？由于C++语言不直接支持模块，隐式隐藏只是在一组类和函数周围绘制一个逻辑结构，并声明这些类组成一个模块。语言允许从模块外部的代码调用任何类的公共函数。因此，模块的公共接口是通过仅记录应该从外部调用的函数来“声明”的。从纯技术角度来看，隐式隐藏根本不是隐藏！</p><p>为什么有人会选择隐式隐藏而不是源代码隐藏或DLL隐藏呢？很简单，这个选择是出于方便。使用隐式隐藏允许开发者以逻辑、可读和可维护的方式组织类和源代码。每个类（或一组紧密相关的类）可以分组到自己的头文件和源文件对中。这使得只包含必要的代码，从而加快编译时间。隐式隐藏还不强制将包含的边界定义纳入特定的共享库，如果设计目标是最小化与软件包一起发布的单个共享库的数量，这可能很重要。</p><p>当然，隐式隐藏的问题在于，没有语言机制可以防止在逻辑模块之外使用设计师未打算使用的函数和类。这是一个严重的问题吗？为什么我们可能想强制阻止用户调用部分被认为不是公共的接口？主要的设计原因是，我们不希望用户依赖于未记录的功能，因为非公共接口可能会发生变化。不出所料，这个原因与我们珍视类设计中的封装的原因是一样的。也就是说，实现应该允许独立于接口进行更改。那么，强制隐藏非公共接口有多重要呢？最终，这取决于你是否信任你的代码的用户，他们要么不调用未记录的接口，要么至少接受由于对未记录接口的更改而强制进行的非计划性维护的所有权。</p><h4 id="7-4-1-4-pdCalc的模块设计">7.4.1.4 pdCalc的模块设计</h4><p>在pdCalc的设计中，我选择使用隐式隐藏。对于这个项目，我认为简单性的优势超过了使用其他模块接口隐藏方式所需的复杂性。你为自己的项目选择哪种技术自然取决于你的个人喜好。鉴于pdCalc相对较小的代码库，使用隐式隐藏可以使类按逻辑分组，而不是沿着模块边界分组。此外，隐式隐藏允许将几个模块（例如，命令调度器、堆栈和插件管理）合并到一个共享的后端库中。</p><p>我选择使用隐式隐藏对解决将命令调度器模块接口扩展到包含CommandRepository类的registerCommand()函数的原始问题有直接影响。这种扩展可以通过文档更改简单地实现。从本质上讲，可以通过更新第2章中的表2-2将此函数添加到接口中。</p><p>隐式隐藏没有特定的语言支持功能，所以你不能指向一个特定的类并说：“这个头定义了模块的接口。”相反，文档用于在选定的公共类和函数周围画出一个隐式的线条，这些类和函数定义了模块的接口。因此，一旦文档被更改，main() 函数可以在插件加载过程中通过调用 CommandRepository 的现有 registerCommand() 函数注入插件命令。为了使 pdCalc 支持插件命令注入，无需更改代码。</p><h3 id="7-4-2-向GUI添加插件按钮">7.4.2 向GUI添加插件按钮</h3><p>回顾一下本节开始时，我们概述了在为插件改装 pdCalc 时要解决的两个问题。第一个问题，我们刚刚解决了，是在加载插件后如何将插件命令添加到 CommandRepository。解决方案事实上非常简单，因为我们已经编写了必要的函数，只需要扩展模块定义的公共接口。第二个问题涉及改装 pdCalc，使其能够将与插件命令相对应的按钮添加到 GUI。</p><p>根据我们的命令调度器的设计，一旦命令被注册，任何用户界面都可以通过将命令的名称作为事件的参数来触发 commandEntered() 事件来执行它。因此，对于 CLI，用户可以通过键入其名称来执行插件命令。也就是说，一旦注册了插件命令，它们就立即可以在 CLI 中使用。当然，在 GUI 中访问插件命令稍微复杂一些，因为每个发现的插件命令都必须创建一个可以触发 commandEntered() 事件的按钮。</p><p>在第7.2节中，我们定义了一个用于标记 CommandButtons 的接口。每个插件提供一个 PluginButtonDescriptor，定义主要命令标签、次要命令标签以及与标签关联的底层命令。因此，为了添加一个与插件命令对应的新 GUI 按钮，我们只需扩展 GUI 的 MainWindow 类的接口，包括根据标签添加按钮的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow, <span class="keyword">public</span> UserInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Existing interface plus the following:</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCommandButton</span><span class="params">(<span class="type">const</span> string&amp; dispPrimaryCmd,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> string&amp; primaryCmd, <span class="type">const</span> string&amp; dispShftCmd,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> string&amp; shftCmd)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，这个功能还需要根据某种合适的算法来布局按钮。我的简单算法只是将按钮从左到右排列，每行放置四个按钮。</p><p>正如在第6章简要提到的，MainWindow 类还包括一个 setupFinalButtons() 函数和一个 fixSize() 函数。setupFinalButtons() 函数将撤消、重做和 proc（见第8章）按钮作为 GUI 的顶行添加。fixSize() 函数强制使 GUI 的几何形状保持在当前尺寸固定。只有在添加了所有插件按钮之后，才能逻辑上调用这些操作。</p><p>与 CommandRegistry 的 registerCommand() 函数不同，addCommandButton() 不是 MainWindow 类的预先存在的公共函数。因此，我们必须添加并实现这个新功能。很可能，一个模块化的 GUI 实现已经在 GUI 模块中的某个地方有了类似的功能，因为创建核心命令按钮已经需要这个功能。因此，实现 addCommandButton() 函数可能就像从 MainWindow 向适当的内部 GUI 类转发此调用一样简单，在那里该功能可能已经存在。</p><h2 id="7-5-整合插件">7.5 整合插件</h2><p>到目前为止，我们已经讨论了 C++ 插件的指南、插件接口、插件命令内存管理、加载和卸载插件、通过接口抽象平台相关代码的设计模式以及改装 pdCalc 以启用插件命令和 GUI 注入。然而，我们尚未讨论查找插件、从磁盘实际加载和卸载插件、管理插件的生命周期或将插件功能注入 pdCalc 的任何机制。这些操作由 PluginLoader 类和应用程序的 main() 函数执行，现在将进行描述。</p><h3 id="7-5-1-加载插件">7.5.1 加载插件</h3><p>通过 PluginLoader 类实现插件的加载。PluginLoader 负责查找插件动态库文件，将插件加载到内存中，并根据需求将具体的 Plugin 专门化提供给 pdCalc。PluginLoader 还负责在适当的时候释放插件资源。正如我们之前看到的，良好的设计将通过 RAII 实现自动释放。</p><p>加载插件的第一步是确定应该加载哪些插件以及何时加载。实际上，回答这个问题只有两个实际选项。插件是在程序启动时由 pdCalc 自动加载（例如，配置文件中指定的文件或特定目录中的所有 DLL），还是根据用户的直接请求按需加载。当然，这些选项并不是互斥的，可以设计一个 PluginLoader 类，结合这两个选项，可能还具有让用户指导将来自动加载哪些手动加载的插件的功能。如何加载插件没有正确或错误的答案。这个决定必须根据程序的需求来解决。</p><p>为了简单起见，我选择实现一个在 pdCalc 启动期间自动加载插件的插件加载器。PluginLoader 通过读取一个由每行文本单独列出插件文件名的 ASCII 配置文件来找到这些插件。配置文件被任意命名为 plugins.pdp，该文件必须位于当前可执行路径中。在 plugins.pdp 中列出的插件文件可以使用相对路径或绝对路径来指定。一个更复杂的插件加载器实现可能会将插件文件的位置存储在操作系统特定的配置位置（例如，Windows 注册表），并使用更好的文件格式，如 XML。像 Qt 这样的好库可以帮助您解析 XML 并使用平台无关的抽象来查找特定于系统的配置文件。</p><p>考虑到上述插件加载器设计约束，PluginLoader 接口非常简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PluginLoader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadPlugins</span><span class="params">(UserInterface&amp; ui, <span class="type">const</span> string&amp; pluginFileName)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> vector&lt;<span class="type">const</span> Plugin*&gt; <span class="title">getPlugins</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>loadPlugins() 函数将配置文件的名称作为输入，将每个库加载到内存中，并为每个库的 Plugin 类分配一个实例。UserInterface 引用仅用于错误报告。当 main() 函数准备好注入插件命令时，调用 getPlugins() 函数返回已加载插件的集合。当然，loadPlugins() 和 getPlugins() 函数可以合并，但我更喜欢一种能让程序员保留更精细的插件加载与插件使用时机控制的设计。我的 PluginLoader 实现使用了一些巧妙的技巧，利用 RAII 管理插件自动释放。由于这里的实现与设计无关，有兴趣的读者可以参考 PluginLoader.cpp 源文件了解详细信息。</p><h3 id="7-5-2-注入功能">7.5.2 注入功能</h3><p>决定插件应该从配置文件自动加载后，插件加载在 main() 函数调用树中的最佳位置。从本质上讲，这个 loadPlugins() 函数只是将我们之前讨论过的所有部分组合在一起：加载插件库、加载插件、从插件描述符中提取命令和按钮，并将这些命令和按钮注入 pdCalc。当然，一个合适的实现还会对插件进行错误检查。例如，错误检查可能包括检查插件 API 版本、确保命令尚未注册以及确保 GUI 按钮与命令存储库中的命令相对应。Listing 7-2 是加载插件功能的一个框架。它的输入是一个用于报告错误的 UserInterface 引用和一个 PluginLoader 引用。</p><p>Listing 7-2 加载插件的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setupPlugins</span><span class="params">(UserInterface&amp; ui, PluginLoader&amp; loader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loader.<span class="built_in">loadPlugins</span>(ui, <span class="string">&quot;plugins.pdp&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> plugins = loader.<span class="built_in">getPlugins</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : plugins) &#123;</span><br><span class="line">        <span class="keyword">auto</span> apiVersion = p-&gt;<span class="built_in">apiVersion</span>();</span><br><span class="line">        <span class="comment">// verify plugin API at correct level</span></span><br><span class="line">        <span class="comment">// inject plugin commands into CommandRepository - recall</span></span><br><span class="line">        <span class="comment">// the cloned command will auto release in the plugin</span></span><br><span class="line">        <span class="keyword">auto</span> descriptor = p-&gt;<span class="built_in">getPluginDescriptor</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; descriptor.nCommands; ++i) &#123;</span><br><span class="line">            <span class="built_in">registerCommand</span>(ui, descriptor.commandNames[i],</span><br><span class="line">                <span class="built_in">MakeCommandPtr</span>(descriptor.commands[i]-&gt;<span class="built_in">clone</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if gui, setup buttons</span></span><br><span class="line">        <span class="keyword">auto</span> mw = <span class="built_in">dynamic_cast</span>&lt;MainWindow*&gt;(&amp;ui);</span><br><span class="line">        <span class="keyword">if</span> (mw) &#123;</span><br><span class="line">            <span class="keyword">auto</span> buttonDescriptor = p-&gt;<span class="built_in">getPluginButtonDescriptor</span>();</span><br><span class="line">            <span class="keyword">if</span> (buttonDescriptor) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; buttonDescriptor-&gt;nButtons; ++i) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> b = *buttonDescriptor;</span><br><span class="line">                    <span class="comment">// check validity of button commands</span></span><br><span class="line">                    mw-&gt;<span class="built_in">addCommandButton</span>(b.dispPrimaryCmd[i], </span><br><span class="line">                        b.primaryCmd[i], b.dispShftCmd[i], b.shftCmd[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在详细描述如何实现 C++ 插件的长篇章节之后，结局有点反高潮，因为大部分机制在抽象的更深层次上处理。当然，正如你在本书中学到的，这种“无聊”只是通过精心设计实现的。简单性总是比代码本身显示的更难实现。如果在这种高级抽象中出现了任何泄漏，那肯定意味着设计不佳。</p><h2 id="7-6-一个具体的插件">7.6 一个具体的插件</h2><p>在详细讨论如何将原生 C++ 插件整合到 pdCalc 之后，我们终于到了可以实现一个具体插件的地方。根据我们在第 1 章中的需求，我们需要编写一个添加自然对数、其逆指数算法以及双曲三角函数命令的插件。当然，你可以随意添加包含任何你可能喜欢的功能的插件。例如，两个有趣的插件可能是概率插件和统计插件。概率插件可以计算排列、组合、阶乘和随机数，而统计插件可以计算均值、中位数、众数和标准差。然而，现在我们只需考虑双曲线、自然对数插件的设计和实现。</p><h3 id="7-6-1-插件接口">7.6.1 插件接口</h3><p>HyperbolicLnPlugin 的实现实际上非常简单。我们将从类的接口开始，然后，不同寻常地，研究一些实现细节。为进一步研究而选择的代码突出了与原生 C++ 插件相关的特定细节。</p><p>HyperbolicLnPlugin 的接口由特殊化 Plugin 类的类定义以及所需的插件分配和释放函数给出；参见 Listing 7-3。</p><p>Listing 7-3 HyperbolicLnPlugin接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HyperbolicLnPlugin</span> : <span class="keyword">public</span> pdCalc::Plugin &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">HyperbolicLnPluginImpl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HyperbolicLnPlugin</span>();</span><br><span class="line">    ~<span class="built_in">HyperbolicLnPlugin</span>();</span><br><span class="line">    <span class="function"><span class="type">const</span> PluginDescriptor&amp; <span class="title">getPluginDescriptor</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> PluginButtonDescriptor* <span class="title">getPluginButtonDescriptor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    pdCalc::<span class="function">Plugin::ApiVersion <span class="title">apiVersion</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unique_ptr&lt;HyperbolicLnPluginImpl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span>* <span class="title">AllocPlugin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">DeallocPlugin</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"></li></ul><p>正如预期的那样，该类实现了 Plugin 类中的三个纯虚函数，并将大部分实现推迟到一个私有实现类。AllocPlugin() 和 DeallocPlugin() 函数具有显而易见的实现。AllocPlugin() 只需返回一个新的 HyperbolicLnPlugin 实例，而 DeallocPlugin() 函数将其 void* 参数转换为 Plugin*，然后在此指针上调用 delete。注意，插件根据定义不是主程序的一部分，因此不应该是 pdCalc 命名空间的一部分。因此，在某些位置有明确的命名空间限定。</p><p>HyperbolicLnPluginImpl 类的责任仅仅是根据需求提供插件描述符，并管理描述符所需对象的生命周期。PluginDescriptor 提供插件实现的命令名称和相应的命令。这些命令将在下面的第 7.6.3 节中描述。插件的 PluginButtonDescriptor 只需列出由 PluginDescriptor 定义的命令名称以及将出现在 GUI 按钮上的相应标签。因为 HyperbolicLnPlugin 中的命令都有自然的逆，我们只需用前向命令标记每个按钮，并将次要（移位）命令附加到逆。我为插件提供的命令使用了显而易见的标签：sinh、asinh、cosh、acosh、tanh、atanh、ln 和 exp。你选择 ln 作为主要命令，exp 作为次要命令，还是反过来，只是个人喜好问题。</p><p>出于已经讨论过的原因，插件描述符在不使用 STL 容器的情况下传输内容。在接口中，我们通常更喜欢使用向量和 unique_ptrs 来管理资源，但我们被迫使用原始数组。当然，pimpl 提供的封装使得我们可以实现所需的任何内存管理方案。对于 HyperbolicLnPlugin，我选择了一种使用字符串、unique_ptrs 和向量的复杂自动内存管理方案。使用 RAII 内存管理方案的优点是，我们可以确保在异常出现时（即在构造过程中抛出的内存不足异常）插件不会泄漏内存。实际上，我不希望计算器在低内存环境中执行，即使是在这种情况下，插件分配期间泄漏内存也不太可能有什么影响，因为用户在这种情况下可能的下一个操作是重启计算机。因此，回顾起来，在构造函数中使用裸露的 new 和析构函数中的 delete 的更简单的内存管理方案可能更加务实。</p><h3 id="7-6-2-源代码依赖反转">7.6.2 源代码依赖反转</h3><p>令人惊讶的是，上面的 HyperbolicLnPlugin 类声明确实是插件的完整接口。我之所以感到惊讶，是因为乍一看，人们可能会惊讶地发现插件的接口与插件提供的功能之间没有关系。当然，这种情况恰恰是如此。插件提供的计算器功能实际上仅仅是一个实现细节，可以完全包含在插件的实现文件中。</p><p>不应忽视上述微妙之处，即 pdCalc 只知道插件的接口，而对功能本身一无所知。事实上，源代码依赖性反转是插件设计的全部要点。那么，什么是源代码依赖性反转，为什么它如此重要？要回答这个问题，我们必须先进行一次简短的历史回顾。</p><p>传统上（想想20世纪70年代的Fortran），代码是通过简单地编写新函数和子程序来扩展的。这种方法的主要设计问题是，要求主程序调用新函数使主程序与任何扩展的具体接口相绑定。因此，主程序变得依赖于扩展作者定义的接口更改。也就是说，每个新扩展都定义了一个主程序必须遵循的新接口。这种设置非常脆弱，因为主程序需要不断修改以跟上其扩展接口的变化。由于每个新扩展都需要对主程序的源代码进行独特的修改，因此处理扩展的主程序代码的复杂性与扩展数量成线性增长。如果这还不够糟糕的话，添加新功能总是需要重新编译和重新链接主程序。具体而言，想象一下，每次添加新的插件命令时，都需要修改、重新编译和重新链接 pdCalc 的源代码的设计。</p><p>上述问题可以通过函数指针和回调来解决，尽管这种方法有些不优雅和笨拙，但不需要面向对象编程。然而，随着面向对象编程的兴起，特别是继承和多态，依赖问题以一种类型安全的方式得到了语言支持的解决方案。这些技术使源代码依赖性反转的普及成为可能。具体而言，源代码依赖性反转是指主程序定义一个接口（例如，我们在本章中研究的插件接口），所有扩展都必须符合这个接口。根据这种策略，扩展要服从主程序的接口，而不是相反。因此，主程序可以通过插件进行扩展，而无需修改、重新编译或重新链接主程序的源代码。更重要的是，可扩展性的接口是由应用程序而不是插件决定的。具体而言，pdCalc 提供了插件接口类来定义新功能的添加，但 pdCalc 从不了解其扩展的实现细节。不符合 pdCalc 接口的插件根本无法注入新命令。</p><h3 id="7-6-3-实现-HyperbolicLnPlugin-的功能">7.6.3 实现 HyperbolicLnPlugin 的功能</h3><p>在这个阶段，我们知道 HyperbolicLnPlugin 将通过为每个操作实现一个命令类来提供其功能。在实现了一些这样的类之后，人们会很快注意到插件中的所有命令都是一元命令。不幸的是，基于 C++ 插件的第三条规则（假设不兼容的对齐），我们不能继承 UnaryCommand 类，而必须继承 PluginCommand 类。请注意，我们的对齐假设甚至排除了通过多重继承使用 UnaryCommand 类，我们必须在 HyperbolicLnPluginCommand 基类中重新实现一元命令功能。虽然这感觉有点重复，但 C++ 插件的规则让我们没有其他选择（尽管我们可以为 UnaryPluginCommand 和 UnaryBinaryCommand 提供源代码，但这些必须与每个插件单独编译）。</p><p>因此，我们最终得到了 HyperbolicLnPlugin 中所有命令派生的接口类；请参见清单7-4。</p><p>清单7-4 HyperbolicLnPluginCommand 类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HyperbolicLnPluginCommand</span> : <span class="keyword">public</span> pdCalc::PluginCommand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HyperbolicLnPluginCommand</span>() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">HyperbolicLnPluginCommand</span><span class="params">(<span class="type">const</span> HyperbolicLnPluginCommand&amp; rhs)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">HyperbolicLnPluginCommand</span>() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">checkPluginPreconditions</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">HyperbolicLnPluginCommand* <span class="title">clonePluginImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HyperbolicLnPluginCommand* <span class="title">doClone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">unaryOperation</span><span class="params">(<span class="type">double</span> top)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> top_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与 UnaryCommand 类一样，HyperbolicLnPluginCommand 类实现了纯虚拟的 executeImpl() 和 undoImpl() 命令，将命令操作委托给纯虚拟的 unaryOperation() 函数。此外，HyperbolicLnPluginCommand 类实现了 checkPluginPreconditions() 函数，以确保在调用命令之前堆栈上至少有一个数字。该函数受保护，以便子类可以直接覆盖前提条件函数，如果必须实现任何额外的前提条件，同时仍然调用基类的 checkPluginPreconditions() 来进行一元命令前提条件检查。</p><p>deallocate() 和 clonePluginImpl() 函数有明显的实现，但在插件中起着关键作用。deallocate() 函数的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HyperbolicLnPluginCommand::deallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下，deallocate() 函数的目的是强制在插件的编译单元中释放插件命令的内存。当销毁持有命令的 unique_ptr 时，通过 CommandDeleter() 函数调用它。</p><p>clonePluginImpl() 函数如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HyperbolicLnPluginCommand*</span></span><br><span class="line"><span class="function"><span class="title">HyperbolicLnPluginCommand::clonePluginImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HyperbolicLnPluginCommand* p;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        p = <span class="built_in">doClone</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数的唯一目的是适应插件命令的克隆，以确保异常不会跨越插件和主应用程序之间的内存边界。</p><p>完成 HyperbolicLnPlugin 的所有剩余部分是为插件中所需的每个数学操作继承 HyperbolicLnPluginCommand，并实现其余的纯虚拟函数（unaryOperation()、doClone() 和 helpMessageImpl()）。此时，这些函数的实现与第 4 章的一元函数实现无异。有兴趣的读者可以参考 HyperbolicLnPlugin.cpp 中的源代码了解详细信息。</p><h2 id="7-7-下一步">7.7 下一步</h2><p>在关于 C++ 插件的较长讨论之后，并通过实现双曲三角函数和自然对数插件，我们完成了第 1 章中提出的 pdCalc 的需求。按照最初的描述，计算器已经完成！好吧，版本 1.0 已经完成了。然而，作为有经验的软件开发人员，我们知道任何“完成”的产品都只是在客户要求新功能之前的一个临时里程碑。下一章将处理这种情况，我们将修改我们的设计以包含未计划的扩展。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Practical C++ Design From Programming to Architecture 1ed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 命令行接口</title>
      <link href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/"/>
      <url>/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/</url>
      
        <content type="html"><![CDATA[<h1>5. 命令行接口</h1><p>这是一个非常令人兴奋的章节。虽然命令行界面（CLI）可能没有现代图形用户界面（GUI）的噱头，尤其是手机或平板电脑的界面，但 CLI 仍然是一种非常有用且有效的用户界面。本章详细介绍了 pdCalc 的命令行界面的设计和实现。到本章结束时，我们将首次拥有一个功能完善（尽管功能不完整）的计算器，这是我们开发过程中的一个重要里程碑。</p><h2 id="5-1-用户界面抽象">5.1 用户界面抽象</h2><p>虽然我们可以独立设计一个功能完整的 CLI，但我们从需求中了解到，功能完整的计算器必须同时具有 CLI 和 GUI。因此，在首先考虑这两个界面之间的共性并将此功能分解为一个通用抽象之前，我们的整体设计将更好地满足需求。让我们考虑两种构建用户界面抽象的设计替代方案：自上而下的方法和自下而上的方法。</p><p>在考虑具体类型之前设计抽象接口类似于自上而下的设计。在用户界面方面，您首先考虑任何 UI 必须遵循的最基本要素，并根据这个最小化概念创建一个抽象接口。当抽象概念遗漏了实现具体类型所需的内容时，对接口的细化就变得必要。</p><p>在考虑具体类型之后设计抽象接口类似于自下而上的设计。再次以用户界面为例，您首先考虑所有具体类型的需求（在这种情况下是 CLI 和 GUI），寻找所有类型之间的共性，然后将公共特性提炼为一个抽象。当添加一个需要在最初提炼抽象时未考虑的额外功能的新具体类型时，对接口的细化变得必要。</p><p>一般来说，哪种策略更适合创建抽象接口：自上而下还是自下而上？通常情况下，答案取决于特定情况、个人舒适度和风格。在这个特定场景中，我们最好从抽象开始，然后向具体类型（自上而下方法）深入。为什么？在这种情况下，自上而下的方法基本上是免费的。用户界面是 pdCalc 的高级模块之一，在第 2 章中，我们在进行初始分解时已经定义了 UI 的抽象接口。现在让我们将抽象模块接口转化为实用的面向对象设计。</p><h3 id="5-1-1-抽象接口">5.1.1 抽象接口</h3><p>为 UI 提供一个抽象接口的目的是让程序的其他部分与用户界面进行交互，而无需关心当前界面是图形界面、命令行界面还是其他完全不同的界面。理想情况下，我们将能够将抽象接口提炼为使用每个具体接口所需的最少函数数量。任何共享实现的函数可以在基类中定义，而任何需要基于具体类型的唯一实现的函数可以在抽象基类中声明为虚拟函数，并在派生类中定义。这个概念相当简单，但通常情况下，问题在于细节。</p><p>考虑图 5-1 所示的层次结构。我们的目标是设计一个简洁而完整的接口，符合 Liskov 替换原则，适用于 pdCalc 的 UserInterface 类，既适用于 CLI，也适用于 GUI。正如前面所讨论的，我们已经在第 2 章中为此 UI 定义了一个高级接口。让我们从这个预定义的接口开始，根据需要进行重构。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/A454125_1_En_5_Fig1_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">       图 5-1 最小接口层次结构  </div></center><p>参考第 2 章中的表 2-2，您会发现 UserInterface 类的完整接口由两个事件处理函数 postMessage() 和 stackChanged() 以及一个 UserInterface 触发的事件 commandEntered() 组成。有趣的是，UserInterface 类既是发布者，又是观察者，还是一个抽象用户界面。</p><p>在接口级别，两个事件处理函数 postMessage() 和 stackChanged() 非常简单。就像我们在之前的观察者中所做的那样，我们将简单地将这两个函数添加到 UserInterface 类的公共接口中，并创建代理观察者类来代理发布者和实际观察者之间的通信。这些代理在下面的 5.1.2.2 节中详细讨论。具体的用户界面必须根据各个 UI 与用户的交互方式，为事件处理提供唯一的实现。因此，postMessage() 和 stackChanged() 都必须是纯虚函数。由于 UserInterface 类在事件处理过程中没有插入的必要，为了简单起见，我选择放弃 NVI 模式。然而，正如第 4 章中所讨论的，人们也可以使用带有简单转发非虚拟接口函数的 NVI 模式。</p><p>UserInterface 类作为发布者的角色比作为观察者的角色稍显复杂。正如您在第 3 章设计 Stack 类时所看到的，Stack 实现了发布者接口，而不是替代作为发布者。因此，我们得出的结论是，应该从 Publisher 类进行私有继承。对于 UserInterface 类，与 Publisher 类的关系类似，只是 UserInterface 类本身不是发布者。UserInterface 类是系统中用户界面的抽象接口，并从 Publisher 类继承，只是为了强制用户界面必须自己实现发布者接口。CLI 和 GUI 类都需要访问 Publisher 的公共函数（例如，引发事件）。因此，在这种情况下，受保护的继承方式是合适的。</p><p>进一步回顾第 3 章，为了让 Stack 类实现发布者接口，我们使用私有继承后，需要将 Publisher 类的 attach() 和 detach() 函数提升到 Stack 的公共接口中。在这里使用受保护继承也是如此。然而，问题是，提升应该发生在 UserInterface 类还是它的派生类中？要回答这个问题，我们需要了解 pdCalc 如何使用特定的用户界面。显然，CLI 或 GUI 都是 UserInterface。因此，具体的用户界面将公开继承自 UserInterface 并被期望遵循 LSP。在不了解底层 UI 类型的情况下，必须能够附加或分离特定用户界面的事件。因此，attach() 和 detach() 函数必须作为 UserInterface 公共接口的一部分可见。有趣的是，在观察者模式的一个相当独特的实现中，发布者接口的一部分是在 UserInterface 层次实现的，而另一部分发布者接口是在派生类层次实现的。</p><p>综合以上所有观点，我们最终可以定义 UserInterface 类，如 Listing 5-1 所示。</p><p>Listing 5-1 UserInterface 类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserInterface</span> : <span class="keyword">protected</span> Publisher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">UserInterface</span>();</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">UserInterface</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">postMessage</span><span class="params">(<span class="type">const</span> string&amp; m)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stackChanged</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">using</span> Publisher::attach;</span><br><span class="line">  <span class="keyword">using</span> Publisher::detach;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> string CommandEntered;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CommandEntered 字符串是已输入命令事件的名称。它需要用于附加或分离此事件，并可以给出 UserInterface 类中事件的任何唯一名称。</p><p>为了完整起见，我在图 5-2 中展示了最终的用户界面层次结构。类图说明了 CLI、GUI、抽象 UserInterface 类和发布者接口之间的关系。请记住，UserInterface 类和 Publisher 类之间的继承是受保护的，因此 UserInterface（或后续派生类）不能用作 Publisher。然而，正如前面所述，具体 CLI 和 GUI 类与抽象 UserInterface 类之间继承的意图是公开的，允许实例化任何具体类型作为 UserInterface 进行替换。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/5.The-Command-Line-Interface/A454125_1_En_5_Fig2_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">       图 5-2 用户界面层次结构  </div></center><h3 id="5-1-2-用户界面事件">5.1.2 用户界面事件</h3><p>定义 UserInterface 类并未完成 UI 的接口。由于 UserInterface 类是一个事件发布者，我们还必须定义与 commandEntered() 事件相对应的事件数据类。此外，定义 UserInterface 类最终完成了发布者/观察者对，因此我们终于准备好设计和实现事件代理类，以协调用户界面与命令调度器和堆栈之间的事件。</p><p>在第 4 章中，你看到所有命令都通过事件传递给命令调度器。具体来说，UI 引发包含特定命令的事件，该命令以字符串参数的形式编码，CommandDispatcher 接收此事件，然后将字符串参数传递给 CommandRepository，从中检索具体命令进行处理。就命令调度器而言，处理 commandEntered() 事件是相同的，无论编码的命令字符串是来自 CLI 还是 GUI。</p><p>同样，当 Stack 类引发 stackChanged() 事件时，Stack 对处理此事件的特定 UserInterface 是漠不关心的。因此，我们有动力在用户界面层次结构中的 UserInterface 类级别统一处理 commandEntered() 事件的发出和 stackChanged() 事件的处理。</p><p>我们首先检查引发 commandEntered() 事件的公共基础设施。在 UserInterface 类的构造函数中，已为所有用户界面注册了 commandEntered() 事件。因此，任何派生的用户界面类都可以通过调用由 Publisher 接口定义的 raise() 函数简单地引发此事件，这通过受保护的继承是任何具体 UI 实现的一部分。 raise() 函数的签名要求事件的名称和事件的数据。由于事件的名称是在 UserInterface 的构造函数中预定义的，因此引发命令输入事件所需的额外功能只是一个通用的 CommandData 类。现在让我们看一下它的设计。</p><h4 id="5-1-2-1-命令数据">5.1.2.1 命令数据</h4><p>在第 3 章中，我们设计了我们的事件系统，以使用推送语义传递事件数据。回想一下，推送语义只是指发布者创建一个包含处理事件所需信息的对象，并在事件触发时将该对象推送给观察者。事件数据对象必须公开继承自抽象的 EventData 类。观察者在事件触发时通过抽象接口接收事件数据，并通过将事件数据向下转换为适当的派生类来检索数据。</p><p>对于已输入的命令事件，事件数据只是一个字符串，包含要在堆栈上输入的数字或要发出的命令的名称。CommandData 类只需要在构造时接受一个字符串命令，存储此命令，并为观察者提供一个函数来检索命令。完整实现在 Listing 5-2 中给出。</p><p>Listing 5-2 CommandData 类的完整实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandData</span> : <span class="keyword">public</span> EventData</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CommandData</span>(<span class="type">const</span> string&amp; s) : <span class="built_in">command_</span>(s) &#123; &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">command</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> command_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string command_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尽管 CLI 和 GUI 中确定如何以及何时引发 CommandEntered 事件的机制有所不同，但它们最终都是通过调用具有编码特定命令的 CommandData 参数的 Publisher 的 raise() 函数来引发事件。也就是说，对于某个命令字符串 cmd，以下代码在 CLI、GUI 或可能继承自 UserInterface 的任何其他用户界面中引发 commandEntered() 事件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">raise</span>( UserInterface::CommandEntered, <span class="built_in">make_shared</span>&lt;CommandData&gt;(cmd) );</span><br></pre></td></tr></table></figure><p>现在我们可以引发 UI 事件了，让我们看看它们是如何处理的。</p><h4 id="5-1-2-2-用户界面观察者">5.1.2.2 用户界面观察者</h4><p>本小节的目标是构建机制，使类能够监听事件。由于抽象用户界面既是事件的来源又是事件的接收器，因此 UI 可作为演示发布者和观察者如何相互作用的理想候选者。</p><p>在第3章中，我们了解到观察者是注册并监听发布者引发的事件的类。到目前为止，我们已经遇到了 CommandDispatcher 和 UserInterface 类，这两个类都需要观察事件。尽管可以直接使 CommandDispatcher 或 UserInterface 成为观察者，但我更喜欢在发布者和需要观察事件的类之间构建一个专用的观察者中介。我经常模糊地将这个中介称为代理。现在我准备给这个术语一个更具体的含义。</p><p>代理模式[6]是一种设计模式，它使用一个类，即代理，作为其他东西的接口。这个其他东西，我们称之为目标，没有严格定义。它可以是网络连接、文件、内存中的对象，或者像我们这种情况下，仅仅是另一个类。通常，当底层目标不可能、不方便或昂贵复制时，会使用代理模式。代理模式使用类缓冲区，使系统将目标视为独立于其底层组成的对象。在我们的上下文中，我们只是使用代理模式来缓冲发布者和观察者之间的通信。</p><p>为什么我们在这里要费心使用代理模式？这种策略有几个明显的优势。首先，它通过用一个描述性的事件处理函数替换泛型的 notify() 函数，增加了目标类公共接口的清晰度。其次，从 Observer 类中删除了不必要的继承。消除这种依赖关系可以减少耦合，增加内聚，并促进在非观察者环境中重用目标。第三，使用代理类消除了目标类需要监听多个事件时产生的歧义。如果不使用代理类，观察者将需要在其单一的 notify() 函数中区分事件。对于每个事件使用单独的代理，使得每个事件能调用目标对象中的唯一处理函数。使用代理实现观察者模式的主要缺点是处理每个事件的额外间接成本略有增加。然而，在使用观察者模式适当的情况下，额外的间接成本可以忽略不计。</p><p>使用代理模式实现观察者模式导致了以下两个用于处理 commandEntered() 和 stackChanged() 事件的类：分别是 CommandIssuedObserver 和 StackUpdatedObserver。CommandIssuedObserver 在 UI 引发的 commandEntered() 事件和命令调度器中的观察之间进行调解。StackUpdatedObserver 在栈引发的 stackChanged() 事件和 UI 中的观察之间进行调解。这两个类的实现都相对简单且非常相似。举个例子，让我们来看一下 CommandIssuedObserver 的实现。请参见清单 5-3。</p><p>清单 5-3 CommandIssuedObserver 的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandIssuedObserver</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CommandIssuedObserver</span>(CommandDispatcher&amp; ce);</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">notifyImpl</span><span class="params">(shared_ptr&lt;EventData&gt;)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  CommandDispatcher&amp; ce_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于它在 UI 作为发布者和 CommandDispatcher 作为观察者目标之间调解事件，CommandIssuedObserver 的构造函数需要一个 CommandDispatcher 实例的引用，当 UI 引发 commandEntered() 事件时，它保留该引用以回调命令调度器。请记住，当观察者附加到事件时，CommandIssuedObserver 将存储在发布者的事件符号表中。notifyImpl() 的实现只是对 EventData 参数进行动态转换为特定的 CommandData 实例，然后调用 CommandDispatcher 的 commandEntered() 函数。</p><p>当然，在触发事件之前，必须向 UI 注册 CommandIssuedObserver。为了完整起见，以下代码说明了如何完成此任务：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ui.<span class="built_in">attach</span>( UserInterface::CommandEntered,</span><br><span class="line">  <span class="built_in">make_unique</span>&lt;CommandIssuedObserver&gt;(ce) );</span><br></pre></td></tr></table></figure><p>其中ui是一个UserInterface引用。注意，由于attach()函数有意地提升到抽象UserInterface范围，因此通过引用附加可以让我们对CLI和GUI重用相同的调用。也就是说，通过抽象UI接口完成事件的注册，这大大简化了pdCalc的main()例程中的用户界面设置。StackUpdatedObserver的声明和注册是类似的。</p><p>观察者代理类的完整实现可以在AppObservers.cpp中找到。尽管观察者代理的使用与事件观察类相互交织，但代理不是目标类接口的一部分。因此，它们被包含在它们自己的文件中。代理附加到事件是在main.cpp中执行的。这种代码结构保持了发布者和观察者之间的松散绑定。具体而言，发布者知道他们可以引发哪些事件，但不知道谁会观察它们，而观察者知道他们将观察哪些事件，但不知道谁会引发它们。发布者和观察者之外的代码将两者绑定在一起。</p><h2 id="5-2-具体的CLI类">5.2 具体的CLI类</h2><p>本章剩余部分将详细介绍CLI具体类。让我们从重新审视CLI的需求开始。</p><h3 id="5-2-1-需求">5.2.1 需求</h3><p>pdCalc的需求表明，计算器必须具有命令行界面，但是，CLI到底是什么呢？我对命令行界面的定义是任何通过文本与用户交互地响应用户命令的程序的用户界面。即使您对命令行界面的定义有所不同，我相信我们可以肯定地说，一个简单地指示程序应该有CLI的宽泛要求是非常不足够的。</p><p>在生产开发环境中，当你遇到一个设计组件过于模糊的需求时，你应该立即向客户寻求澄清。注意我说的是何时而不是如果。无论你在前期花多少精力尝试完善需求，你总是会遇到不完整的、不一致的或者不断变化的需求。这通常是由于以下几个原因。有时，这是因为有意识地不花时间在前期完善需求。有时，这是因为没有经验的团队成员不了解如何正确收集需求。然而，通常情况下，这是因为终端用户在产品开始成型之前并不知道他或她真正想要或需要什么。即使对于我自己是客户的小型开发项目，我也发现这是真实的！虽然作为实现者，您总是可以在不与客户交流的情况下完善需求，但我的经验表明，这条路总是不可避免地导致代码的反复重写：一次是为了你认为用户想要的，一次是为了用户认为他想要的，还有一次是为了用户真正想要的。</p><p>显然，在我们的案例研究中，我们只有一个假设的终端用户，所以我们只需自己进行完善。我们指定以下内容：</p><ol><li class="lvl-3"><p>CLI应该接受计算器定义的任何命令的文本命令（存在于命令仓库中的命令，以及撤消、重做、帮助和退出）。</p></li><li class="lvl-3"><p>help命令应显示所有可用命令的列表和一个简短的解释性消息。</p></li><li class="lvl-3"><p>CLI应该接受按照它们应该被处理的顺序用空格分隔的命令。回想一下，这个顺序对应于逆波兰表示法。在按下回车键后处理一行上的所有命令。</p></li><li class="lvl-3"><p>在处理命令后，界面应显示栈顶部最多四个元素以及栈的当前大小。</p></li></ol><p>令人惊讶的是，上面列出的最小要求足以构建一个简单的CLI。虽然这些要求有些武断，但为了描述设计和实现，需要选择具体的内容。如果你不喜欢生成的CLI，我强烈建议你制定自己的需求，并相应地修改设计和实现。</p><h3 id="5-2-2-CLI设计">5.2.2 CLI设计</h3><p>CLI的设计非常简单。因为我们整体的架构设计将计算器的整个“业务逻辑”放在了后端，前端只是一个很薄的层，除了接受和对用户输入进行标记化处理、将输入依次传递给控制器并显示结果之外，没有其他功能。让我们从描述接口开始。</p><h4 id="5-2-2-1-接口">5.2.2.1 接口</h4><p>从本章前面的分析中，我们知道具体的CLI类将继承自抽象UserInterface类。这种继承是公共的，因为CLI“是一个”UserInterface，并且必须作为一个替代。因此，CLI必须实现UserInterface的两个抽象纯虚函数，postMessage()和stackChanged()。这两个方法只通过UserInterface引用多态地调用；因此，这两个方法都成为了CLI的私有接口。除了构造和销毁，CLI需要公开暴露的唯一功能是启动其执行的命令。这个函数驱动整个CLI，只有在用户请求退出程序时才返回（通常）。将上述内容结合起来，CLI的整个接口可以通过列表5-4中的代码给出。</p><p>列表5-4 CLI的全部接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cli</span> : <span class="keyword">public</span> UserInterface</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">CliImpl</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cli</span>(istream&amp; in, ostream&amp; out);</span><br><span class="line">  ~<span class="built_in">Cli</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">bool</span> suppressStartupMessage = <span class="literal">false</span>, <span class="type">bool</span> echo = <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">postMessage</span><span class="params">(<span class="type">const</span> string&amp; m)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stackChanged</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  unique_ptr&lt;CliImpl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然接口主要是自解释的，但构造函数和execute()函数的参数值得解释。为了满足上述要求，可以编写一个没有参数的execute()函数。接口中包含的这两个参数只是可以打开的可选功能。第一个参数决定CLI启动时是否显示横幅。第二个参数控制命令回显。如果将回显设置为true，则在显示结果之前重复每个命令。这两个功能可以在CLI中硬编码，但我选择将它们作为execute()方法的参数以增加灵活性。</p><p>构造函数的参数稍微不那么明显，与execute()命令的参数不同。几乎可以肯定，CLI从cin接收输入并将结果输出到cout或者cerr。然而，将这些标准I/O流硬编码会任意限制这个类的用途，使其仅限于传统的CLI。通常，我主张将功能限制在你确切需要的范围内，而不是预期更通用的用途。然而，使用C++流I/O是我对这个经验法则的少数例外。</p><p>让我们讨论为什么在C++ I/O流中使用基类引用通常是一个好的设计实践。首先，使用不同的I/O模式的需求相当普遍。具体而言，重定向到文件或从文件中重定向是CLI经常要求修改的。实际上，你会在第8章看到这个请求！其次，实现通用与特定接口几乎不增加复杂性。例如，不是直接写入cout，而是保留一个输出流引用并改为写入该引用。在基本情况下，此引用仅指向cout。最后，使用任意流输入和输出大大简化了测试。虽然程序可能使用cin和cout实例化Cli类，但测试可以使用文件流或字符串流实例化Cli类。通过这种方式，可以使用字符串或文件模拟交互式流输入和输出。这种策略简化了Cli类的测试，因为输入可以很容易地传入，输出可以很容易地捕获为字符串，而不是通过标准输入和输出。</p><h4 id="5-2-2-2-实现">5.2.2.2 实现</h4><p>值得研究Cli类的实现，以观察pdCalc设计的模块化所带来的简单性。Cli类的整个实现实际上包含在execute()和postMessage()成员函数中。execute()函数驱动CLI。它向最终用户展示启动消息，等待输入命令，对这些命令进行标记化处理，并发出事件以通知命令调度器已输入新命令。stackChanged()函数是一个观察者代理回调目标，在触发stackChanged()事件后将堆栈顶部写入命令行。本质上，CLI可以简化为两个I/O例程，其中execute()处理输入，stackChanged()处理输出。让我们从列表5-5中显示的execute()函数开始，看看这两个函数的实现。</p><p>列表5-5 execute()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> Cli::CliImpl::<span class="built_in">execute</span>(<span class="type">bool</span> suppressStartupMessage, <span class="type">bool</span> echo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!suppressStartupMessage) <span class="built_in">startupMessage</span>();</span><br><span class="line">  <span class="keyword">for</span>(string line; <span class="built_in">getline</span>(in_, line, <span class="string">&#x27;\n&#x27;</span>);)</span><br><span class="line">  &#123;</span><br><span class="line">    Tokenizer tokenizer&#123;line&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; i : tokenizer)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(echo) out_ &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="string">&quot;exit&quot;</span> || i == <span class="string">&quot;quit&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        parent_.<span class="built_in">raise</span>( CommandEntered, <span class="built_in">make_shared</span>&lt;CommandData&gt;(i) );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CLI的主要算法相当简单。首先，CLI等待用户输入一行。然后，由Tokenizer类对这个输入行进行标记处理。然后，CLI在输入行中的每个标记上循环，并使用标记字符串作为事件的数据发出事件。当CLI遇到退出或退出标记时，它会终止。</p><p>在execute()函数中尚未解释的部分是Tokenizer类。简单地说，Tokenizer类负责接收一段文本字符串，并将该字符串拆分为独立的空格分隔的标记。CLI和Tokenizer都不确定标记的有效性。标记只是作为事件触发，由命令调度器处理。值得注意的是，作为编写自己的替代方法，许多库（例如boost）提供了简单的分词器。</p><p>考虑到分词算法的简单性（请参阅Tokenizer.cpp中的实现），为什么我要将Tokenizer设计为一个类，而不是一个返回字符串向量的函数？实际上，这两种设计在功能上都可行，而且两种设计都很容易测试和维护。然而，我更喜欢类设计，因为它为Tokenizer提供了一个独特的类型。让我们来看一下为标记化创建一个独特类型的优点。</p><p>假设我们想要在函数foo()中对输入进行标记化处理，但在另一个函数bar()中处理标记。考虑以下两个可能的函数对来实现这个目标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use a Tokenizer class</span></span><br><span class="line"><span class="function">Tokenizer <span class="title">foo</span><span class="params">(<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> Tokenizer&amp;)</span></span>;</span><br><span class="line"><span class="comment">// use a vector of strings</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">foo</span><span class="params">(<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp;)</span></span>;</span><br></pre></td></tr></table></figure><p>首先，使用Tokenizer类，foo()和bar()的签名立即告诉程序员这些函数的意图。我们知道这些函数涉及到标记化。使用字符串向量会在没有进一步文档的情况下留下歧义（我故意没有为参数提供名称）。更重要的是，输入标记器使编译器确保bar()只能使用一个Tokenizer类作为参数，从而防止程序员不小心用一个无关的字符串集合调用bar()。类设计的另一个好处是，Tokenizer类封装了表示标记集合的数据结构。这种封装保护了bar()的接口，免受更改底层数据结构的决定（例如，从字符串向量更改为字符串列表）。最后，Tokenizer类可以封装关于标记化的其他状态信息（例如，原始的、未标记化的输入），如果需要的话。显然，字符串集合仅限于携带标记本身。</p><p>现在让我们来看一下stackChanged()函数的简化实现，如Listing 5-6所示。</p><p>Listing 5-6 stackChanged函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> Cli::CliImpl::<span class="built_in">stackChanged</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nElements&#123;<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> v = Stack::<span class="built_in">Instance</span>().<span class="built_in">getElements</span>(nElements);</span><br><span class="line">  ostringstream oss;</span><br><span class="line">  <span class="type">size_t</span> size = Stack::<span class="built_in">Instance</span>().<span class="built_in">size</span>();</span><br><span class="line">  oss &lt;&lt; <span class="string">&quot;stack\n&quot;</span>;</span><br><span class="line">  <span class="type">size_t</span> j&#123; v. <span class="built_in">size</span>() &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> i = v.<span class="built_in">rbegin</span>(); i != v.<span class="built_in">rend</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    oss &lt;&lt; j &lt;&lt; <span class="string">&quot;:\t&quot;</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    --j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">postMessage</span>( oss. <span class="built_in">str</span>() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cli.cpp中的实现仅在打印的繁琐程度上有所不同。请注意，每当堆栈发生变化时，CLI只需选择堆栈顶部的四个条目（如我们的要求所述）（getElements()返回nElements和堆栈大小的最小值），将它们格式化到ostringstream中，然后将一个字符串消息传递给postMessage()函数。对于CLI，postMessage()只需将字符串写入输出流。</p><p>在继续之前，让我们暂停并反思CLI实现的简洁和简明。这种简单性是pdCalc整体设计的直接结果。虽然许多用户界面将业务逻辑与显示代码混合在一起，但我们精心设计了这两个层次以实现独立性。命令的解释和处理（业务逻辑）完全位于命令调度器中。因此，CLI只负责接受命令、标记化命令和报告结果。此外，根据我们的事件系统设计，CLI与命令调度器之间没有直接耦合，这是符合我们MVC架构的决策。命令调度器确实与用户界面有直接联系，但由于我们的抽象，命令调度器绑定到一个抽象的UserInterface，而不是一个特定的用户界面实现。这样，Cli可以完美地替代UserInterface（LSP的应用），并可以轻松地作为计算器的许多独特视图之一进行交换。虽然这种灵活性可能看起来对于计算器的设计来说有些过分，但所有组件的模块化对于测试和关注点分离来说都是有益的，即使计算器没有计划使用另一个用户界面。</p><h2 id="5-3-整合：一个可运行的程序">5.3 整合：一个可运行的程序</h2><p>在结束本章关于CLI的讨论之前，编写一个简单的主程序将所有组件连接在一起以展示一个可运行的计算器是值得的。pdCalc的实际实现在main.cpp中要复杂得多，因为它处理多个用户界面和插件。最终，我们将逐步了解main.cpp中的完整实现，但现在，Listing 5-7中的代码将使我们能够使用命令行界面执行一个可运行的计算器（当然，包括适当的头文件）：</p><p>Listing 5-7 一个可运行的计算器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Cli cli&#123;cin, cout&#125;;</span><br><span class="line">  CommandDispatcher ce&#123;cli&#125;;</span><br><span class="line">  <span class="built_in">RegisterCoreCommands</span>(cli);</span><br><span class="line">  cli.<span class="built_in">attach</span>( UserInterface::CommandEntered,</span><br><span class="line">    <span class="built_in">make_unique</span>&lt;CommandIssuedObserver&gt;(ce) );</span><br><span class="line">  Stack::<span class="built_in">Instance</span>().<span class="built_in">attach</span>( Stack::StackChanged,</span><br><span class="line">    <span class="built_in">make_unique</span>&lt;StackUpdatedObserver&gt;(cli) );</span><br><span class="line">  cli.<span class="built_in">execute</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于设计的模块化，整个计算器可以通过仅仅六个可执行语句来设置、组装和执行！main() 函数中的逻辑非常容易理解。从维护的角度来看，项目中的任何新程序员都可以轻松地追踪计算器的逻辑，并看到每个模块的功能都被清晰地划分为不同的抽象。在后续章节中，将看到随着模块数量的增加，抽象变得更加强大。</p><p>为了让您快速开始，仓库源代码中包含了一个项目，该项目使用上述 main() 函数作为应用程序的驱动程序构建一个可执行文件，pdCalc-simple-cli。该可执行文件是一个独立的 CLI，包含了到目前为止在本书中讨论的所有功能。</p><p>在下一章中，我们将考虑设计计算器的图形用户界面。一旦 GUI 完成，许多用户会很快将 CLI 视为一个练习或者是过去时代的遗物。在此之前，我想鼓励读者不要过于快速地评判谦逊的 CLI。CLI 是非常高效的接口，而且通常在需要大规模部署或自动化的任务中编写脚本更为简便。就 pdCalc 而言，我个人更喜欢 CLI 而不是 GUI，因为它更易于使用。当然，也许这只是表明我也是过去时代的遗物。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Practical C++ Design From Programming to Architecture 1ed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. 图形用户界面</title>
      <link href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/6.The-Graphical-User-Interface/"/>
      <url>/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/6.The-Graphical-User-Interface/</url>
      
        <content type="html"><![CDATA[<h1>6. 图形用户界面</h1><p>在本章中，我们将探讨pdCalc的图形用户界面（GUI）的设计。在设计GUI时，需要选择一个部件平台。如前所述，我选择使用Qt来创建GUI。也就是说，这不是一个关于如何使用Qt设计界面的教程。相反，我假设读者已经对Qt有一定的了解，并且本章主要关注GUI的设计方面。事实上，尽可能地，我将引导读者查看源代码以了解部件实现的详细方面。关于Qt实现的任何讨论要么仅是附带性的，要么值得特别强调。如果你对GUI设计不感兴趣，那么完全可以跳过这一章，几乎不会影响连续性。</p><h2 id="6-1-要求">6.1 要求</h2><p>在第5章中，我们通过导出一个接口抽象来分析命令行界面（CLI），这个接口抽象将同时被CLI和GUI使用。显然，我们将在此处重用此接口，因此我们已经知道我们的整体用户界面必须符合的抽象接口。因此，我们通过定义GUI专门化的需求来开始本章。</p><p>与CLI一样，我们很快发现第1章的需求对于指定图形用户界面是严重不足的。给定的需求仅是功能性的。也就是说，我们知道计算器应该支持哪些按钮和操作，但我们对预期外观一无所知。</p><p>在一个商业项目中，人们可能会（希望）与客户、平面设计师和人机交互专家合作，以协助设计GUI。对于我们的案例研究，充分明确我们自己的需求就足够了：</p><ol><li class="lvl-3"><p>GUI应该有一个窗口，既显示输入也显示输出。输出是当前堆栈的前六个条目。</p></li><li class="lvl-3"><p>GUI应该有可点击的按钮，用于输入数字和所有受支持的命令。</p></li><li class="lvl-3"><p>GUI应该有一个状态显示区域，用于显示错误消息。</p></li></ol><p>上述要求仍然无法解释计算器实际上应该是什么样子。为此，我们需要一张图片。图6-1显示了我在Linux桌面上的工作计算器（使用Kubuntu 1## 6.10和Qt 5.7.1）。将完成的GUI作为设计GUI的原型展示肯定是“作弊”。希望这种捷径不会过多地影响案例研究的真实性。显然，在开发的这个阶段，人们不会有一个完整的产品。在生产环境中，人们可能会用手或使用诸如Microsoft PowerPoint、Adobe Illustrator、Inkscape等程序绘制模型。或者，也许GUI是根据一个物理对象建模的，设计师要么拥有照片，要么可以直接访问该对象。例如，可能正在设计一个用于替换物理控制系统的GUI，要求指定界面必须显示相同的刻度盘和仪表（以减少操作员再培训的成本）。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/6.The-Graphical-User-Interface/A454125_1_En_6_Fig1_HTML.jpg" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图6-1 Linux上的GUI没有插件  </div></center><p>pdCalc的GUI受到我的HP48S计算器的启发。对于熟悉该系列惠普计算器的人来说，界面会感觉有些熟悉。对于不熟悉这个系列计算器的人（可能是大多数读者），以下描述解释了GUI的基本行为。</p><p>GUI的顶部三分之一是一个专用的输入/输出（I/O）窗口。I/O窗口在左侧显示前六个堆栈级别的标签，堆栈顶部位于窗口底部。堆栈上的值出现在窗口右侧，与堆栈上数字位置对应的行上。当用户输入一个数字时，堆栈减少到仅显示前五个堆栈元素，而正在输入的数字显示在底部行的左侧。按Enter键结束数字输入并将其输入到堆栈上。</p><p>假设输入足够，当按下按钮时立即进行操作。如果输入不足，错误消息将显示在I/O窗口上方。对于命令，输入区域中的有效数字被视为堆栈顶部的数字。也就是说，在输入数字时应用操作相当于按Enter键，然后应用操作。</p><p>为节省空间，某些按钮上方和左侧有一个移位操作。这些移位操作可以通过首先按下shift按钮，然后按下移位文本下方的按钮来激活。按下shift按钮会将计算器置于shift模式，直到按下带有移位操作的按钮，或者直到再次按下shift按钮。为了清晰起见，移位操作通常是按钮上操作的逆操作。</p><p>为了简化输入，许多按钮绑定了键盘快捷键。按相应的数字键可以激活数字，按Enter键可以激活Enter按钮，按S键可以激活Shift，按Backspace键可以激活退格，按E键可以激活指数运算，按相应的键可以激活四个基本算术运算（+，-，*，/）。</p><p>最后，有些操作是半隐藏的。在不输入数字时，退格键会将堆栈顶部的条目删除，而Enter键会将堆栈顶部的条目复制。这些组合中的一些并不直观，因此可能不代表很好的GUI设计。然而，它们确实模仿了HP48S上使用的输入。如果您以前从未使用过HP48系列计算器，我强烈建议您在继续之前从GitHub仓库中构建并熟悉GUI。</p><p>如果你想知道proc键的作用，它执行存储过程。这是我们将在第8章中遇到的“新”要求之一。</p><p>关于GUI的第一个批评可能是它并不是很漂亮。我同意。本章中GUI的目的不是展示高级Qt功能。相反，其目的是说明如何设计一个模块化、健壮、可靠和可扩展的代码库。添加使GUI更具吸引力而不是功能性的代码会让这个信息分散注意力。当然，这种设计允许更漂亮的GUI，所以请随意在提供的基础设施上制作自己的漂亮GUI。</p><p>现在我们已经有了足够的细节来设计和实现计算器的GUI。然而，在我们开始之前，有必要简要讨论一下构建GUI的替代方案。</p><h2 id="6-2-构建GUI">6.2 构建GUI</h2><p>本质上，构建GUI有两种截然不同的路径：在集成开发环境（IDE）中构建GUI或在代码中构建GUI。在这里，我宽泛地使用术语代码来表示通过文本构建GUI，无论是使用传统的编程语言（如C++）还是使用声明式标记语法（如XML）。当然，在两个极端之间是混合方法，它结合了IDE和代码的元素。</p><h3 id="6-2-1-在IDE中构建GUI">6.2.1 在IDE中构建GUI</h3><p>如果您只需要一个简单的GUI，那么在IDE中设计和构建GUI无疑是更简单的途径。大多数IDE都有一个图形界面，用于将视觉元素布局到画布上，例如，这可能是一个对话框或一个小部件。设置好新画布后，用户通过将现有小部件拖放到画布上来直观地构建GUI。现有的小部件包括GUI工具包的内置图形元素（例如，一个按钮）以及在IDE框架中启用了拖放的自定义小部件。布局完成后，可以通过图形方式或少量代码将动作绑定在一起。最后，IDE创建与图形化布局的GUI相对应的代码，并将这些IDE创建的代码与您的其余源代码一起编译。</p><p>使用IDE构建GUI有优点和缺点。以下是一些优点。首先，因为过程是可视的，所以在执行布局时，您可以轻松地看到GUI的外观。这与编写GUI代码形成鲜明对比，因为您只有在编译和执行代码后才能看到GUI的外观。这种差异非常类似于使用WYSIWYG文本编辑器（如Microsoft Word）和使用标记语言（如LaTeX）编写论文的区别。其次，IDE通过在后台自动生成代码，所以图形化方法可以显著减少编写GUI所需的代码量。第三，IDE通常会在属性表中列出GUI元素的属性，使得在不断查阅API文档的情况下，可以轻松地对GUI进行样式化。这对于很少使用的功能特别有用。</p><p>使用IDE构建GUI的一些缺点如下。首先，您受限于IDE选择暴露的API子集。有时会暴露完整的API，有时则不会。如果您需要IDE作者选择不授予您的功能，您将被迫编写自己的代码。也就是说，IDE可能会限制对GUI元素的微调控制。其次，对于重复的GUI元素，您可能需要多次执行相同的操作（例如，在所有按钮中单击使文本变红），而在代码中，将重复任务封装在类或函数调用中很容易。第三，使用IDE设计GUI会将GUI限制在编译时可以做出的决策。如果您需要动态更改GUI的结构，您需要编写相应的代码。第四，使用IDE设计GUI会将您的代码绑定到特定的供应商产品。在企业环境中，这可能不是一个重要的问题，因为整个公司的开发环境可能是统一的。然而，对于开源、分布式项目来说，并非所有希望为您的代码库做出贡献的开发者都希望受到您选择的相同IDE的限制。</p><h3 id="6-2-2-用代码构建GUI">6.2.2 用代码构建GUI</h3><p>用代码构建GUI正如其名字所暗示的。与在画布上以图形方式放置小部件不同，您需要编写代码来与GUI工具包进行交互。有几种不同的代码编写选项，通常对于任何给定的GUI工具包，您可以使用多种选项。首先，您几乎总是可以用工具包的语言编写源代码。例如，在Qt中，您可以通过用非常命令式的风格编写C<ins>代码（即，您明确指导GUI的行为）来完全构建GUI。其次，一些GUI工具包允许声明式风格（即，您编写描述GUI元素样式的标记代码，但工具包定义元素的行为）。最后，一些工具包使用基于脚本的接口来构建GUI（通常是JavaScript或JavaScript派生语法），可能与声明式标记结合使用。在本章的背景下，用代码构建GUI专指针对Qt桌面小部件集的C</ins>编码。</p><p>正如您所预料的，用代码构建GUI与用IDE构建GUI几乎具有相反的权衡。优点如下。首先，部件的完整API完全暴露。因此，程序员可以根据需要进行微调控制。如果部件库设计者希望用户能够做某事，您可以在代码中实现它。其次，通过使用抽象，可以轻松管理重复的GUI元素。例如，在设计计算器时，我们可以创建一个按钮类，而不是手动定制每个按钮。第三，运行时动态添加部件非常容易。对于pdCalc来说，这个优点对于支持动态插件的要求很重要。第四，用代码设计GUI提供了完全的IDE独立性，前提是构建系统独立于IDE。</p><p>虽然用代码构建GUI有很多优点，但也存在缺点。首先，布局不是可视化的。为了看到GUI成形，您必须编译并执行代码。如果看起来不对，您必须调整代码，重试，并重复此过程，直到您做对为止。这可能非常繁琐且耗时。其次，您必须自己编写所有代码。虽然IDE会自动生成大部分GUI代码，特别是与布局相关的部分，但当您编写代码时，您必须手动完成所有工作。最后，用代码编写GUI时，您将无法在属性表上简洁地访问部件的所有属性。通常，您需要更频繁地查阅文档。话虽如此，好的IDE代码补全可以大大帮助这项任务。有人可能会对我最后一句话提出质疑，声称，“指出使用IDE可以减轻不使用IDE的缺点是不公平的。”请记住，除非您在纯文本编辑器中编写源代码（不太可能），代码编辑器很可能仍然是一个复杂的IDE。我的比较是在使用IDE的图形GUI布局工具构建GUI与使用现代代码编辑器手动编写代码之间进行比较，很可能本身就是一个IDE。</p><h3 id="6-2-3-哪种构建GUI的方法更好？">6.2.3 哪种构建GUI的方法更好？</h3><p>关于章节标题中过于宽泛的问题的答案当然是没有一个更好。构建GUI的更好技术完全取决于上下文。当您在自己的编码过程中遇到这个问题时，请参考上述权衡，为您的情况做出最合理的选择。通常，最佳解决方案是采用混合策略，其中一些GUI部分将以图形方式布局，而其他GUI部分将完全从代码构建。</p><p>在我们的背景下，一个更具体的问题是，“哪种GUI构建方法对于pdCalc更好？”对于这个应用程序，权衡重点有利于基于代码的方法。首先，计算器的视觉布局相当简单（一个状态窗口、一个显示部件和一组按钮网格），并且可以轻松地在代码中实现。这一事实立即消除了IDE方法最显著的优势：以视觉方式处理复杂布局。其次，按钮的创建和布局是重复的，但很容易封装，这是基于代码方法的优点之一。最后，因为计算器必须支持运行时插件，代码方法更适合动态添加部件元素（运行时发现的按钮）。</p><p>在本章的剩余部分，我们将探讨pdCalc的GUI在代码中的设计。特别是，主要关注组件的设计及其接口。由于我们的关注点不是部件构建，许多实现细节将被忽略。然而，不用担心。如果您对细节感兴趣，GitHub仓库中提供了所有代码供您查阅。</p><h2 id="6-3-模块化">6.3 模块化</h2><p>从本书一开始，我们就讨论了计算器的分解策略。使用MVC架构模式，我们将设计分成模型、视图和控制器。在第4章中，我们看到主要组件之一，命令调度器，被拆分成子组件。虽然CLI简单到不需要模块化，但GUI足够复杂，分解是有用的。</p><p>在第5章中，我们确定了我们的系统中任何用户界面都必须继承自UserInterface抽象类。本质上，UserInterface类定义了MVC模式中视图的抽象接口。虽然GUI模块必须继承自UserInterface，并因此向控制器呈现相同的抽象接口，但我们可以自由地分解GUI的内部结构。我们将再次使用松散耦合和强内聚的指导原则来模块化GUI。</p><p>当我分解一个模块时，我首先考虑强内聚。也就是说，我试图将模块分解成每个都做一件事（并且做得很好）的小组件。让我们用GUI来尝试一下。首先，任何Qt GUI都必须有一个主窗口，通过继承QMainWindow来定义。主窗口也是MVC视图的入口点，所以我们的主窗口也必须继承自UserInterface。MainWindow是我们的第一个类。接下来，从视觉上检查图6-1，计算器显然被分成一个用于输入（按钮集合）的组件和一个用于显示的组件。因此，我们添加两个类，InputWidget和Display。我们已经讨论过，使用代码方法构建GUI的一个优点是抽象重复创建按钮，所以我们也会创建一个CommandButton类。最后，让我们添加一个负责管理计算器外观和感觉（如字体、边距、间距等）的组件，恰当地命名为LookAndFeel类。还有一个用于存储过程输入的组件，但我们将推迟讨论这个组件，直到第8章。</p><p>现在让我们看看每个类的设计，从CommandButton开始。在出现时，我们将讨论对这个初始分解的任何必要的细化。</p><h3 id="6-3-1-CommandButton抽象">6.3.1 CommandButton抽象</h3><p>我从描述按钮是如何被抽象的开始讨论。这是一个合理的开始，因为按钮是计算器的数字和命令输入机制的基础。</p><p>Qt 提供了一个按钮部件类，它显示一个可点击的按钮，当按钮被点击时发出信号。这个 QPushButton 类为我们所需的数字和命令输入提供了基础功能。我们可以采用的一种设计是使用原生的 QPushButton。这种设计需要显式编写代码，将每个 QPushButton 手动连接到其自定义的槽。然而，这种方法重复、繁琐且容易出错。此外，某些按钮需要 QPushButton API 未提供的附加功能（如 shifted input）。因此，我们寻求为我们的程序构建一个基于 QPushButton 的按钮抽象，补充这个 Qt 类的附加功能，同时限制 QPushButton 的接口以满足我们的需求。我们将这个类称为 CommandButton。</p><p>在模式术语中，我们提出了一个既是适配器又是外观的东西。我们在第3章见过适配器模式。外观模式是一个密切的表亲。适配器模式负责将一个接口转换为另一个接口（可能需要一些调整），而外观模式负责为子系统中的一组接口提供统一的接口（通常是为了简化）。我们的CommandButton被赋予了这两个任务。我们既在简化QPushButton接口到pdCalc所需的有限子集，同时又在调整QPushButton的功能以满足我们问题的要求。那么，CommandButton是一个外观还是一个适配器呢？区别在于语义；它具有两者的特征。请记住，了解不同模式的目标并根据您的需求进行调整是很重要的。尽量不要因为模式纯度而迷失在《四人帮》[6]的死板实现中。</p><h3 id="6-3-2-CommandButton-设计">6.3.2 CommandButton 设计</h3><p>抛开导言，我们仍然需要确定我们的CommandButton到底需要做什么以及它如何与其余的GUI进行交互。在很多方面，CommandButton的外观和功能与QPushButton相似。例如，CommandButton必须呈现一个可以点击的视觉按钮，在按钮被点击后，它应该发出某种信号，让其他GUI组件知道已经发生了点击动作。然而，与标准QPushButton不同，我们的CommandButton必须支持标准和移位状态（例如，支持sin和arcsin的按钮）。这种支持应该是视觉上的（两种状态都应该由我们的CommandButton小部件显示）和功能上的（点击信号必须描述标准点击和移位点击）。因此，我们有两个设计问题要回答。首先，我们如何设计和实现小部件以在屏幕上正确显示？其次，计算器总体上如何处理移位操作？</p><p>首先让我们解决CommandButton外观问题。当然，我们可以从头开始实现我们的按钮，手动绘制屏幕，并使用鼠标事件捕获按钮点击，但这对于CommandButton来说有些过头了。相反，我们寻求一个重用Qt的QPushButton类的解决方案。我们本质上有两个重用选项：继承和封装。</p><p>首先，让我们考虑通过继承在CommandButton类的设计中重用QPushButton类。这种方法是合理的，因为人们可以合乎逻辑地认为CommandButton是一个QPushButton。然而，这种方法存在一个明显的缺陷。&quot;is-a&quot;关系意味着公共继承，这意味着QPushButton的整个公共接口将成为CommandButton的公共接口的一部分。然而，我们已经确定了在pdCalc中，为了简单起见，我们希望CommandButton具有一个受限的接口（外观模式）。好吧，让我们尝试私有继承，并修改我们在CommandButton和QPushButton之间的“实现”关系。现在我们遇到了第二个缺陷。在没有从QPushButton公共继承的情况下，CommandButton失去了对QWidget类的间接继承，这是Qt中一个类成为用户界面对象的先决条件。因此，任何私下继承QPushButton的实现也需要从QWidget公开继承。然而，由于QPushButton也继承自QWidget，因此CommandButton对这两个类的多重继承将导致歧义，因此是不允许的。我们必须寻求一个替代设计。</p><p>现在，考虑将QPushButton封装在CommandButton中（即，CommandButton“有一个”QPushButton）。我们可能应该从这个选项开始，因为一般实践表明，我们应该尽可能地选择封装而不是继承。然而，许多开发者倾向于从继承开始，我想讨论这种方法的缺点，而不仅仅是依赖C++规范。除了打破强继承关系之外，选择封装方法克服了之前讨论过的使用继承的两个缺点。首先，由于QPushButton将被封装在CommandButton内，我们可以自由地仅暴露出对我们应用有意义的QPushButton接口的部分（或者完全不暴露）。其次，通过使用封装，我们将避免同时从QWidget和QPushButton类继承的多重继承混乱。请注意，我原则上不反对使用多重继承的设计。在这种情况下，多重继承仅仅是模糊的。</p><p>封装关系可以采取组合或聚合的形式。哪一个适合CommandButton类呢？考虑两个类A和B，其中A封装了B。在复合关系中，B是A的一个组成部分。在代码中，关系表示如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  B b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相比之下，聚合意味着A仅在内部使用B对象。在代码中，聚合表示如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  B* b_; <span class="comment">// or some suitable smart pointer or reference</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于我们的应用程序，我认为聚合更有意义。也就是说，我们的CommandButton使用一个QPushButton，而不是由一个QPushButton组成。差别微妙，而且同样可以为声明关系是组合的关系提出合乎逻辑的论据。话虽如此，Qt中的两种设计在机械上都能工作，因此编译器实际上不关心您如何选择表达关系。</p><p>既然我们已经决定将QPushButton聚合在CommandButton中，我们可以继续进行CommandButton类的整体设计。我们的CommandButton必须支持主要命令和次要命令。在视觉上，我选择在按钮上显示主要命令，而次要命令则以蓝色显示在按钮的上方和左侧。（我稍后会讨论移位状态的操作。）因此，CommandButton只需实例化一个QPushButton和一个QLabel，并将它们都放入一个QVBoxLayout中。QPushButton显示主要命令的文本，QLabel显示移位命令的文本。布局如图6-2所示。为了完成设计，如前所述，为了与GUI的其余部分进行图形交互，CommandButton必须公开继承QWdiget类。设计结果是一个可重用的CommandButton小部件类，用于通用的按钮，声明了一个主要命令和一个次要命令。因为按钮操作是通过使用QPushButton实现的，所以CommandButton类的整体实现非常简单。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/6.The-Graphical-User-Interface/A454125_1_En_6_Fig2_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图6-2 CommandButton的布局  </div></center><p>对于重用QPushButton，还有一个最后的小细节。显然，因为QPushButton被封装在CommandButton中，客户端无法外部连接到QPushButton的clicked()信号，这使得客户端代码无法知道何时单击了CommandButton。这种设计实际上是有意为之。CommandButton将在内部捕获QPushButton的clicked()信号，然后重新发射自己的信号。这个公共CommandButton信号的设计与移位状态处理密切相关。</p><p>现在我们回到在计算器中建模移位状态。我们有两个实际选项。第一个选项是让CommandButton知道计算器何时处于移位状态，并且只发出正确的移位或非移位命令。另一方面，第二个选项是让CommandButton发出移位和非移位命令，让信号接收者解决计算器的当前状态。让我们检查两个选项。</p><p>第一个选项，让 CommandButton 知道计算器是处于移位还是非移位状态，实现起来相对容易。在一种实现中，移位按钮在按下时通知每个按钮（通过 Qt 信号和槽），并且按钮在移位和非移位状态之间切换。如果需要，每次切换移位状态时，甚至可以将移位位置的文本与按钮上的文本交换。或者，移位按钮可以连接到一个槽，该槽设置一个全局移位状态标志，按钮在发出点击信号时可以查询该标志。在这两种实现情景中，当按钮被点击时，只有当前状态的命令被发出，接收此命令的接收器最终通过 commandEntered() 事件将单个命令从 GUI 中转发出去。</p><p>在第二个选项中，CommandButton 不需要了解计算器的状态。相反，当按钮被点击时，它会用移位和非移位状态发出点击信号。本质上，按钮只是在被点击时通知其侦听器，并提供两个可能的命令。接收器接着负责确定在 commandEntered() 事件中引发哪一个可能的命令。接收器大概必须负责跟踪移位状态（或者能够查询另一个类或变量保存的状态）。</p><p>对于 CommandButton，处理计算器状态的两种设计都相当有效。然而，就个人而言，我更喜欢不需要 CommandButton 知道移位状态的设计。在我看来，这种设计促进了更好的内聚性和较松的耦合。设计更具内聚性，因为 CommandButton 应该负责显示一个可点击的小部件，并在按钮被点击时通知系统。要求 CommandButton 理解计算器状态侵犯了它们抽象的独立性。按钮不仅仅是具有两个命令的通用可点击按钮，而是与计算器的全局状态概念紧密联系在一起。此外，通过强制 CommandButton 理解计算器的状态，系统的耦合性增加，使 CommandButton 不必要地与移位按钮或它们必须查询的类相互连接。在移位按钮被按下时通知每个 CommandButton 的唯一优势是能够交换主要和次要命令的标签。当然，标签交换可以独立于 CommandButton 的信号参数来实现。</p><h3 id="6-3-3-CommandButton-接口">6.3.3 CommandButton 接口</h3><p>设计得当是困难的部分。有了设计，接口几乎可以自己编写。让我们来看一下 CommandButton 类定义的简化版本，如清单 6-1 所示。</p><p>清单 6-1 CommandButton 类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandButton</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT <span class="comment">// needed by all Qt objects with signals and slots</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CommandButton</span>(<span class="type">const</span> string&amp; dispPrimaryCmd, <span class="type">const</span> string&amp; primaryCmd,</span><br><span class="line">    <span class="type">const</span> string&amp; dispShftCmd, <span class="type">const</span> string&amp; shftCmd,</span><br><span class="line">    QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">CommandButton</span>(<span class="type">const</span> string&amp; dispPrimaryCmd, <span class="type">const</span> string&amp; primaryCmd,</span><br><span class="line">    QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">onClicked</span><span class="params">()</span></span>;</span><br><span class="line">signals:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clicked</span><span class="params">(string primCmd, string shftCmd)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CommandButton 类有两个构造函数：四参数重载和两参数重载。四参数重载允许指定主命令和次要命令，而两参数重载仅允许指定主命令。每个命令需要两个字符串进行完整指定。第一个字符串等于标签在 GUI 中呈现的文本，可以是按钮上的文本，也可以是移位命令的位置。第二个字符串等于将由 commandEntered() 事件引发的文本命令。可以通过要求这两个字符串相同来简化接口。然而，我选择添加显示与命令调度器所需文本不同的文本的灵活性。请注意，我们需要重载而不是默认参数，因为尾随的父指针。</p><p>接口的唯一其他公共部分是带有按钮的主要和移位命令的 clicked() 信号。先前讨论过两参数与一参数信号的理由。尽管是私有的，但我还是在 CommandButton 的接口中列出了 onClicked() 槽，以突出显示必须创建的私有槽，以捕获内部 QPushButton 的 clicked() 信号。onClicked() 函数的唯一目的是捕获 QPushButton 的 clicked() 信号，并用两个函数参数发出 CommandButton 的 clicked() 信号。</p><p>如果您查看 CommandButton.h 中的 CommandButton 类的实际声明，您会看到 CommandButton 公共接口的一部分还有一些附加功能。这些只是转发功能，它们可以更改外观（例如，文本颜色）或向底层 QPushButton 添加视觉元素（例如，工具提示）。虽然这些功能是 CommandButton 接口的一部分，但它们在功能上是可选的，与 CommandButton 的底层设计无关。</p><h3 id="6-3-4-获取输入">6.3.4 获取输入</h3><p>GUI 需要从用户那里获取两种不同类型的输入：数字和命令。两种输入类型都是通过排列在网格中的 CommandButtons（或映射到这些按钮的键盘快捷键）输入的。这些 CommandButtons 的集合、它们的布局以及它们与 GUI 其余部分的关联信号组成了 InputWidget 类。</p><p>命令输入在概念上很简单。点击 CommandButton，发出一个信号，反映该特定按钮的命令。最终，GUI 的另一部分将接收到这个信号，并引发一个 commandEntered() 事件，由命令调度器处理。</p><p>输入数字比输入命令稍微复杂一些。在 CLI 中，我们有幸能够简单地让用户输入数字，然后按 Enter 键完成输入。然而，在 GUI 中，我们没有这样的内置机制（假设我们希望在 Qt 窗口中实现比 CLI 更复杂的 GUI）。尽管计算器确实有一个输入数字的命令，但请记住，它假定输入的是完整的数字，而不是单个数字。因此，GUI 必须具有构建数字的机制。</p><p>构建数字包括输入数字以及特殊符号，如小数点、加/减运算符或指数运算符。此外，当用户输入时，他可能会犯错误，所以我们也需要启用基本的编辑功能（例如，退格键）。数字的组装是一个两步过程。InputWidget 仅负责发出用于组合和编辑数字所需的按钮点击。GUI 的另一部分将接收这些信号并组装完成的数字输入。</p><h3 id="6-3-5-InputWidget-的设计">6.3.5 InputWidget 的设计</h3><p>从概念上讲，InputWidget 类的设计非常简单。该小部件必须显示用于生成和编辑输入的按钮，将这些按钮绑定到键（如果需要），并在这些按钮被点击时发出信号。如前所述，InputWidget 包含用于数字输入和命令输入的按钮。因此，它负责数字 0-9，加/减按钮，小数点按钮，指数按钮，回车按钮，退格按钮，移位按钮以及每个命令的按钮。请回忆一下，作为一种经济手段，CommandButton 类允许每个可视按钮有两个不同的命令。</p><p>为了在整个 GUI 中保持一致性，我们将专门使用 CommandButton 作为所有输入按钮的表示，即使对于既不发出命令也没有次要操作的按钮（例如，数字 0 按钮）。我们的 CommandButton 设计是如此灵活真是太方便了！然而，这个决定仍然让我们面临两个未解决的设计问题。我们如何在视觉上布局按钮，以及在按钮被点击时该做什么？</p><p>在 InputWidget 中放置按钮有两种选择。首先，InputWidget 本身拥有一个布局，它将所有按钮放置在这个内部布局中，然后将 InputWidget 本身放置在主窗口的某个位置。另一种方法是让 InputWidget 在构建过程中接受一个外部拥有的布局，并将其 CommandButtons 放置在该布局上。总的来说，让 InputWidget 拥有自己的布局是更好的设计。与另一种方法相比，它具有更强的内聚性和减少的耦合。唯一的例外是，如果设计要求其他类共享相同的布局来放置额外的小部件。在这种特殊情况下，使用由两个类外部拥有的共享布局会更加清晰。</p><p>现在让我们关注一下在 InputWidget 内部点击按钮时会发生什么。因为 InputWidget 封装了 CommandButtons，所以每个 CommandButton 的 clicked() 信号对于 InputWidget 类的使用者来说并不是直接可访问的。因此，InputWidget 必须捕获所有 CommandButtons 的点击并重新发出它们。对于像正弦或正切这样的计算器命令，重新发出点击是一个简单的转发命令。实际上，Qt 为将 CommandButton 的 clicked() 信号直接连接到 InputWidget commandEntered() 信号提供了一种简写表示法，从而避免了需要通过 InputWidget 中的私有槽。数字、数字编辑按钮（例如加/减、退格）和计算器状态按钮（例如移位）的处理方式更好是通过在 InputWidget 中的私有槽捕获 CommandButton 的特定 clicked() 信号，然后发出一个针对这些操作的 InputWidget 信号。</p><p>正如刚才所描述的，当每个输入按钮被按下时，InputWidget 必须发出自己的信号。在一个极端，InputWidget 可以为每个内部 CommandButton 单独发出信号。在另一个极端，InputWidget 可以发出一个信号，无论按下哪个按钮，都通过参数区分操作。正如预期的那样，对于我们的设计，我们将寻求一些中间地带，从每个极端吸收元素。</p><p>本质上，InputWidget 接受三种不同类型的输入：修饰符（例如，回车、退格、加/减、移位）、科学计数法字符（例如，0-9、小数点、指数）或命令（例如，正弦、余弦等）。每个修饰符需要独特的响应；因此，每个修饰符都绑定到自己单独的信号上。另一方面，科学计数法字符可以通过在屏幕上显示输入字符来统一处理（这是 Display 类的角色）。因此，科学计数法字符都是通过发出一个将特定字符作为参数编码的单一信号来处理的。最后，命令通过发出一个单一的信号来处理，该信号只是将主要和次要命令原样作为函数参数传递给信号。</p><p>在构建信号处理时，保持 InputWidget 作为将原始用户输入发给其他 GUI 部分的类是非常重要的。让 InputWidget 解释按钮按压会导致问题。例如，假设我们设计 InputWidget 以聚合字符并且只发出完整、有效的数字。由于这种策略意味着不会为每个字符输入发出信号，字符在数字完成之前既不能显示也不能编辑。显然，这种情况是不可接受的，因为用户肯定希望在输入时看到屏幕上的每个字符。</p><p>现在让我们把注意力转向将设计转换为 InputWidget 的最小接口。</p><h3 id="6-3-6-InputWidget-的接口">6.3.6 InputWidget 的接口</h3><p>让我们通过呈现类声明来开始讨论 InputWidget 的接口。正如预期的那样，我们的清晰设计导致了一个简单的接口。请参见清单6-2。</p><p>清单6-2 InputWidget</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InputWidget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">InputWidget</span><span class="params">(QWidget* parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">characterEntered</span><span class="params">(<span class="type">char</span> c)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">enterPressed</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backspacePressed</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">plusMinusPressed</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shiftPressed</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">commandEntered</span><span class="params">(string, string)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本质上，整个类接口由与用户输入事件相对应的信号来定义。具体来说，我们有一个信号表示输入任何科学记数法字符，一个信号用于转发命令按钮点击，以及分别表示点击退格、回车、加/减或移位按钮的单独信号。</p><p>如果您在 GitHub 存储库源代码中的 InputWidget.cpp 文件中查看，您将找到一些额外的公共函数和信号。这些额外的功能是实现后续章节中引入的两个特性所必需的。首先，需要一个 addCommandButton() 函数和一个 setupFinalButtons() 函数来容纳动态添加的插件按钮，这是在第7章中引入的功能。其次，需要一个 procedurePressed() 信号来表示用户请求使用存储过程。存储过程在第8章中介绍。</p><h3 id="6-4-显示">6.4 显示</h3><p>从概念上讲，计算器有两个显示器，一个用于输入，一个用于输出。这种抽象可以在视觉上实现为两个单独的显示器或一个合并的输入/输出显示器。两种设计都是完全有效的；每个设计都在图6-3中说明。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/6.The-Graphical-User-Interface/A454125_1_En_6_Fig3_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图6-3 输入和输出显示选项  </div></center><p>选择一种 I/O 风格与另一种风格最终归结为客户的喜好。对两种风格没有特别的偏好，我选择了合并显示，因为它看起来更像我的 HP48S 计算器的显示。选择了显示样式后，现在让我们关注这个选择所暗示的设计影响。</p><p>如图6-3a所示，对于输入和输出的单独屏幕部件，选择具有单独输入和输出显示类的选择是显而易见的。输入显示将具有接收 InputWidget 信号的槽，输出显示将具有接收已完成数字（来自输入显示）和堆栈更新的槽。内聚性会很强，组件的分离也是恰当的。</p><p>然而，我们的设计要求一个混合输入/输出显示，如图6-3b所示。混合设计显著改变了使用独立输入和输出显示类的合理性。虽然将输入和输出显示问题合并到一个类中确实降低了显示的内聚性，但试图维护两个独立的类，这两个类都指向同一个屏幕部件，会导致实现变得笨拙。例如，选择哪个类应该拥有底层的 Qt 部件是任意的，可能会导致共享部件设计（也许使用 shared_ptr？）。然而，在这种情况下，输入或输出显示类应该初始化屏幕部件吗？如果输入显示共享指向单个显示部件的指针，那么输入显示向输出显示发出信号是否合理？答案很简单，对于合并的 I/O 显示部件，两类设计是不可行的，尽管我们可能更喜欢分离输入和输出显示的关注点。</p><p>上述讨论指出了一些有趣的观点。首先，屏幕上设计的视觉呈现可以合法地改变底层组件的设计和实现。虽然一旦提供了一个具体的 GUI 示例，这可能看起来很明显，但间接的含义是，如果屏幕部件只是稍微改变了一下，GUI 类设计可能需要显著改变。其次，存在这样的情况：当设计直接与第二章中假定的良好设计元素相矛盾时，结果更为简洁。显然，第二章中的指南旨在帮助设计过程，而不是作为不可侵犯的规则。也就是说，我的一般建议是，要保持清晰度优先于遵循指南，但只有在审慎考虑后才违反最佳实践。</p><p>既然我们已经决定使用一个单一的 I/O 显示和一个底层的 Display 类，那么让我们看看它的设计。</p><h3 id="6-4-1-Display-接口设计">6.4.1 Display 接口设计</h3><p>我承认。我最初为 Display 类设计和实现是笨拙的。我没有使用合适的分析技巧和预先设计，而是让设计和实现一起成长（也就是说，与实现一起成长）。然而，当我的设计迫使 Display 类发出 commandEntered() 信号以使 GUI 正常工作时，我知道这个设计有一个“不好的味道”。负责在屏幕上绘制数字的类可能不应该解释命令。也就是说，实现工作得很好，所以我保留了原来的代码并完成了计算器。然而，当我终于开始写关于设计的内容时，我在试图为我的设计找到一个合理的解释时遇到了很大的困难，最后不得不承认这个设计有致命的缺陷，迫切需要重写。</p><p>显然，在重新设计显示器之后，我本可以选择只描述改进后的产品。然而，我认为研究我第一次错误的尝试、讨论设计存在严重问题的明显迹象，最后看到经过一个晚上重构后最终浮现出的设计是有指导意义的。可能这里最有趣的教训是，糟糕的设计肯定会导致工作代码，所以永远不要认为工作代码是好设计的指标。此外，糟糕的设计（如果是局部的）可以被重构，有时候重构应该仅仅为了提高清晰度而进行。当然，重构假设你的项目计划包含足够的应急时间，以便不时地暂停支付技术债务。在回到更好的设计之前，让我们简要研究一下我的错误。</p><h3 id="6-4-2-糟糕的设计">6.4.2 糟糕的设计</h3><p>从上面的分析中，我们确定计算器应该有一个统一的 Display 类来处理输入和输出。我为显示设计的根本错误来自于错误地解释一个 Display 类暗示了没有其他类处理正交关注点。因此，我开始将所有没有由 InputWidget 类处理的功能放入一个单独的 Display 类中。让我们从这个路径开始。然而，与其像我之前所做的那样完成设计和实现，不如在我们看到第一个致命缺陷出现时就停止并重新设计这个类（这是我原本应该做的）。</p><p>对于一个单一的 Display 类设计，Display 类负责显示用户的输入和计算引擎的输出。显示输出是非常简单的。Display 类观察 stackChanged() 事件（间接地，因为它不是 GUI 的外部接口的一部分），并使用新的堆栈值更新屏幕显示部件（在这种情况下是 QLabel）。从概念上讲，显示输入也是非常简单的。Display 类直接接收 InputWidget 类发出的信号（例如，characterEntered()），并使用当前输入更新屏幕显示部件。这种交互的简单性掩盖了这个设计的根本问题，即输入不是原子性地输入显示。相反，它是通过输入多个字符并按 Enter 键最终输入而在多个信号上组装的。这种顺序构建输入意味着计算器必须维护一个活动输入状态，而输入状态在显示部件中是没有存在的必要的。</p><p>那么，除了意识形态上的反感之外，Display 类维护输入状态有什么问题呢？我们不能把状态简单地看作是一个显示输入缓冲区吗？让我们继续关注这个设计，看看它为什么有缺陷。例如，考虑退格键，其操作基于输入状态进行重载。如果当前输入缓冲区非空，退格键会从缓冲区中擦除一个字符。然而，如果当前输入缓冲区为空，按下退格键会发出从堆栈中删除顶部数字的命令。在这种设计下，Display 拥有输入状态并且是 backspacePressed() 信号的接收器，因此 Display 必须是从堆栈命令中删除数字的源头。一旦 Display 开始发出命令，我们就完全放弃了内聚性，现在是时候找到意大利面酱，因为接下来将产生意大利面条式代码。从这里开始，我没有放弃这个设计，而是加倍努力，我的原始设计实际上变得更糟。然而，与其继续沿着这个错误的道路前进，不如简单地继续探讨一种更好的方法。</p><h3 id="6-4-3-改进的显示设计">6.4.3 改进的显示设计</h3><p>在讨论糟糕的显示设计之初，我指出了一个致命的错误，即假设统一显示需要一个单一的类设计。然而，正如我们已经看到的，这个假设是无效的。计算器中状态的出现意味着至少需要两个类，一个用于可视化显示，一个用于状态。</p><p>这是否让你想起了我们已经看到的一个模式？GUI 需要维护一个内部状态（一个模型）。我们现在正在设计一个显示器（一个视图）。我们已经设计了一个类，InputWidget，用于接受输入并发出命令（一个控制器）。显然，GUI 本身只不过是一个熟悉模式的体现，即模型-视图-控制器（MVC）。请注意，相对于第 2 章图 2-2 中看到的 MVC 原型，GUI 可以用间接通信替代控制器和模型之间的直接通信。这种微小的变化，有助于降低耦合度，是通过 Qt 的信号和插槽机制实现的。</p><p>现在，我们将注意力转向新引入的模型类的设计。在模型完成后，我们将回到 Display 类，完成它现在更简单的设计和界面。</p><h2 id="6-5-模型">6.5 模型</h2><p>模型类，我恰当地称之为 GuiModel，负责 GUI 的状态。为了正确实现这个目标，模型必须成为导致系统状态改变的所有信号的接收器，同时也必须成为所有表示系统状态已改变的信号的来源。自然地，模型还是系统状态的存储库，它应该为 GUI 的其他组件提供查询模型状态的功能。让我们看一下 GuiModel 的接口，如清单 6-3 所示。</p><p>清单 6-3 GuiModel 接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuiModel</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum class</span> <span class="title class_">ShiftState</span> &#123; Unshifted, Shifted &#125;;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">State</span> &#123; <span class="comment">/* discussed below */</span> &#125;;</span><br><span class="line">  <span class="built_in">GuiModel</span>(QObject* parent = <span class="literal">nullptr</span>);</span><br><span class="line">  ~<span class="built_in">GuiModel</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stackChanged</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">double</span>&gt;&amp; v)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> State&amp; <span class="title">getState</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">  <span class="comment">// called to toggle the calculator&#x27;s shift state</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">onShift</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// paired to InputWidget&#x27;s signals</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">onCharacterEntered</span><span class="params">(<span class="type">char</span> c)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">onEnter</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">onBackspace</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">onPlusMinus</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">onCommandEntered</span><span class="params">(string primaryCmd, string secondaryCmd)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">modelChanged</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">commandEntered</span><span class="params">(string s)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">errorDetected</span><span class="params">(string s)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>GuiModel 类中的六个插槽都对应 InputWidget 类发出的信号。GuiModel 解释这些请求，根据需要改变内部状态，并发出一个或多个自己的信号。特别值得注意的是 commandEntered() 信号。虽然 GuiModel 的 onCommandEntered() 插槽接受两个参数，即按下的 CommandButton 对应的原始主要和次要命令，但 GuiModel 负责解释 GUI 的移位状态，并且只重新发出带有活动命令的 commandEntered() 信号。</p><p>GuiModel 接口的其余部分涉及 GUI 的状态。我们首先讨论嵌套 State 结构体背后的理由。我发现将所有状态参数归入一个结构体要比在 GuiModel 中将每个模型状态作为单独的成员声明要整洁得多。这种设计有助于查询模型状态，因为允许整个系统状态通过一个函数调用返回 const 引用，而不需要逐个访问单独的状态成员。我选择嵌套 State 结构体，因为它是 GuiModel 的内在部分，没有独立的作用。因此，State 结构体自然属于 GuiModel 的范围，但是为了让 GUI 的其他组件能够查询状态，必须公开声明。</p><p>State 结构体的成分定义了整个 GUI 的状态。特别是，这个 State 结构体包括一个数据结构，存储堆栈中可见数字的最大数量的副本，当前输入缓冲区，定义系统移位状态的枚举，以及定义输入缓冲区有效性的 Qt 枚举。声明如清单 6-4 所示。</p><p>清单 6-4 GuiModel 的 State 结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span></span><br><span class="line">&#123;</span><br><span class="line">  vector&lt;<span class="type">double</span>&gt; curStack;</span><br><span class="line">  string curInput;</span><br><span class="line">  ShiftState shiftState;</span><br><span class="line">  QValidator::State curInputValidity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个有趣的问题是，为什么 GuiModel 的 State 要从堆栈顶部缓冲可见数字？鉴于 Stack 类是一个单例，Display 可以直接访问 Stack。然而，Display 只观察 GuiModel 的变化（通过 modelChanged() 插槽）。由于与堆栈变化无关的状态变化在 GUI 中频繁发生（例如，字符输入），Display 将被迫在每个 modelChanged() 事件上浪费地查询 Stack，因为 Display 不是 stackChanged(67) 事件的直接观察者。另一方面，GuiModel 是 stackChanged() 事件的观察者（间接通过 MainWindow 的函数调用）。因此，高效的解决方案是让 GuiModel 只在计算器的堆栈实际发生变化时更新堆栈缓冲区，并让 Display 类访问这个缓冲区，以便更新屏幕。</p><h2 id="6-6-Display类再设计">6.6 Display类再设计</h2><p>我们现在准备回到 Display 类。将所有状态和状态交互放在 GuiModel 类中后，Display 类可以简化为一个对象，用于监视模型更改并在屏幕上显示计算器的当前状态。除了构造函数，Display 类的接口只包括两个功能：在模型发生变化时调用的插槽，以及在状态区域中显示消息的成员函数。后者的函数调用用于显示在 GUI 中检测到的错误（例如，输入无效）以及在命令分发器中检测到的错误（通过 UserInterface 的 postMessage() 传输）。Display 类的整个接口在清单 6-5 中给出。</p><p>清单 6-5 Display类接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Display</span><span class="params">(<span class="type">const</span> GuiModel&amp; g, QWidget* parent = <span class="literal">nullptr</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nLinesStack = <span class="number">6</span>, <span class="type">int</span> minCharWide = <span class="number">25</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">showMessage</span><span class="params">(<span class="type">const</span> string&amp; m)</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">onModelChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Display 类构造函数的可选参数只是简单地指定屏幕上堆栈的视觉外观。具体来说，Display 类的客户端可以自由选择要显示的堆栈行数和屏幕显示的最小宽度（以固定宽度字体字符为单位）。</p><h2 id="6-7-整合在一起：主窗口">6.7 整合在一起：主窗口</h2><p>主窗口是一个相对较小的类，但具有重要的作用。确切地说，在我们的应用程序中，它有三个目的。首先，和大多数基于 Qt 的 GUI 一样，我们需要提供一个公开继承自 QMainWindow 的类，自然地，它将作为应用程序的主 GUI 窗口。特别是，这是在启动 GUI 的函数中实例化和显示的类。按照我典型的创意命名风格，我将这个类称为 MainWindow。其次，MainWindow 作为计算器视图模块的接口类。也就是说，MainWindow 也必须公开继承我们的抽象 UserInterface 类。最后，MainWindow 类拥有所有先前讨论过的 GUI 组件，并根据需要将这些组件粘合在一起。实际上，将组件粘合在一起就是将信号连接到相应的槽。这些简单的实现细节可以在 MainWindow.cpp 源代码文件中找到。我们将在本节剩余部分讨论 MainWindow 的设计和接口。</p><p>我们已经编写了一个 Qt 应用程序；很明显，我们将在某个地方拥有一个 QMainWindow 的后代。这本身并不是非常有趣。然而，有趣的是决定使用多重继承使相同的类也充当 pdCalc 其余部分的 UserInterface。话虽如此，这是一个真正有趣的决定，还是因为一些开发人员对多重继承有道德反感而显得挑衅？</p><p>实际上，我可以将 QMainWindow 和 UserInterface 分为两个单独的类。在一个主窗口装饰有菜单、工具栏和多个底层小部件的 GUI 中，我可能会将这两者分开。然而，在我们的 GUI 中，QMainWindow 基本上除了为我们的 Qt 应用程序提供一个入口点之外没有其他用途。MainWindow 在 QMainWindow 角色中实际上什么都没做。因此，创建一个单独的 MainWindow 类，其唯一目的是包含一个具体的 UserInterface 类的特殊化，除了避免多重继承之外没有其他目的。虽然有些人可能不同意，但我认为在这种情况下，缺乏多重继承实际上会使设计变得复杂。</p><p>上述情况实际上是一个典型的例子，说明在哪里多重继承是一个很好的选择。特别是，多重继承在派生类中表现优秀，其多个基类具有正交功能。在我们的例子中，一个基类作为 Qt 的 GUI 入口点，而另一个基类作为 pdCalc 的 GUI 视图的 UserInterface 特化。注意，这两个基类都不共享功能、状态、方法或祖先。在至少有一个基类是纯抽象（没有状态，只有纯虚函数的类）的情况下，多重继承尤为明智。使用纯抽象基类的多重继承场景非常有用，以至于在其他不允许多重继承的编程语言中也被允许（例如，C＃和Java中的接口）。</p><p>MainWindow 的接口非常简单，仅包括一个构造函数、UserInterface 类中两个纯虚函数的重写以及一些用于动态添加命令的函数（在第7章中设计插件时，您将遇到这些函数）。为了完整起见，MainWindow 的接口显示在清单 6-6 中。</p><p>清单 6-6 MainWindow 的接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow, <span class="keyword">public</span> UserInterface</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">MainWindowImpl</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MainWindow</span>(<span class="type">int</span> argc, <span class="type">char</span>* argv[], QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">postMessage</span><span class="params">(<span class="type">const</span> string&amp; m)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stackChanged</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="comment">// plugin functions ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-8-外观与感觉">6.8 外观与感觉</h2><p>在本章结束之前，我们通过一些示例代码执行 GUI，我们必须简要回顾最后一个 GUI 组件，即 LookAndFeel 类。LookAndFeel 类只是管理 GUI 的动态可定制外观，例如字体大小和文本颜色。接口很简单。对于每个定制点，都有一个函数返回所请求的设置。例如，为了获得显示的字体，我们提供了以下功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LookAndFeel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// one function per customizable setting, e.g.,</span></span><br><span class="line">  <span class="function"><span class="type">const</span> QFont&amp; <span class="title">getDisplayFont</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为我们在计算器中只需要一个 LookAndFeel 对象，所以该类实现为单例。</p><p>一个很好的问题是，“我们为什么需要这个类？”答案是它为我们提供了根据当前环境动态修改计算器外观的机会，并在内存中集中存取 pdCalc 的外观和感觉。例如，假设我们想让我们的 GUI 具有 DPI 感知并相应选择字体大小（我在源代码中没有这样做，但您可能想要）。使用静态配置文件（或者，概念上等同的注册表设置），我们需要在安装过程中为每个平台定制设置。我们要么必须为每个平台构建安装程序中的定制功能，要么必须编写代码在安装过程中动态创建合适的静态配置文件。如果我们必须编写代码，为什么不将其放在源代码中呢？作为实现决策，LookAndFeel 类可以被设计为简单地读取一个配置文件并将外观属性缓存在内存中（一个外观和感觉代理对象）。这就是 LookAndFeel 类的真正力量。它使得外观属性的位置集中化，以便只需要更改一个类就可以实现全局外观变化。或许更重要的是，LookAndFeel 类将单个 GUI 组件与定义 GUI 如何发现（并可能适应）特定平台上的设置的实现细节隔离开来。</p><p>LookAndFeel 类的完整实现可以在 LookAndFeel.cpp 文件中找到。当前的实现非常简单。LookAndFeel 类为标准化 GUI 的外观和感觉提供了一种机制，但没有实现允许用户自定义应用程序的功能。第8章简要介绍了可以对 LookAndFeel 类进行的一些可能的扩展，以使 pdCalc 用户可定制。</p><h2 id="6-9-一个可运行的程序">6.9 一个可运行的程序</h2><p>本章结束时，我们将提供一个用于启动 GUI 的工作主函数。由于您将在第7章中遇到的其他要求，pdCalc 的实际 main() 函数比下面列出的要复杂得多。然而，这个简化版值得列出，以说明如何将 pdCalc 的组件与 GUI 结合在一起，创建一个功能完备的独立可执行文件。请参见清单 6-7。</p><p>Listing 6-7 A Working main() Function</p><p>清单 6-7 一个可运行的 main() 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QApplication app &#123; argc, argv &#125;;</span><br><span class="line">    MainWindow gui &#123; argc, argv &#125;;</span><br><span class="line">    CommandDispatcher ce &#123; gui &#125;;</span><br><span class="line">    <span class="built_in">RegisterCoreCommands</span>(gui);</span><br><span class="line">    gui.<span class="built_in">attach</span>(UserInterface::CommandEntered,</span><br><span class="line">        <span class="built_in">make_unique</span>&lt;CommandIssuedObserver&gt;(ce));</span><br><span class="line">    Stack::<span class="built_in">Instance</span>().<span class="built_in">attach</span>(Stack::StackChanged,</span><br><span class="line">        <span class="built_in">make_unique</span>&lt;StackUpdatedObserver&gt;(gui));</span><br><span class="line">    gui.<span class="built_in">setupFinalButtons</span>();</span><br><span class="line">    gui.<span class="built_in">show</span>();</span><br><span class="line">    gui.<span class="built_in">fixSize</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意上述执行 GUI 的 main() 函数与第 5 章结尾处列出的执行 CLI 的 main() 函数之间的相似之处。这些相似之处并非偶然，而是 pdCalc 模块化设计的结果。</p><p>与 CLI 一样，为了让您快速入门，仓库源代码中包含了一个项目，该项目使用上述 main() 函数作为应用程序的驱动程序构建一个可执行文件 pdCalc-simple-gui。该可执行文件是一个独立的 GUI，包含了本书到目前为止讨论的所有功能。</p><p>在结束本节之前，我将对上述实现做一些评论。首先，QApplication 类、调用 gui 上的 show() 和 app.exec() 调用都是 Qt 代码的样板代码。就我们在这里关心的问题而言，这些调用只是使我们能够启动 GUI 并将其显示在屏幕上。其次，gui 上调用了 setupFinalButtons()，但我们从未将此函数定义为 MainWindow 接口的一部分。在插件存在时，需要这个函数正确地添加按钮。在本章设计的独立 GUI 中，setupFinalButtons() 函数是不必要的。我在上述代码清单中包含了这个函数，以便上述 main() 函数可以与现有的 GitHub 仓库代码一起使用。最后，fixSize() 函数也没有包含在本章构建的接口中。这个函数是一个实现细节，对 GUI 的设计没有任何贡献。该函数仅用于固定屏幕上 GUI 的大小并消除调整大小的功能。同样，由于插件的原因，我们只有在插件添加了按钮之后才能知道 GUI 的最终几何形状，这个函数才变得必要。</p><h2 id="6-10-微软-Windows-构建说明">6.10 微软 Windows 构建说明</h2><p>pdCalc 旨在成为一个 GUI 和 CLI。在 Linux 中，控制台应用程序（CLI）和窗口应用程序（GUI）之间没有编译时区别。两种风格可以使用相同的构建标志编译统一应用程序。然而，在微软 Windows 中，创建既能作为 CLI 又能作为 GUI 的应用程序并不那么简单，因为操作系统要求在编译过程中声明使用控制台还是 Windows 子系统。</p><p>为什么在 Windows 上子系统的声明很重要？如果一个应用程序被声明为窗口应用程序，那么如果从命令提示符启动，应用程序将简单地返回而没有任何输出（即，应用程序看起来好像从未执行过）。然而，当双击应用程序图标时，应用程序将在没有背景控制台的情况下启动。另一方面，如果一个应用程序被声明为控制台应用程序，从命令提示符启动时 GUI 将出现，但如果通过双击应用程序图标打开，GUI 将在后台控制台中启动。</p><p>传统上，微软 Windows 应用程序是为一个子系统或另一个子系统而设计的。在少数情况下，应用程序同时具有 GUI 和 CLI，开发人员创建了技巧以避免上述问题。这样一种技巧是创建两个应用程序，一个 .com 和一个 .exe，操作系统可以根据通过命令行参数选择的选项适当地调用它们。</p><p>为了保持 pdCalc 的代码简单且跨平台，我忽略了这个问题，只是在控制台模式下构建了 GUI（然而，pdCalc-simple-gui 没有 CLI，是在窗口模式下构建的）。实际上，这意味着如果通过双击 pdCalc 图标启动应用程序，后台会出现一个额外的控制台窗口。如果您打算主要将应用程序用作 GUI，可以通过简单地删除使用控制台的功能来解决问题（例如，在 <a href="http://pdCalc.pro">pdCalc.pro</a> 构建文件中注释掉 win32:CONFIG += console 这一行）。如果您需要同时访问 CLI 和 GUI，而多余的控制台让您感到疯狂，您有两个现实的选择。首先，搜索互联网上面讨论过的其中一种技术并尝试一下。就我个人而言，我从未走过那条路。其次，构建两个单独的可执行文件（可能称为 pdCalc 和 pdCalc-cli），而不是基于命令行参数切换模式的一个可执行文件。应用程序的灵活架构可以轻松支持任何决策。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Practical C++ Design From Programming to Architecture 1ed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. 命令分发器</title>
      <link href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/"/>
      <url>/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/</url>
      
        <content type="html"><![CDATA[<h1>4. 命令分发器</h1><p>命令分发器是计算器的核心。作为 MVC 框架中的控制器，命令分发器负责应用程序的整个业务逻辑。本章不仅讨论计算器的命令分发器模块的具体设计，还更广泛地讨论松散耦合命令基础设施的灵活设计。</p><h2 id="4-1-命令分发器的分解">4.1 命令分发器的分解</h2><p>当我们分解堆栈时，第一个问题是：“堆栈应该划分为多少个组件？”现在我们也为命令分发器提出了同样的问题。为了回答这个问题，让我们考虑一下命令分发器必须封装的功能。命令分发器的功能是：</p><ol><li class="lvl-3"><p>存储已知命令的集合，</p></li><li class="lvl-3"><p>接收和解释这些命令的请求，</p></li><li class="lvl-3"><p>调度命令请求（包括撤销和重做的能力），以及</p></li><li class="lvl-3"><p>执行实际操作（包括更新计算器的状态）。</p></li></ol><p>在第二章中，我讨论了内聚原则。在类级别，为内聚性设计意味着每个类应该只做一件事，并且可以假定，做得很好。在最高分解层次上，命令分发器确实只做一件事：解释命令。然而，在任务层次上，从我们上面的功能列表中可以清楚地看出，它显然需要执行多个任务。因此，我们将命令分发器分解为几个不同的类，每个主要任务分配一个类。因此，我们有以下类：</p><ol><li class="lvl-3"><p>CommandRepository：存储可用命令的列表</p></li><li class="lvl-3"><p>CommandDispatcher：接收并解释执行命令的请求</p></li><li class="lvl-3"><p>CommandManager：调度命令并管理撤销和重做</p></li><li class="lvl-3"><p>Command hierarchy：执行命令</p></li></ol><p>本章余下部分致力于描述上述类和类层次结构的设计和显著实现细节。</p><h2 id="4-2-命令类">4.2 命令类</h2><p>在分解的这个阶段，我发现采用自下而上的设计方法更有用。在严格的自上而下的方法中，我们可能从接收和解释命令请求的 CommandDispatcher 类开始，然后一直深入到命令本身。然而，在这种自下而上的方法中，我们将从研究命令本身的设计开始。我们从被称为命令模式的抽象开始。</p><h3 id="4-2-1-命令模式">4.2.1 命令模式</h3><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/A454125_1_En_4_Fig1_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图4-1 命令模式的最简单层次结构  </div></center><p>从本质上讲，这种模式做了两件事。首先，它将命令的请求者与命令的调度者解耦。其次，它将对动作的请求（否则可能通过函数调用来实现）封装到一个对象中。这个对象可以携带状态，并在请求本身的即时生命周期之外具有延长的生命周期。</p><p>实际上，这两个特性给我们带来了什么？首先，由于请求者与调度者解耦，执行命令的逻辑不需要驻留在与执行命令的类相同的类或者相同的模块中。这显然降低了耦合度，但同时也提高了内聚性，因为可以为系统必须实现的每个独特命令创建一个独特的类。其次，由于请求现在被封装在与动作生命周期不同的命令对象中，命令既可以延迟执行（例如，排队命令），也可以撤销。撤销操作成为可能是因为已经执行的命令可以保留足够的数据以恢复到执行命令之前的状态。当然，将排队能力与撤销能力结合起来，允许为实现命令模式的所有请求创建无限制的撤销/重做功能。</p><h3 id="4-2-2-关于实现撤销-重做的更多内容">4.2.2 关于实现撤销/重做的更多内容</h3><p>pdCalc 的一个要求是实现无限撤销和重做操作。大多数书籍认为，通过仅在抽象命令接口中添加一个撤销命令，可以通过命令模式实现撤销。然而，这种简化处理忽略了正确实现撤销功能所需的实际细节。</p><p>实现撤销和重做涉及两个不同的步骤。首先（显然），在具体的命令类中必须正确实现撤销和重做。其次，必须实现一个数据结构来跟踪和存储分发的命令对象。自然地，这个数据结构必须保留命令执行的顺序，并能够分发撤销、重做或执行新命令的请求。在下面的第 4.4 节中详细描述了这个撤销/重做数据结构。现在讨论撤销和重做的实现。</p><p>实现撤销和重做操作本身通常是简单的。重做操作与命令的执行功能相同。只要在第一次执行命令之前和调用撤销之后系统的状态相同，那么实现重做命令本质上是免费的。这当然立即意味着，实现撤销实际上是要将系统的状态恢复到命令第一次执行之前。</p><p>撤销可以通过两种类似但略有不同的机制来实现，每种机制负责以不同的方式恢复系统的状态。第一种机制正如撤销的名称所暗示的：它接受系统的当前状态并真正地反转前进命令的过程。也就是说，从数学上讲，撤销是作为执行的逆操作来实现的。例如，如果前向操作是对栈顶数字取平方根，那么撤销操作将是对栈顶数字取平方。这种方法的优点是不需要存储额外的状态信息就能实现撤销。缺点是该方法不适用于所有可能的命令。让我们检查一下前面例子的相反情况。也就是说，考虑对栈顶数字进行平方。撤销操作将是对平方操作结果取平方根。然而，原始数字是平方的正根还是负根？在不保留额外状态信息的情况下，逆转方法会失效。</p><p>将撤销实现为逆操作的另一种方法是在命令首次执行之前保留系统的状态，然后将撤销实现为恢复到之前的状态。回到我们关于平方一个数的例子，前向操作既计算平方，又保存栈顶数字。然后，撤销操作通过从栈中删除结果并将保存的前向操作执行前的状态推送回来来实现。这个过程由命令模式启用，因为所有命令都实现为允许携带状态的具体命令类的实例。这种实现撤销的方法的一个有趣特点是操作本身不需要有数学逆。注意，在我们的例子中，撤销甚至不需要知道前向操作是什么。它只需要知道如何将栈顶元素替换为保存的状态。</p><p>在您的应用程序中使用哪种机制真的取决于您的应用程序执行的不同操作。当操作没有逆时，存储状态是唯一的选择。当逆操作计算成本过高时，存储状态通常是更好的实现。当存储状态的成本很高时，通过反转实现撤销是首选，假设存在逆操作。当然，由于每个命令都作为一个单独的类实现，整个系统不需要对如何实现撤销进行全局决策。针对特定操作的设计者可以自由选择适合该特定操作的方法，基于每个命令。在某些情况下，甚至混合方法（分别存储和反转操作的不同部分）可能是最佳的。在下一节中，我们将研究我为 pdCalc 做出的选择。</p><h3 id="4-2-3-将命令模式应用于计算器">4.2.3 将命令模式应用于计算器</h3><p>为了执行、撤销和重做计算器中的所有操作，我们将实现命令模式，每个计算器操作都将由派生自抽象 Command 类的自己的具体类封装。从上面关于命令模式的讨论中，我们可以看到，为了将模式应用于计算器，必须做出两个决定。首先，我们必须决定每个命令必须支持哪些操作。这组操作将定义 Command 基类的抽象接口。其次，我们必须选择如何支持撤销。准确地说，这个决定总是推迟到特定具体命令的实现者。然而，通过选择状态重构或命令反转，我们可以实现一些基础设施来简化命令实现者的撤销。我们将依次解决这两个问题。</p><h4 id="4-2-3-1-命令接口">4.2.3.1 命令接口</h4><p>选择在抽象Command类中包含哪些公共函数等同于为计算器中的所有命令定义接口。因此，这个决定不能轻率作出。虽然每个具体命令将执行不同的功能，但所有具体命令必须可以相互替代（回顾LSP）。因为我们希望接口最小但完整，我们必须确定能抽象地表示所有命令所需操作的最少函数数量。</p><p>首先要包括的两个命令是最明显且最容易定义的。它们分别是 execute() 和 undo()，分别用于执行命令的正向和逆向操作。这两个函数返回 void，不需要参数。不需要参数是因为计算器的所有数据都通过全局可访问的单例模式通过Stack类处理。此外，Command 类将需要一个构造函数和一个析构函数。因为这个类是带有虚拟函数的接口类，所以析构函数应该是虚拟的。Listing 4-1 展示了我们的第一次尝试接口。</p><p>Listing 4-1 命令接口的第一次尝试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Command</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 Listing 4-1 中，读者会立即注意到构造函数是受保护的，execute() 和 undo() 都是公共的且非虚拟的，并且存在单独的 executeImpl() 和 undoImpl() 虚拟函数。构造函数受保护的原因是向实现者发出信号，表示 Command 类不能直接实例化。当然，因为类包含纯虚拟函数，编译器无论如何都会阻止 Command 类的直接实例化。将构造函数设为受保护的有点多余。另一方面，使用虚拟和非虚拟函数组合定义公共接口值得更详细的解释。</p><p>通过公共非虚拟函数和私有虚拟函数的混合来为类定义公共接口是一种称为非虚拟接口（NVI）模式的设计原则。NVI模式规定，多态接口应始终使用非虚拟公共函数定义，这些函数将调用转发给私有虚拟函数。这个模式背后的原理非常简单。由于具有虚拟函数的基类充当接口类，客户端应该仅通过基类的接口通过多态访问派生类的功能。通过使公共接口非虚拟，基类实现者保留了在调度之前拦截虚拟函数调用的能力，以便为所有派生类实现的执行添加前置条件或后置条件。使虚拟函数私有会强制消费者使用非虚拟接口。在不需要前置条件或后置条件的简单情况下，非虚拟函数的实现简化为对虚拟函数的转发调用。坚持使用NVI模式，即使在简单的情况下，也是有道理的，因为它在零计算开销下保留了未来扩展的设计灵活性，因为转发函数调用可以内联。关于NVI模式的更深入的基本原理详见 Sutter [27]。</p><p>现在让我们考虑execute()和undo()是否需要前置条件或后置条件；我们从execute()开始。通过快速浏览第2章的用例，我们可以看到pdCalc必须完成的许多操作只有在满足一组前置条件后才能执行。例如，要将两个数相加，我们必须在栈上有两个数。显然，加法有一个前置条件。从设计角度来看，如果我们在命令执行之前捕获这个前置条件，我们可以在它们引起执行问题之前处理前置条件错误。在调用executeImpl()之前，我们肯定希望将检查前置条件作为基类execute()实现的一部分。</p><p>对于所有命令，必须检查哪些前置条件？也许，就像加法一样，所有命令都必须至少在栈上有两个数字？让我们再看一个用例。考虑求一个数的正弦值。这个命令只需要在栈上有一个数字。啊，前置条件是特定于命令的。关于通用处理前置条件的问题的正确答案是要求派生类通过让execute()首先调用一个checkPreconditionsImpl()虚拟函数来检查它们自己的前置条件。</p><p>关于execute()的后置条件怎么样呢？事实证明，如果满足每个命令的前置条件，那么所有命令在数学上都定义良好。很好，不需要进行后置条件检查！不幸的是，数学正确性不能确保浮点数计算没有错误。例如，即使加法在数学上定义良好，使用pdCalc所需的双精度数进行浮点加法也可能导致正溢出。然而，幸运的是，我们第一章的要求规定可以忽略浮点错误。因此，在技术上我们不需要处理浮点错误，最终也不需要进行后置条件检查。</p><p>为了保持代码相对简单，我选择遵循要求，在pdCalc中忽略浮点异常。如果我想在设计中积极捕获浮点错误，可以使用checkPostconditions()函数。因为浮点错误对所有命令都是通用的，所以后置条件检查可以在基类级别处理。</p><p>了解我们的前置条件和后置条件需求，使用NVI模式，我们能够编写如下图4-2所示的简单execute()实现。</p><p>Listing 4-2 execute()的简单实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Command::execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">checkPreconditionsImpl</span>();</span><br><span class="line">  <span class="built_in">executeImpl</span>();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到checkPreconditionsImpl()和executeImpl()都必须被派生类连续调用和处理，我们能否将这两个操作合并到一个函数调用中？我们可以这样做，但这样的决策会导致次优的设计。首先，通过将这两个操作合并到一个executeImpl()函数调用中，我们将失去内聚性，因为要求一个函数执行两个不同的操作。其次，通过使用单独的checkPreconditionsImpl()调用，我们可以选择强制派生类实现者检查前置条件（通过使checkPreconditionsImpl()纯虚拟）或者为前置条件检查提供一个可选的默认实现。最后，谁能说checkPreconditionsImpl()和executeImpl()将分发给相同的派生类？请记住，层次结构可以有多个级别。</p><p>与execute()函数类似，人们可能会认为撤销命令需要进行前置条件检查。然而，事实证明，我们实际上不必检查撤销的前置条件，因为它们在构造过程中总是为真。也就是说，由于撤销命令只能在执行命令成功完成后调用，因此undo()的前置条件是确保满足的（当然，前提是execute()的正确实现）。与正向执行一样，undo()也不需要进行后置条件检查。</p><p>对execute()和undo()的前置条件和后置条件的分析仅导致在虚拟接口中添加了一个函数checkPreconditionImpl()。然而，为了使这个函数的实现完整，我们必须确定这个函数的正确签名。首先，函数的返回值应该是什么？我们可以选择使返回值为空并通过异常处理前置条件的失败，或者使返回值为一种可以表示前置条件未满足的类型（例如，在前置条件失败时返回false的布尔值或表示发生的故障类型的枚举）。对于pdCalc，我选择通过异常处理前置条件失败。这种策略具有更高的灵活性，因为错误不需要由直接调用者execute()函数处理。此外，可以设计异常以携带可由派生命令扩展的自定义描述性错误消息。这与使用枚举类型形成对比，后者必须由基类实现者完全定义。</p><p>我们在指定checkPreconditionImpl()的签名时必须解决的第二个问题是选择该函数应该是纯虚拟的还是具有默认实现。尽管大多数命令确实需要满足一些前置条件，但并非所有命令都是如此。例如，将新数字输入堆栈不需要前置条件。因此，checkPreconditionImpl()不应该是一个纯虚拟函数。相反，它被赋予一个默认实现，即什么也不做，这相当于声明前置条件已满足。</p><p>由于命令中的错误是通过checkPreconditionImpl()函数检查的，任何命令的正确实现都不应该从checkPreconditionImpl()之外抛出异常。因此，为了增加接口保护，Command类中的每个纯虚拟函数都应标记为noexcept。为了简洁起见，我在文本中经常省略这个关键字；然而，noexcept确实出现在实现中。这个说明符在实现插件命令时才真正重要，插件命令将在第7章中讨论。</p><p>接下来要添加到Command类中的一组函数是用于多态地复制对象的函数。这组函数包括一个受保护的复制构造函数，一个公共的非虚拟clone()函数和一个私有的cloneImpl()函数。在这一设计阶段，为什么命令必须是可复制的还不能得到充分的解释。然而，当我们审查CommandRepository的实现时，原因将变得清晰。然而，为了连贯性，我现在将讨论复制接口的实现。</p><p>对于为多态使用而设计的类层次结构，简单的复制构造函数是不够的，对象的复制必须通过克隆虚拟函数执行。考虑以下仅显示复制构造函数的简略命令层次结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Command</span>(<span class="type">const</span> Command&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Add</span>(<span class="type">const</span> Add&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们的目标是复制多态地使用的命令。让我们看下面的例子，我们通过一个Command指针持有一个Add对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command* p = <span class="keyword">new</span> Add;</span><br></pre></td></tr></table></figure><p>根据定义，复制构造函数将自身类类型的引用作为其参数。因为在多态设置中我们不知道底层类型，我们必须尝试调用复制构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> Command&#123;*p&#125;;</span><br></pre></td></tr></table></figure><p>上述构造是非法的，将无法编译。因为Command类是抽象的（且其复制构造函数受保护），编译器不允许创建Command对象。然而，并非所有层次结构都有抽象基类，因此在那些合法的情况下，人们可能会尝试这种构造。小心。这种构造会切断层次结构。也就是说，p2将作为一个Command实例而不是一个Add实例构造，p中的任何Add状态都将在复制中丢失。</p><p>既然我们不能直接使用复制构造函数，那么如何在多态环境中复制类呢？解决方案是提供一个虚拟克隆操作，可以如下使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command* p2 = p-&gt;<span class="built_in">clone</span>();</span><br></pre></td></tr></table></figure><p>这里，非虚拟clone()函数将克隆操作分派给派生类的cloneImpl()函数，其实现只是用解引用的this指针作为参数调用自己的复制构造函数。对于上面的示例，扩展的接口和实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Command* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">cloneImpl</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Command</span>(<span class="type">const</span> Command&amp;) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Command* <span class="title">cloneImpl</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Add</span>(<span class="type">const</span> Add&amp; rhs)</span><br><span class="line">        : Command &#123; rhs &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Add* <span class="title">cloneImpl</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Add &#123; *<span class="keyword">this</span> &#125;; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里唯一有趣的实现特性是cloneImpl()函数的返回类型。注意，基类将返回类型指定为Command*，而派生类将返回类型指定为Add*。这种构造称为返回类型协变，这是一条规则，它规定派生类中的覆盖函数可以返回比虚拟接口中的返回类型更具体的类型。协变允许克隆函数总是返回与调用克隆的层次结构级别相对应的特定类型。对于具有公共克隆函数并允许从层次结构的所有级别进行克隆调用的实现，这个特性非常重要。</p><p>我选择用帮助消息函数和相应的虚拟实现函数来完善命令接口。这个帮助函数的目的是强制单个命令实现者为用户界面中的帮助命令提供简要的文档。帮助函数对于命令的功能并非必要，将其作为设计的一部分是可选的。然而，即使在一个像计算器这样简单的程序中，提供一些内部文档来描述命令的用法总是很好的。</p><p>结合所有上述信息，我们终于可以为我们的Command类编写完整的抽象接口；请参见列表4-3。</p><p>列表4-3 Command类的完整抽象接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Command* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">helpMessage</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Command</span>();</span><br><span class="line">    <span class="built_in">Command</span>(<span class="type">const</span> Command&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">checkPreconditionsImpl</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Command* <span class="title">cloneImpl</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">helpMessageImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你查看Command.h中的源代码，你还会看到一个虚拟的deallocate()函数。这个函数专门用于插件，它在接口中的添加将在第7章中讨论。</p><hr><p>现代C++设计注意事项：override关键字</p><p>override关键字在C<ins>11中引入。从功能上讲，它可以防止一个常见的错误，这种错误通常让新的C</ins>程序员感到惊讶。请考虑以下代码片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Base* p = <span class="keyword">new</span> Derived;</span><br><span class="line">p-&gt;<span class="built_in">foo</span>(<span class="number">2.1</span>);</span><br></pre></td></tr></table></figure><p>哪个函数被调用？大多数初学者C++程序员认为应该调用Derived::foo()，因为他们期望Derived的foo()覆盖了Base的实现。然而，由于foo()函数在基类和派生类之间的签名不同，Base的foo()实际上隐藏了Derived的实现，因为重载不能跨范围边界进行。因此，调用p-&gt;foo()将调用Base的foo()，而不管参数的类型如何。有趣的是，出于相同的原因</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">d-&gt;<span class="built_in">foo</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>永远只能调用Derived的foo()。</p><p>在C<ins>03和C</ins>11中，上述代码以完全相同的令人困惑但技术上正确的方式运行。然而，从C++11开始，派生类可以选择使用override关键字标记覆盖函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，编译器将标记声明为错误，因为程序员明确声明派生函数应该覆盖。因此，添加override关键字可以防止一个令人困惑的错误发生，让程序员明确自己的意图。</p><p>从设计的角度来看，override关键字明确地将函数标记为覆盖。虽然这可能看起来不重要，但在处理大型代码库时非常有用。在实现一个基类位于代码的另一个独立部分的派生类时，不查看基类的声明就能知道哪些函数覆盖了基类函数，哪些没有，这是很方便的。</p><hr><h4 id="4-2-3-2-撤销策略">4.2.3.2 撤销策略</h4><p>定义了命令的抽象接口后，我们接下来要设计撤销策略。从技术上讲，因为我们接口中的undo()命令是纯虚拟的，我们可以简单地摆手表示撤销的实现是每个具体命令的问题。然而，这样既不优雅也不高效。相反，我们寻求所有命令（或者至少是命令分组）的一些功能共性，这可能使我们能够在比命令层次结构中的每个叶子节点更高的层次上实现撤销。</p><p>如前所述，撤销可以通过命令反演或状态重建（或两者的某种组合）来实现。命令反演已经被证明是有问题的，因为对于某些命令来说，逆问题是不适定的（具体来说，它有多个解）。因此，让我们来研究状态重建作为pdCalc的一种通用撤销策略。</p><p>我们通过考虑一个用例，加法操作来开始分析。加法从堆栈中移除两个元素，将它们相加，并返回结果。一个简单的撤销可以通过从堆栈中删除结果并恢复原始操作数来实现，前提是这些操作数是由execute()命令存储的。现在，考虑减法、乘法或除法。这些命令也可以通过删除它们的结果和恢复它们的操作数来撤销。难道对所有命令实现撤销就这么简单，我们只需要在execute()过程中存储堆栈顶部的两个值，并通过删除命令的结果和恢复存储的操作数来实现撤销吗？不是的。考虑正弦、余弦和正切。它们每个都从堆栈中取一个操作数并返回一个结果。考虑交换。它从堆栈中取两个操作数并返回两个结果（相反顺序的操作数）。在所有命令上实现一个完全统一的撤销策略是不可能的。话虽如此，我们也不应该放弃希望，回到为每个命令单独实现撤销。</p><p>仅仅因为我们的计算器中所有命令都必须从Command类继承，并不意味着这种继承必须是图4-1中所示的直接继承。相反，考虑图4-2中所示的命令层次结构。虽然有些命令仍然直接从Command基类继承，但我们已经创建了两个新的子类，从这些子类可以继承更专门的命令。事实上，如稍后将看到的，这两个新基类本身就是抽象的。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/A454125_1_En_4_Fig2_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图4-2 计算器命令模式的多级层次结构  </div></center><p>我们前面的用例分析确定了两个显著的操作子类别，这些子类别分别为其成员实现了统一的撤销操作：二元命令（接受两个操作数并返回一个结果的命令）和一元命令（接受一个操作数并返回一个结果的命令）。因此，我们可以通过通用地处理这两个类别的命令来显著简化我们的实现。虽然不属于一元或二元命令族的命令仍然需要单独实现undo()，但这两个子类别占计算器核心命令的约75%。创建这两个抽象将节省大量工作。</p><p>让我们来看一下UnaryCommand类。根据定义，所有一元命令都需要一个参数并返回一个值。例如，f(x) = sin(x)从堆栈中取一个数，x，并将结果f(x)返回到堆栈上。如前所述，将所有一元函数作为一个家族来考虑的原因是，无论函数如何，所有一元命令都以相同的方式实现前向执行和撤销操作，仅在f的功能形式上有所不同。此外，它们还必须至少满足相同的前提条件。也就是说，堆栈上必须至少有一个元素。</p><p>在代码中，通过在UnaryCommand基类中重写executeImpl()、undoImpl()和checkPreconditionsImpl()，并创建一个新的unaryOperation()纯虚函数将每个命令的精确实现委托给一个更进一步派生的类来强制执行一元命令的上述共性。结果是一个具有如下声明的UnaryCommand类，见列表4-4。</p><p>列表4-4 UnaryCommand类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnaryCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">UnaryCommand</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkPreconditionsImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="built_in">UnaryCommand</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">UnaryCommand</span>(<span class="type">const</span> UnaryCommand&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">unaryOperation</span><span class="params">(<span class="type">double</span> top)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> top_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了完整起见，让我们来看一下从Command重写的三个函数的实现。检查前提条件是微不足道的；我们确保堆栈上至少有一个元素。如果没有，则抛出异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UnaryCommand::checkPreconditionsImpl</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Stack::<span class="built_in">Instance</span>().<span class="built_in">size</span>() &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> Exception&#123;<span class="string">&quot;Stack must have one element&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executeImpl()命令也相当简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UnaryCommand::executeImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top_ = Stack::<span class="built_in">Instance</span>().<span class="built_in">pop</span>(<span class="literal">true</span>);</span><br><span class="line">  Stack::<span class="built_in">Instance</span>().<span class="built_in">push</span>( <span class="built_in">unaryOperation</span>(top_) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆栈顶部的元素被弹出并存储在UnaryCommand的状态中以便撤销。请记住，因为我们已经检查了前提条件，我们可以确保unaryOperation()将在没有错误的情况下完成。具有特殊前提条件的命令仍然需要实现checkPreconditionsImpl()，但它们至少可以将一元前提条件检查委托给UnaryCommand的checkPreconditionImpl()函数。然后，我们一举将一元函数操作分派到一个更派生的类，并将其结果推回堆栈。</p><p>UnaryCommand的executeImpl()函数中唯一的特殊之处是堆栈的pop命令的布尔参数。这个布尔值可选地抑制发出堆栈更改事件。因为我们知道接下来的push命令会立即再次更改堆栈，所以没有必要发出两个连续的堆栈更改事件。抑制这个事件允许命令实现者将命令的动作归为一个用户可见的事件。虽然这个布尔参数不是Stack的pop()的原始设计的一部分，但这个功能现在可以作为一个便利添加到Stack类中。请记住，设计是迭代的。</p><p>最后要检查的成员函数是undoImpl()：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UnaryCommand::undoImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack::<span class="built_in">Instance</span>().<span class="built_in">pop</span>(<span class="literal">true</span>);</span><br><span class="line">    Stack::<span class="built_in">Instance</span>().<span class="built_in">push</span>(top_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数也具有预期的明显实现。一元操作的结果从堆栈中删除，而在执行executeImpl()期间存储在类的top_成员中的前一个顶部元素被恢复到堆栈。</p><p>作为使用UnaryCommand类的示例，我们展示了正弦命令的部分实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sine</span> : <span class="keyword">public</span> UnaryCommand &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">unaryOperation</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">sin</span>(t); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显然，使用UnaryCommand作为基类而不是最高级别的Command类的优势在于，我们不再需要实现undoImpl()和checkPreconditionsImpl()，并用稍微简单的unaryOperation()替换了executeImpl()的实现。我们不仅需要更少的总体代码，而且由于所有一元命令的undoImpl()和checkPreconditionsImpl()的实现是相同的，我们还减少了代码重复，这总是一个好处。</p><p>二元命令的实现与一元命令类似。唯一的区别是执行操作的函数需要两个命令作为操作数，并相应地必须存储这两个值以进行撤销。BinaryCommand类的完整定义可以在GitHub存储库中的源代码中找到，与Command和UnaryCommand类一起位于Command.h头文件中。</p><h4 id="4-2-3-3-具体命令">4.2.3.3 具体命令</h4><p>定义了上述的Command、UnaryCommand和BinaryCommand类，完成了在计算器中使用命令模式的抽象接口。正确实现这些接口占据了命令设计的主要部分。然而，到目前为止，我们的计算器还没有一个具体的命令（除了部分正弦类实现）。本节将最终解决这个问题，我们的计算器的核心功能将开始成型。</p><p>计算器的核心命令都定义在CoreCommands.h文件中，它们的实现可以在相应的CoreCommands.cpp文件中找到。什么是核心命令？我将核心命令定义为从第1章中列出的要求中提炼出的功能的命令集。对于计算器必须执行的每个不同操作，都存在一个独特的核心命令。为什么我称之为核心命令？因为它们与计算器一起编译和链接，因此在计算器加载时立即可用。实际上，它们是计算器的内在组成部分。这与插件命令形成对比，插件命令可以在运行时动态地由计算器选择加载。插件命令将在第7章详细讨论。</p><p>虽然人们可能会怀疑我们现在需要进行分析以确定核心命令，但事实证明，这种分析已经完成。具体来说，核心命令是由第2章中用例描述的动作定义的。敏锐的读者甚至会记得，用例中的异常列表定义了每个命令的前提条件。因此，在必要时参考用例，人们可以轻松地推导出核心命令。为方便起见，它们都列在表4-1中。</p><p>表4-1 按照其直接抽象基类列出的核心命令</p><table><thead><tr><th>Command</th><th>UnaryCommand</th><th>BinaryCommand</th></tr></thead><tbody><tr><td>EnterCommand</td><td>Sine</td><td>Add</td></tr><tr><td>SwapTopOfStack</td><td>Cosine</td><td>Subtract</td></tr><tr><td>DropTopOfStack</td><td>Tangent</td><td>Multiply</td></tr><tr><td>Duplicate</td><td>Arcsine</td><td>Divide</td></tr><tr><td>ClearStack</td><td>Arccosine</td><td>Power</td></tr><tr><td></td><td>Arctangent</td><td>Root</td></tr><tr><td></td><td>Negate</td><td></td></tr></tbody></table><p>在将上述核心命令列表与第2章的用例进行比较时，可以注意到撤消和重做作为命令的明显缺失，尽管它们都是用户可以要求计算器执行的操作。这两个“命令”很特殊，因为它们对系统中的其他命令起作用。出于这个原因，它们并没有按照命令模式的意义实现为命令。相反，它们由尚待讨论的 CommandManager 从内部处理，这个类负责请求命令、调度命令以及请求撤消和重做操作。撤消和重做操作（与每个命令定义的撤消和重做操作相对）将在下面的第4.4节中详细讨论。</p><p>每个核心命令的实现，包括前提条件的检查、正向操作和撤消实现，都相对简单。大多数命令类可以用大约20行代码实现。如果感兴趣的读者希望查看细节，可以参考存储库源代码。</p><h4 id="4-2-3-4-深度命令层次结构的替代方案">4.2.3.4 深度命令层次结构的替代方案</h4><p>为每个操作创建一个单独的 Command 类是实现命令模式的非常经典的方式。然而，现代C++为我们提供了一个非常引人注目的替代方案，使我们能够将层次结构展平。具体来说，我们可以使用 lambda 表达式（请参见边栏）来封装操作，而不是创建额外的派生类，然后在 UnaryCommand 或 BinaryCommand 级别使用标准函数类（请参见边栏）来存储这些操作。为了使讨论具体化，让我们考虑 BinaryCommand 类的另一种部分设计，如 Listing 4-5 所示。</p><p>Listing 4-5 另一种部分设计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryCommandAlternative</span> <span class="keyword">final</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line">    <span class="keyword">using</span> BinaryCommandOp = <span class="built_in">double</span>(<span class="type">double</span>, <span class="type">double</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BinaryCommandAlternative</span>(<span class="type">const</span> string&amp; help, naryCommandOp&gt; f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkPreconditionsImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">helpMessageImpl</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undoImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="type">double</span> top_;</span><br><span class="line">    <span class="type">double</span> next_;</span><br><span class="line">    string helpMsg_;</span><br><span class="line">    function&lt;BinaryCommandOp&gt; command_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们不是声明一个实现 executeImpl() 的抽象 BinaryCommand，并通过将其推迟到 binaryOperation() 虚拟函数，而是声明一个接受可调用目标的具体和最终（请参见边栏）类，并通过调用此目标来实现 executeImpl()。事实上，BinaryCommand 和 BinaryCommandAlternative 之间唯一的实质性区别是 executeImpl() 命令的实现方式有一个微妙的区别；参见 Listing 4-6。</p><p>Listing 4-6 一个微妙的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryCommandAlternative::executeImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top_ = Stack::<span class="built_in">Instance</span>().<span class="built_in">pop</span>(<span class="literal">true</span>);</span><br><span class="line">    next_ = Stack::<span class="built_in">Instance</span>().<span class="built_in">pop</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// invoke callable target instead of virtual dispatch:</span></span><br><span class="line">    Stack::<span class="built_in">Instance</span>().<span class="built_in">push</span>(<span class="built_in">command_</span>(next_, top_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，举个例子，我们不是声明一个 Multiply 类并实例化一个 Multiply 对象，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mult = <span class="keyword">new</span> Multiply;</span><br></pre></td></tr></table></figure><p>我们创建一个能够执行乘法的 BinaryCommandAlternative，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mult = <span class="keyword">new</span> BinaryCommandAlternative&#123; <span class="string">&quot;help msg&quot;</span>,</span><br><span class="line">  [](<span class="type">double</span> d, <span class="type">double</span> f)&#123; <span class="keyword">return</span> d * f; &#125; &#125;;</span><br></pre></td></tr></table></figure><p>为了完整起见，我要提到，因为没有类进一步派生自 BinaryCommandAlternative，我们必须在构造函数中直接处理帮助消息，而不是在派生类中处理。此外，如实现的那样，BinaryCommandAlternative 只处理二元前提条件。然而，可以通过类似于处理二元操作的方式处理额外的前提条件。也就是说，在 checkPreconditionImpl() 中测试两个堆栈参数之后，构造函数可以接受并存储一个执行前提条件测试的 lambda。</p><p>显然，一元命令可以通过创建 UnaryCommandAlternative 类类似地处理二元命令。通过足够的模板，我相信你甚至可以将二元命令和一元命令统一到一个类中。然而，请注意，过多的巧妙做法，虽然在办公室里令人印象深刻，但通常不会导致可维护的代码。在这个扁平化的命令层次结构中，为二元命令和一元命令保持单独的类可能会在简洁性和可理解性之间取得适当的平衡。</p><p>BinaryCommand 的 executeImpl() 和 BinaryCommandAlternative 的 executeImpl() 之间的实现差异相当小。然而，你不应该低估这种变化的重要性。最终结果是命令模式实现的显著设计差异。在一般情况下，一个比另一个好吗？我认为这种说法不能毫不含糊地做出；每种设计都有权衡。BinaryCommand 策略是命令模式的经典实现，大多数有经验的开发人员都会将其视为这样。源代码非常容易阅读、维护和测试。对于每个命令，创建一个执行一个操作的类。另一方面，BinaryCommandAlternative 非常简洁。与为 n 个操作创建 n 个类相比，只有一个类存在，每个操作由构造函数中的一个 lambda 定义。如果代码简洁是你的目标，这种替代风格是难以击败的。然而，因为 lambda 本质上是匿名对象，所以通过不在系统中为每个二元操作命名而失去了一些清晰度。</p><p>对于 pdCalc，深层命令层次结构还是浅层命令层次结构哪个策略更好？就我个人而言，我更喜欢深层命令层次结构，因为为每个对象命名带来的清晰度。然而，对于诸如加法和减法之类的简单操作，我认为可以认为减少的代码行数比通过匿名性损失的清晰度更能提高清晰度。由于我个人的喜好，我使用深层层次结构和 BinaryCommand 类实现了大多数命令。尽管如此，我确实通过 BinaryCommandAlternative 实现了乘法，以说明实践中的实现。在生产系统中，我强烈建议选择其中一种策略。在同一系统中实现两种模式肯定比采用一种更令人困惑，即使选择的那个被认为是次优的。</p><hr><p>现代 C++ 设计注意事项：Lambda、标准函数和 final 关键字</p><p>Lambda、标准函数和 final 关键字实际上是三个独立的现代 C++ 概念。因此，我将分别讨论它们。</p><p><b>Lambdas:</b></p><p>Lambda（更正式地说，lambda 表达式）可以被认为是匿名函数对象。理解 Lambda 的最简单方法是考虑它们的函数对象等价物。定义 Lambda 的语法如下所示：<br>capture-list{function-body}</p><p>上述 Lambda 语法与通过构造函数将 capture-list 存储为成员变量的函数对象完全相等，并提供一个带有由 argument-list 提供的参数和由 function-body 提供的函数体的 operator() const 成员函数。 operator() 的返回类型通常从函数体中推导出来，但如果需要，可以使用替代函数返回类型语法（即，在参数列表和函数体之间使用 -&gt; ret）手动指定。</p><p>鉴于 Lambda 表达式和函数对象之间的等价性，Lambda 实际上并没有为 C++ 提供新功能。在 C<ins>11 中可以使用 Lambda 完成的任何操作，在 C</ins>03 中都可以使用不同的语法完成。然而，Lambda 提供的是一种引人注目、简洁的内联、匿名函数声明语法。 Lambda 的两个非常常见的用例是作为 STL 算法的谓词和 C++11 异步任务的目标。有人甚至认为 Lambda 语法如此引人注目，以至于在高级代码中不再需要编写 for 循环，因为它们可以用 Lambda 和算法替换。就我个人而言，我觉得这种观点太极端了。</p><p>在二元命令的替代设计中，您看到了 Lambda 的另一个用途。它们可以存储在对象中，然后根据需求调用，为实现算法提供不同的选项。在某些方面，这种范例编码了策略模式的微型应用。为了避免与命令模式混淆，我特意没有在正文中介绍策略模式。有兴趣的读者可以参考 Gamma 等人[6]的详细信息。</p><p><b>标准函数：</b></p><p>函数类是 C++ 标准库的一部分。这个类为任何可调用目标提供了一个通用的包装器，将这个可调用目标转换为一个函数对象。本质上，任何像函数一样可以被调用的 C++ 结构都是可调用目标。这包括函数、Lambda 和成员函数。</p><p>标准函数提供了两个非常有用的特性。首先，它为与任何可调用目标进行接口提供了通用设施。也就是说，在模板编程中，将可调用目标存储在函数对象中可以统一对目标的调用语义，而不依赖于底层类型。其次，函数可以存储其他难以存储的类型，如 Lambda 表达式。在设计 BinaryCommandAlternative 时，我们利用了函数类来存储 Lambda，以实现小算法，将策略模式覆盖到命令模式上。尽管实际上没有在 pdCalc 中使用，但函数类的通用性实际上使得 BinaryCommandAlternative 构造函数可以接受除 Lambda 之外的可调用目标。</p><p><b> final 关键字：</b></p><p>final 关键字在 C<ins>11 中引入，使类设计者可以声明一个类不能从中继承，或者一个虚拟函数不能再被重写。对于那些来自 C# 或 Java 的程序员来说，你会知道 C</ins> 在最后（顺便说一句，这是有意的）添加这个功能方面晚了一步。</p><p>在 C<ins>11 之前，需要使用恶心的黑客手段来防止类的进一步派生。从 C</ins>11 开始，final 关键字使编译器可以强制执行此约束。在 C<ins>11 之前，许多 C</ins> 设计者认为 final 关键字是不必要的。希望让一个类不可继承的设计者可以将析构函数设置为非虚拟的，从而暗示从这个类派生是在设计者的意图之外。任何看过从 STL 容器继承的代码的人都会知道，开发者在不受编译器强制执行的意图上遵循得有多好。你多久听到一位开发人员说：“当然，通常来说这是个坏主意，但是，别担心，对我这个特殊情况来说没问题。”这种经常被说出的评论几乎总是紧接着一周长的调试会议，以追踪到晦涩的错误。</p><p>你为什么可能想要防止从一个类继承或者重写先前声明的虚拟函数？可能是因为你遇到了一个情况，即使语言定义得很好，从逻辑上来说继承也没有意义。一个具体的例子是 pdCalc 的 BinaryCommandAlternative 类。虽然你可以尝试从它派生并重写 executeImpl() 成员函数（也就是说，没有 final 关键字），但这个类的目的是终止层次结构并通过可调用目标提供二元操作。从 BinaryCommandAlternative 继承是在其设计范围之外。因此，防止派生可能会防止微妙的语义错误。</p><hr><h2 id="4-3-命令仓库">4.3 命令仓库</h2><p>现在我们的计算器拥有了满足其需求的所有命令。然而，我们尚未定义存储命令并随后按需访问它们所需的基础设施。在本节中，我们将探讨存储和检索命令的几种设计策略。</p><h3 id="4-3-1-CommandRepository-类">4.3.1 CommandRepository 类</h3><p>乍一看，实例化一个新的命令似乎是一个很容易解决的问题。例如，如果用户要求两个数字相加，以下代码将执行此功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Command* cmd = <span class="keyword">new</span> Add;</span><br><span class="line">cmd-&gt;<span class="built_in">execute</span>();</span><br></pre></td></tr></table></figure><p>太好了！问题解决了，对吧？并非如此。这段代码是如何被调用的？这段代码出现在哪里？如果添加了新的核心命令（即需求发生变化）会怎么样？如果动态地添加新命令（如插件）会怎么样？看似容易解决的问题实际上比最初预期的要复杂得多。让我们通过回答上述问题来探讨可能的设计替代方案。</p><p>首先，我们提出如何调用代码的问题。计算器的需求之一是要有命令行界面（CLI）和图形用户界面（GUI）。显然，初始化命令的请求将在用户界面中响应用户操作时派生。让我们考虑一下用户界面如何处理减法。假设 GUI 有一个减法按钮，当这个按钮被点击时，将调用一个函数来初始化并执行减法命令（我们暂时忽略撤销功能）。现在考虑 CLI。当识别到减法符号时，会调用类似的函数。起初，人们可能会期望我们可以调用相同的函数，前提是它存在于业务逻辑层而不是用户界面层。然而，GUI 回调的机制使得这种做法变得不可能，因为它会强制在业务逻辑层中引入一个不需要的依赖关系，即依赖于 GUI 的小部件库（例如，在 Qt 中，按钮回调是一个类中的槽，需要回调的类是一个 Q_OBJECT）。另一种选择是，GUI 可以部署双重间接分派每个命令（每次按钮点击都会调用一个函数，这个函数会调用业务逻辑层中的一个函数）。这种情况既不优雅也不高效。</p><p>尽管上述策略看起来相当繁琐，但这种初始化方案的结构赤字比不方便要深得多。在我们为 pdCalc 采用的模型-视图-控制器架构中，视图不允许直接访问控制器。由于命令正确地属于控制器，所以 UI 对命令的直接初始化违反了我们的基本架构。</p><p>我们如何解决这个新问题？回想一下表 2-2 中的命令调度器的唯一公共接口是事件处理函数 commandEntered(const string&amp;)。实际上，这个认识回答了我们最初提出的前两个问题：初始化和执行代码是如何被调用的，以及它们位于哪里？这段代码必须通过来自 UI 到命令调度器的事件间接触发，并通过字符串对特定命令进行编码。代码本身必须驻留在命令调度器中。请注意，这个接口还具有在 CLI 和 GUI 之间创建新命令时消除重复的额外优点。现在，两个用户界面都可以简单地通过触发 commandEntered 事件并通过字符串指定命令来创建命令。分别在第 5 章和第 6 章中，你将看到每个用户界面如何实现触发这个事件。</p><p>从上述分析中，我们有动力在命令调度器中添加一个新类，负责拥有和分配命令。我们将这个类称为 CommandRepository。目前，我们假设命令调度器的另一部分（CommandDispatcher 类）接收 commandEntered() 事件，并从 CommandRepository 中请求适当的命令（通过 commandEntered() 的字符串参数），而命令调度器的另一个组件（CommandManager 类）随后执行命令（并处理撤销和重做）。也就是说，我们已经将命令的初始化和存储与它们的调度和执行分离开来。CommandManager 和 CommandDispatcher 类是即将到来的章节的主题。现在，我们将关注命令存储、初始化和检索。</p><p>我们从 CommandManager 类的以下基本接口开始：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandRepository</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">unique_ptr&lt;Command&gt; <span class="title">allocateCommand</span><span class="params">(<span class="type">const</span> string&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的接口我们可以看到，给定一个字符串参数，存储库分配相应的命令。接口使用智能指针返回类型明确表示调用者拥有新构建命令的内存。</p><p>现在让我们考虑一下 allocateCommand() 的实现可能是什么样子的。这个练习将帮助我们修改设计以获得更大的灵活性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Command&gt; <span class="title">CommandRepository::allocateCommand</span><span class="params">(<span class="type">const</span> string&amp; c)</span></span></span><br><span class="line"><span class="function">    <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Add&gt;();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Subtract&gt;();</span><br><span class="line">    <span class="comment">// ... all known commands ...</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的接口简单有效，但它的局限性在于需要预先知道系统中的每个命令。通常情况下，这样的设计将会因为几个原因而变得非常不受欢迎和不方便。首先，向系统添加新的核心命令需要修改存储库的初始化函数。其次，部署运行时插件命令需要一个完全不同的实现。第三，这种策略在特定命令的实例化和存储之间创建了不需要的耦合。相反，我们更喜欢一种设计，其中 CommandRepository 仅依赖于 Command 基类定义的抽象接口。</p><p>上述问题通过应用一个简单的模式来解决，即原型模式 [6]。原型模式是一种创建型模式，其中存储一个原型对象，通过复制原型创建这种类型的新对象。现在，考虑一种将我们的 CommandRepository 视为仅仅是命令原型容器的设计。此外，让所有原型都通过 Command 指针存储，比如在哈希表中，使用字符串作为键（可能是在 commandEntered() 事件中引发的相同字符串）。然后，通过添加（或删除）新的原型命令，可以动态地添加（或删除）新命令。为了实现这种策略，我们对 CommandRepository 类进行如下添加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandRepository</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">unique_ptr&lt;Command&gt; <span class="title">allocateCommand</span><span class="params">(<span class="type">const</span> string&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerCommand</span><span class="params">(<span class="type">const</span> string&amp; name, unique_ptr&lt;Command&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> Repository = unordered_map&lt;string, unique_ptr&lt;Command&gt;&gt;;</span><br><span class="line">    Repository repository_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注册命令的实现非常简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CommandRepository::registerCommand</span><span class="params">(<span class="type">const</span> string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">    unique_ptr&lt;Command&gt; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (repository_.<span class="built_in">find</span>(name) != repository_.<span class="built_in">end</span>())</span><br><span class="line">        <span class="comment">// handle duplicate command error</span></span><br><span class="line">        <span class="keyword">else</span> repository_.<span class="built_in">emplace</span>(name, std::<span class="built_in">move</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们检查命令是否已经在存储库中。如果是，那么我们处理错误。如果不是，那么我们将命令参数移动到存储库中，命令成为命令名称的原型。注意，unique_ptr 的使用表明注册命令将原型的所有权转移到命令存储库。在实际使用中，核心命令都通过 CoreCommands.cpp 文件中的一个函数注册，每个插件内部也存在一个类似的函数来注册插件命令（我们将在第7章检查插件构建时看到这个接口）。这些函数分别在计算器初始化和插件初始化期间调用。可以选择使用一个注销命令来增强命令存储库，具有显而易见的实现。</p><p>使用我们的新设计，我们可以将 allocateCommand() 函数重写为以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Command&gt; CommandRepository ::<span class="built_in">allocateCommand</span>(<span class="type">const</span> string&amp; name)</span><br><span class="line">    <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = repository_.<span class="built_in">find</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (it != repository_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;Command&gt;(it-&gt;second-&gt;<span class="built_in">clone</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果在存储库中找到命令，则返回原型的副本。如果找不到命令，返回 nullptr（或者可以抛出异常）。原型的副本以 unique_ptr 形式返回，表示调用者现在拥有这个命令的副本。注意 Command 类中 clone() 函数的使用。clone 函数最初被添加到 Command 类中，以后会有合理的解释。如今显而易见，我们需要 clone() 函数以便为原型模式的实现多态地复制 Commands。当然，如果我们在设计 Command 类时没有预见到为所有命令实现克隆函数，现在可以很容易地添加。请记住，你不会在第一次尝试就完美地完成设计，所以习惯迭代设计的想法。</p><p>基本上，registerCommand() 和 allocateCommand() 实现了 CommandRepository 类的最小完整接口。然而，如果你查看这个类的包含的源代码，你会发现一些差异。首先，接口中添加了额外的函数。额外的函数主要是便利和语法糖。其次，整个接口都隐藏在一个 pimpl 后面。第三，我使用别名 CommandPtr，而不是直接使用 unique_ptr<Command>。对于本章的目的，只需将 CommandPtr 视为由以下 using 语句定义：</Command></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> CommandPtr = std::unique_ptr&lt;Command&gt;;</span><br></pre></td></tr></table></figure><p>实际上的别名，可以在 Command.h 中找到，稍微复杂一些。它将在第7章详细解释。相应地，我使用函数 MakeCommandPtr() 而不是 make_unique<Command>() 来创建 CommandPtrs。</Command></p><p>最后，从存储库代码中尚未讨论的接口部分，唯一影响设计的是使 CommandRepository 成为单例的选择。这个决定的原因很简单。无论系统中存在多少不同的命令调度器（有趣的是，我们最终会看到一个拥有多个命令调度器的案例），函数的原型永远不会改变。因此，使 CommandRepository 成为单例可以集中存储、分配和检索计算器的所有命令。</p><hr><p>现代 C++ 设计注意事项：统一初始化</p><p>你可能已经注意到我经常使用大括号进行初始化。对于长时间使用 C++ 编程的开发者来说，用大括号初始化类（即调用其构造函数）可能看起来有些奇怪。虽然我们习惯于使用列表语法初始化数组，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><p>但使用大括号初始化类是 C<ins>11 中的新特性。虽然仍然可以使用括号调用构造函数，但使用大括号的新语法，称为统一初始化，是现代 C</ins> 的首选语法。虽然这两种初始化机制在功能上执行相同的任务，但新语法有三个优势：</p><ol><li class="lvl-3"><p>统一初始化是非收窄的：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="built_in">A</span>(<span class="type">int</span> a); &#125;;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">7.8</span>)</span></span>; <span class="comment">// ok, truncates</span></span><br><span class="line">A a&#123;<span class="number">7.8</span>&#125;; <span class="comment">// error, narrows</span></span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>统一初始化（结合初始化器列表）允许用列表初始化用户定义的类型：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;<span class="type">double</span>&gt; v&#123; <span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span> &#125;; </span><br><span class="line"><span class="comment">// valid since C++11; initializes vector with 3 doubles</span></span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>统一初始化永远不会被误解析为函数：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123; <span class="built_in">B</span>(); <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">()</span></span>; <span class="comment">// Are you declaring a function that returns a B?</span></span><br><span class="line">b.<span class="built_in">foo</span>(); <span class="comment">// error, requesting foo() in non-class type b</span></span><br><span class="line">B b2&#123;&#125;; <span class="comment">// ok, default construction</span></span><br><span class="line">b2.<span class="built_in">foo</span>(); <span class="comment">// ok, call B::foo()</span></span><br></pre></td></tr></table></figure><p>在使用统一初始化时，只有一个很大的警告：列表构造函数总是在任何其他构造函数之前被调用。典型的例子来自于 STL vector 类，它具有一个初始化列表构造函数和一个单独的构造函数，接受一个整数来定义向量的大小。因为如果使用大括号，初始化列表构造函数在任何其他构造函数之前被调用，所以有以下不同的行为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// vector, size 3, all elements initialized to 0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">3</span>&#125;; <span class="comment">// vector with 1 element initialized to 3</span></span><br></pre></td></tr></table></figure><p>幸运的是，上述情况并不经常发生。然而，当它发生时，你必须了解统一初始化和函数风格初始化之间的区别。</p><p>从设计角度来看，统一初始化的主要优势是用户定义的类型可以设计为接受用于构造的相同类型值的列表。因此，诸如向量之类的容器可以使用值列表进行静态初始化，而不是默认初始化后接连续赋值。这个现代 C++ 功能使得派生类型的初始化可以使用与内置数组类型相同的初始化语法，这是 C++03 缺失的语法特性。</p><h3 id="4-3-2-注册核心命令">4.3.2 注册核心命令</h3><p>现在我们已经定义了计算器的核心命令和一个用于按需加载和提供命令的类。然而，我们还没有讨论将核心命令加载到 CommandRepository 的方法。为了正常工作，所有核心命令的加载只能执行一次，并且必须在使用计算器之前执行。本质上，这为命令调度器模块定义了一个初始化需求。由于退出程序时不需要注销核心命令，因此不需要最终化函数。</p><p>在计算器的 main() 函数中调用命令调度器的初始化操作是最好的地方。因此，我们只需创建一个全局的 RegisterCoreCommands() 函数，在 CoreCommands.h 头文件中声明它，在 CoreCommands.cpp 文件中实现它，并从 main() 中调用它。之所以创建一个全局函数而不是在 CommandRepository 的构造函数中注册核心命令，是为了避免将 CommandRepository 与命令层次结构的派生类耦合在一起。当然，注册函数可以叫做像 InitCommandDispatcher() 这样的名字，但我更喜欢一个更具体描述功能的名字。</p><p>隐式地，我们刚刚扩展了命令调度器的接口（最初在表 2-2 中定义），尽管相当琐碎。我们应该能提前预料到这部分接口吗？可能不会。这个接口更新是由第 2 章的高级分解中明显更详细的设计决策所必需的。我发现在开发过程中稍微修改一个关键接口是设计程序的可接受方式。要求不变性的设计策略实在太死板了，不切实际。然而，请注意，在开发过程中轻易接受关键接口修改与在发布后接受关键接口修改之间的区别，这种决定应该只在深入考虑了这种更改将如何影响已经使用你的代码的客户端之后才做出。</p><h2 id="4-4-命令管理器">4.4 命令管理器</h2><p>设计了命令基础结构并为系统中的命令存储、初始化和检索创建了一个仓库后，我们现在准备设计一个负责按需执行命令并管理撤消和重做的类。这个类叫做 CommandManager。从本质上讲，它通过在每个命令上调用 execute() 函数并以适当的方式保留每个命令来管理命令的生命周期，以实现无限撤消和重做。我们将从定义 CommandManager 的接口开始，并通过讨论实现无限撤消和重做的策略来结束本节。</p><h3 id="4-4-1-接口">4.4.1 接口</h3><p>CommandManager 的接口非常简单直接。CommandManager 需要一个接受要执行的命令、撤消命令和重做命令的接口。此外，可以选择包括一个用于查询可用撤消和重做操作数量的接口，这对于实现 GUI 可能很重要（例如，对于重做大小等于零，使重做按钮变灰）。一旦命令传递给 CommandManager，CommandManager 就拥有命令的生命周期。因此，CommandManager 的接口应该强制使用所有权语义。结合起来，我们有以下 CommandManager 的完整接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">getUndoSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">getRedoSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">executeCommand</span><span class="params">(unique_ptr&lt;Command&gt; c)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">redo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在实际列在 CommandManager.h 中的代码中，接口还额外定义了一个用于在构造过程中选择撤消/重做策略的枚举类。我仅出于说明目的包含了这个选项。生产代码只需实现一个撤消/重做策略，而不需要在构造时使底层数据结构可定制。</p><h3 id="4-4-2-实现撤消和重做">4.4.2 实现撤消和重做</h3><p>要实现无限撤消和重做，我们必须有一个可动态增长的数据结构，能够以执行顺序存储和重新访问命令。尽管可以设计许多不同的数据结构来满足这个要求，但我们将研究两个同样优秀的策略。这两种策略都已经为计算器实现，并可以在 CommandManager.cpp 文件中看到。</p><p>考虑图 4-3 中的数据结构，我将其称为列表策略。执行命令后，将其添加到列表中（实现可以是列表、向量或其他适当的有序容器），并更新指向最后一个执行的命令的指针（或索引）。每当调用撤销时，当前指向的命令被撤销，指针向左移动（指向较早命令的方向）。当调用重做时，命令指针向右移动（指向较晚命令的方向），并执行新指向的命令。当当前命令指针到达最左边（没有更多命令可以撤销）或最右边（没有更多命令可以重做）时，存在边界条件。这些边界条件可以通过禁用使用户调用命令的机制（例如，分别使撤消或重做按钮变灰）来处理，或者简单地忽略导致指针越过边界的撤消或重做命令。当然，每次执行新命令时，在将新命令添加到撤消/重做列表之前，必须清空当前命令指针右侧的整个列表。清空列表是为了防止撤消/重做列表变成具有多个重做分支的树。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/A454125_1_En_4_Fig3_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图 4-3 撤销/重做列表策略  </div></center><p>作为替代方案，请考虑图 4-4 中的数据结构，我将其称为堆栈策略。我们维护两个堆栈，一个用于撤销命令，一个用于重做命令，而不是按照执行顺序维护命令列表。执行新命令后，将其推入撤销堆栈。通过从撤销堆栈中弹出顶部条目，撤销命令，并将命令推入重做堆栈来撤销命令。通过从重做堆栈中弹出顶部条目，执行命令，并将命令推入撤销堆栈来重做命令。存在边界条件，可以通过堆栈大小轻松识别。执行新命令需要清空重做堆栈。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/4.The-Command-Dispatcher/A454125_1_En_4_Fig4_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        Figure 4-4 The Undo/Redo Stack Strategy        图 4-4 撤销/重做堆栈策略  </div></center><p>实际上，在通过堆栈或列表策略实现撤销和重做之间进行选择主要是个人喜好。列表策略只需要一个数据容器和较少的数据移动。然而，堆栈策略实现起来稍微容易一些，因为它不需要索引或指针移位。也就是说，两种策略都相当容易实现，且需要很少的代码。一旦你实现并测试了这两种策略中的任何一种，只要通过命令模式实现命令，未来需要撤销和重做功能的项目都可以轻松重用 CommandManager。为了更具通用性，CommandManager 可以在抽象的 Command 类上进行模板化。为了简单起见，我选择为之前讨论过的抽象 Command 类特别实现包含的 CommandManager。</p><h2 id="4-5-命令分发器">4.5 命令分发器</h2><p>命令分发器模块的最后一个组件是 CommandDispatcher 类本身。尽管这个类更恰当地被称为 CommandInterpreter，但我保留了 CommandDispatcher 这个名字，以强调这个类充当命令分发器模块与计算器其他部分之间的接口。也就是说，就其他模块而言，CommandDispatcher 类是命令分发器模块的全部。</p><p>如前所述，CommandDispatcher 类扮演了两个主要角色。第一个角色是作为命令分发器模块的接口。第二个角色是解释每个命令，从 CommandRepository 请求适当的命令，并将每个命令传递给 CommandManager 执行。我们依次解决这两个角色。</p><h3 id="4-5-1-接口">4.5.1 接口</h3><p>尽管命令分发器模块的实现相当复杂，但 CommandDispatcher 类的接口却非常简单（就像大多数优秀的接口一样）。如第 2 章所讨论的，命令分发器的接口完全由一个用于执行命令的单一功能组成；命令本身由一个字符串参数指定。这个功能自然是之前讨论过的 executeCommand() 事件处理程序。因此，CommandDispatcher 类的接口由以下内容给出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommandDispatcher</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CommandDispatcher</span>(UserInterface&amp; ui);</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">executeCommand</span><span class="params">(<span class="type">const</span> string&amp; command)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unique_ptr&lt;CommandDispatcherImpl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回想一下，计算器的基本架构是基于模型-视图-控制器模式，而 CommandDispatcher 可以直接访问模型（栈）和视图（用户界面）。因此，CommandDispatcher 的构造函数接受一个抽象 UserInterface 类的引用，详细信息将在第 5 章中讨论。由于栈是作为单例实现的，因此不需要直接引用栈。按照我通常的惯例，CommandDispatcher 的实际实现被推迟到一个私有实现类 CommandDispatcherImpl。</p><p>上面的一种替代设计是使 CommandDispatcher 类直接成为一个观察者。如第 3 章所讨论的，我更喜欢使用中介事件观察者的设计。在第 5 章中，我将讨论 CommandIssuedObserver 代理类的设计和实现，以在用户界面和 CommandDispatcher 类之间进行事件代理。</p><p>4.5.2 实现细节</p><p>通常在这本书中，我不讨论 pimpl 类中包含的实现细节。但在这种情况下，CommandDispatcherImpl 类的实现尤其有启发性。CommandDispatcherImpl 类的主要功能是实现 executeCommand() 函数。此函数必须接收命令请求、解释这些请求、检索命令、请求执行命令以及优雅地处理未知命令。如果我们从自上而下地开始分解命令分发器模块，试图清晰地实现此功能将非常困难。然而，由于我们自下而上的方法，executeCommand() 的实现在很大程度上是将现有组件粘合在一起的练习。请考虑以下实现，其中 manager_ 对象是 CommandManager 类的一个实例，如 Listing 4-7 所示。</p><p>清单 4-7 executeCommand() 的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CommandDispatcher::CommandDispatcherImpl::<span class="built_in">executeCommand</span>(<span class="type">const</span> string&amp; command)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNum</span>(command, d))</span><br><span class="line">        manager_.<span class="built_in">executeCommand</span>(<span class="built_in">MakeCommandPtr</span>&lt;EnterNumber&gt;(d));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;undo&quot;</span>)</span><br><span class="line">        manager_.<span class="built_in">undo</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;redo&quot;</span>)</span><br><span class="line">        manager_.<span class="built_in">redo</span>();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> c = CommandRepository::<span class="built_in">Instance</span>().<span class="built_in">allocateCommand</span>(command);</span><br><span class="line">        <span class="keyword">if</span> (!c) &#123;</span><br><span class="line">            ostringstream oss;</span><br><span class="line">            oss &lt;&lt; <span class="string">&quot;Command &quot;</span> &lt;&lt; command &lt;&lt; <span class="string">&quot; is not a known command&quot;</span>;</span><br><span class="line">            ui_.<span class="built_in">postMessage</span>(oss.<span class="built_in">str</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                manager_.<span class="built_in">executeCommand</span>(std::<span class="built_in">move</span>(c));</span><br><span class="line">            &#125; <span class="built_in">catch</span> (Exception&amp; e) &#123;</span><br><span class="line">                ui_.<span class="built_in">postMessage</span>(e.<span class="built_in">what</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5-10 行处理特殊命令。特殊命令是指在命令存储库中未输入的任何命令。在上面的代码中，这包括输入新数字、撤消和重做。如果没有遇到特殊命令，则假定命令可以在命令存储库中找到。这个请求在第 13 行中进行。如果命令存储库返回 nullptr，则在 16-18 行处理错误。否则，命令由命令管理器执行。请注意，命令的执行在 try/catch 块中进行。通过这种方式，我们可以捕获由命令前置条件失败引起的错误，并在用户界面中报告这些错误。CommandManager 的实现确保未通过前置条件的命令不会进入撤销栈（按执行顺序进行）。</p><p>实际在 CommandDispatcher.cpp 中找到的 executeCommand() 的实现与上面的代码略有不同。首先，实际实现包括两个额外的特殊命令。这些额外特殊命令中的第一个是 help。help 命令可用于为当前在命令存储库中的所有命令打印简短的解释性消息。虽然实现通常将帮助信息打印到用户界面，但我只在 CLI 中公开了帮助命令（即，我的 GUI 的实现没有帮助按钮）。第二个特殊命令处理存储过程。存储过程在第 8 章中解释。此外，我将 try/catch 块放在其自己的函数中。这样做只是为了缩短 executeCommand() 函数并将命令解释的逻辑与命令执行分开。</p><h2 id="4-6-重新审视早期决策">4.6 重新审视早期决策</h2><p>此时，我们已经完成了计算器的两个主要模块：栈和命令调度器。让我们回顾一下我们最初的设计，讨论一个已经出现的重要细微偏差。</p><p>回顾第 2 章，我们最初的设计是通过在栈和命令调度器中引发事件来处理错误，这些事件将由用户界面处理。之所以做出这个决定，是为了保持一致性。虽然命令调度器具有对用户界面的引用，但栈没有。因此，我们决定让两个模块通过事件通知用户界面错误。然而，敏锐的读者会注意到，上面设计的命令调度器从未引发异常。相反，当错误发生时，它直接调用用户界面。那么我们是不是打破了有意设计到系统中的一致性呢？答案是否定的。实际上，在命令调度器的设计过程中，我们隐含地重新设计了系统的错误处理机制，使得栈和命令调度器都不再引发错误事件。让我们来看看原因。</p><p>正如我刚才所说，从实现来看，命令调度器显然没有引发错误事件，但栈事件发生了什么变化呢？我们没有更改 Stack 类的源代码，那么错误事件是如何被消除的呢？在最初的设计中，栈在发生错误时通过引发事件间接通知用户界面。两种可能的栈错误条件是弹出空栈和交换大小不足的栈的前两个元素。在设计命令时，我意识到，如果命令触发了这两种错误条件之一，用户界面会得到通知，但命令调度器不会（它不是栈事件的观察者）。在任何一种错误场景下，命令虽然执行失败，但都会被错误地放置在撤销栈上。然后我意识到，要么命令调度器必须捕获栈错误并阻止错误地放置到撤销栈上，要么命令不应被允许产生栈错误。正如最终设计所展示的，我选择了更简单、更干净的实现方式，即在执行命令之前使用前置条件来防止栈错误发生，从而隐式地抑制栈错误。</p><p>一个大问题是，为什么我没有修改描述原始设计的文本和相应的代码以反映错误报告的变化呢？简单地说，我希望读者看到错误确实会发生。设计是一个迭代过程，一个试图通过示例教授设计的书应该拥抱这个事实，而不是隐藏它。设计应该是有些流动性的（但也许具有较高的粘度）。在发现原始设计存在缺陷的证据后，尽早改变糟糕的设计决策要比坚持它更好。一个糟糕的设计被改变得越晚，修复它的成本就越高，而开发人员在尝试实现错误时会遇到更多的痛苦。至于改变代码本身，当我执行重构时，除非 Stack 类被设计为在另一个通过事件处理错误的程序中重用，否则我会从 Stack 类中移除多余的代码。毕竟，作为一个通用设计，通过引发事件来报告错误的机制并没有缺陷。事后来看，这种机制对于 pdCalc 来说并不合适。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Practical C++ Design From Programming to Architecture 1ed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. 定义案例研究</title>
      <link href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/1.Defining-the-Case-Study/"/>
      <url>/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/1.Defining-the-Case-Study/</url>
      
        <content type="html"><![CDATA[<h1>1. 定义案例研究</h1><h2 id="1-1-简要介绍">1.1 简要介绍</h2><p>本书是关于编程设计的。然而，与许多关于这个主题的书不同，本书通过探索而不是指令教授设计。通常，大多数关于设计方面的作者都会确立他们想要传达的原则，在抽象的地方阐述这些原则，然后继续提供支持当前观点的示例。本书不是这样的。相反，本书定义了一个要解决的实际问题，然后详细给出其解决方案。也就是说，与决定一个主题并创建支持其教学的琐碎示例相反，我已经定义了一个困难的问题，然后通过这个问题的解决方案决定应该讨论哪些主题。</p><p>有趣的是，上述方法正是我告诉别人不要学习一个科目的方法。我总是强调人们应该首先学习广泛的基础知识，然后将这些知识应用于解决问题。也就是，这并不是一本旨在教授设计原理的书。相反，这本书是为那些已经知道基本原理但希望加深实践知识的人准备的。这本书的目的是教授人们如何运用基础从头到尾设计和实现一个现实的，尽管较小的程序。这个过程不仅仅涉及到对设计模式的了解。它涉及到理解何时以及如何使用你所知道的东西，理解如何在看似相等的方法之间做出决定，以及理解各种决定的长期影响。本书在数据结构、算法、设计模式或C++最佳实践方面的覆盖面并不全面，不过已有大量的书籍涉及这些主题。这本书是关于学习如何将这些知识应用于编写有组织、紧密、明智、有目的和实用的代码的。换句话说，这本书是关于学习如何写出既能完成现在的工作（开发）又能让别人在未来继续完成工作（维护）的代码。这一点，我称之为实用设计。</p><p>为了探索实用设计，我们需要一个案例研究。理想情况下，案例研究问题应该具备以下特点：</p><ul class="lvl-0"><li class="lvl-2"><p>足够大，不仅仅是微不足道的；</p></li><li class="lvl-2"><p>足够小，易于处理；</p></li><li class="lvl-2"><p>足够熟悉，不需要特定领域的专业知识；</p></li><li class="lvl-2"><p>足够有趣，以保持读者在整本书的过程中的兴趣。</p></li></ul><p>考虑到上述标准，我决定选择基于栈的逆波兰式（RPN）计算器作为案例研究。下面将定义计算器的需求详情。我相信完整计算器的代码足够重要，以提供充分的设计研究材料以涵盖一本书。然而，该项目足够小，以使这本书成为一个合理的长度。当然，不需要专门的领域专业知识。我猜想，这本书的每一位读者都使用过计算器，并对其基本功能非常熟悉。最后，我希望使计算器RPN能够提供一个合适的变化，以避免无聊。</p><h2 id="1-2-关于需求的几点说明">1.2 关于需求的几点说明</h2><p>不管程序有多大或有多小，所有程序都有需求。需求是程序必须遵守的特性，无论是明确的还是隐含的。关于收集和管理软件需求的整本书已经被写下了（请参阅[28]或[21]）。通常情况下，尽管一个人尽了最大努力，但实际上不可能一次性收集所有的需求。有时，所需的努力在经济上是不可行的。有时，领域专家会忽略对他们来说似乎是显而易见的需求，他们根本没有向开发团队说明他们的所有需求。有时，需求只有在程序开始形成后才能明显。有时，客户不了解他的需求，因此不能向开发团队说明。虽然使用敏捷开发方法可以减轻一些困境，但事实仍然是，许多设计决策，其中一些可能有深远影响，必须在所有需求已知之前发生。</p><p>本书不会研究如何收集需求，而是先给出了大部分需求。有些需求将在以后的章节中确定，这样您就可以研究设计如何改变以适应未知的未来扩展。当然，人们可以理直气壮的说，既然作者知道需求会如何变化，那么最初的设计就会正确的 &quot;预测 &quot;那些不可预见的功能。尽管这种批评是公正的，但我仍然认为设计决策背后的思维和讨论仍然是相关的。作为软件架构师，您的工作之一将是预测未来的需求。虽然任何需求都是可能的，但在一开始就过多地w为灵活性考虑并不经济。设计未来扩展总是要考虑成本差异，即在一开始明确适应扩展性的成本与如果需求更改时修改代码的成本之间的平衡。一个设计在简单性和灵活性之间的落脚点，最终必须根据功能需求实现的可能性和增加新功能的可行性来衡量，如果一开始就不考虑它的话。</p><h2 id="1-3-逆波兰表示法">1.3 逆波兰表示法</h2><p>我假定有人读这本书时都熟悉计算器的操作。然而，除非你在使用惠普计算器长大，否则你可能不熟悉基于堆栈的逆波兰表示法（RPN）计算器的工作方式（如果不熟悉堆栈的工作方式，请参阅[5]）。简单地说，输入的数字被压入堆栈，并在堆栈上的数字上执行操作。二进制运算符，例如加法，从堆栈顶部弹出前两个数字，将这两个数字相加，然后将结果压入堆栈。单目运算符，例如正弦函数，从堆栈顶部弹出一个数字，使用该数字作为操作数，并将结果压入堆栈。对于那些熟悉基本编译语言的人来说，RPN充当操作的后缀表示法（有关后缀表示法的详细讨论，请参阅[1]）。以下列表描述了我对逆波兰表示法优于常规语法的仅仅几点观点：</p><ul class="lvl-0"><li class="lvl-2"><p>所有操作都可以不使用圆括号表示。</p></li><li class="lvl-2"><p>多个输入和输出可以同时可视化。</p></li><li class="lvl-2"><p>复杂的计算可以轻松地分解为多个简单的操作。</p></li><li class="lvl-2"><p>中间结果可以轻松保留和重复使用。</p></li></ul><p>虽然一开始使用逆波兰表达式（RPN）可能感觉极其奇怪，但是一旦适应了，当你需要完成复杂运算时，你会诅咒没有使用它的每一个计算器。</p><p>为了确保 RPN 计算器的操作是明确的，让我们来看一个简短的例子。假设我们想计算以下表达式：$\frac{\left(4+7\right)\ast 3+2}{7}$</p><p>在一般的非 RPN 计算器上，我们会输入((4 + 7) * 3 + 2)/7并点击 = 键。在 RPN 计算器上，我们则输入 4 7 + 3 * 2 + 7 /，其中在每个数字后面都有一个回车命令，以便将输入压入堆栈。请注意，对于许多计算器，为了减少键盘输入操作，如 +，也可以隐式地进入堆栈中的前一个数字。图 1-1 显示了在 RPN 计算器上上述计算的步骤。</p><center>    <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/1.Defining-the-Case-Study/A454125_1_En_1_Fig1_HTML.gif" alt>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图1-1 RPN计算器上执行的示例计算，显示了中间步骤。出乎意料的是，栈的顶部位于屏幕底部。  </div></center><p>图1-1展示了在RPN计算器上的计算过程的一个例子，其中包括了计算的中间步骤。这个计算是在堆栈上进行的，输入的数字被压入堆栈，然后在堆栈上已有的数字上执行操作。堆栈顶部位于屏幕底部，对某些人来说可能是不太直观的。该图展示了如何使用二进制和一元运算符从堆栈弹出数字，如何对它们执行操作，并将结果压入堆栈的步骤。</p><h2 id="1-4-计算器的需求">1.4 计算器的需求</h2><p>理解逆波兰表示法的本质后，您应该能够很容易地根据需求说明理解计算器的其余功能。 如果您对逆波兰表示法仍然不清楚，建议您先澄清这个概念再继续。因此，定义计算器的要求如下：</p><ul class="lvl-0"><li class="lvl-2"><p>计算器将基于堆栈运作，堆栈大小不应该是硬编码的。</p></li><li class="lvl-2"><p>计算器将使用逆波兰表达式（RPN）执行运算。</p></li><li class="lvl-2"><p>计算器将专门运算浮点数；应实现一种输入数字（包括科学记数法）的技术。</p></li><li class="lvl-2"><p>计算器将具有撤消和重做操作的能力；撤消/重做堆栈大小应是无限的。</p></li><li class="lvl-2"><p>计算器将具有交换堆栈顶部两个元素的能力。</p></li><li class="lvl-2"><p>计算器将能够从堆栈顶部删除（删除）一个元素。</p></li><li class="lvl-2"><p>计算器将能够清除整个堆栈。</p></li><li class="lvl-2"><p>计算器将能够复制堆栈顶部的元素。</p></li><li class="lvl-2"><p>计算器将能够取消堆栈顶部的元素。</p></li><li class="lvl-2"><p>计算器将实现四种基本算术运算：加法、减法、乘法和除法。除以0是不允许的。</p></li><li class="lvl-2"><p>计算器将实现三种基本三角函数和它们的逆函数：sin、cos、tan、arcsin、arccos和arctan。三角函数的参数将以弧度为单位给出。</p></li><li class="lvl-2"><p>计算器将实现 $ y^x $ 和 $ \sqrt[x]{y} $ 的函数。</p></li><li class="lvl-2"><p>计算器将实现运行时插件结构，以扩展计算器可以执行的操作。</p></li><li class="lvl-2"><p>计算器将实现命令行界面（CLI）和图形用户界面（GUI）。</p></li><li class="lvl-2"><p>计算器不支持无穷大或虚数。</p></li><li class="lvl-2"><p>计算器将是容错的（即，如果用户给出错误的输入不会崩溃），但不需要处理浮点数异常。</p></li></ul><p>现在，计算器已经有了需求，它应该有一个名字。我选择将计算器命名为 pdCalc，意为实用设计计算器。对于我的命名缺乏创意，请接受我的歉意。</p><p>本书的其余部分将详细检查满足上述要求的计算器的完整设计。除了描述最终设计的决策外，我还将讨论其他选择，以便您理解为什么做出最终决策，以及不同决策的可能后果。请注意，本书中呈现的最终设计不是唯一能满足要求的设计，甚至可能不是满足要求的最佳设计。我鼓励有抱负的读者尝试其他设计并将计算器扩展以满足自己的需求和兴趣。</p><h2 id="1-5-源代码">1.5 源代码</h2><p>在本书中，我们将检查大量代码片段，以设计我们的计算器。大多数代码片段是直接从pdCalc的GitHub源代码库中获取的（有关下载源代码的说明，请参见附录A）。我将指出文本代码与代码库中的代码之间的任何显著差异。偶尔，代码片段由小的、人为构造的示例组成。这些代码片段不是pdCalc源代码库的一部分。所有代码均根据GPL版本3授权[7]。我强烈建议您对源代码进行实验并按自己的方式进行修改。</p><p>为了构建pdCalc，您需要访问C++14兼容的编译器和Qt（版本4或5）。由于该项目具有内在的Qt依赖（并且因为我喜欢Qt Creator IDE），我使用Qt项目文件作为构建系统，并使用Qt Test作为单元测试框架。我已经使用gcc / mingw在Linux和Windows上构建和测试了该程序，但代码也应该可以在其他系统上构建和执行，或在其他编译器上执行，源代码修改很少或根本不修改。在移植到不同平台时，需要对qmake项目文件进行微调。因为我预期该书的读者偏向于具有多年经验的开发人员，因此我认为从源代码构建代码将是一项相当简单的任务。然而，为了完整性，我已经在附录A中包含了构建指导。此外，我还在附录B中说明了pdCalc源代码、库和可执行文件的组织。尽管这两个附录出现在本书的末尾，但如果您打算构建pdCalc并在阅读文本时探索其全部实现，您可能希望首先阅读它们。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Practical C++ Design From Programming to Architecture 1ed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. 堆栈</title>
      <link href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/"/>
      <url>/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/</url>
      
        <content type="html"><![CDATA[<h1>3. 堆栈</h1><p>栈是我们将设计和实现的计算器的第一个模块。尽管我在第 2 章中定义了模块的公共接口，但关于其实现我说得很少。在 C++ 中，模块不是定义的语言概念。因此，我们实际上要将栈分解为一组逻辑分组的函数和类，并将其称为我们的模块。因此，这就是我们开始的地方。如果你对栈数据结构的机制有点生疏，现在是时候参考你最喜欢的数据结构和算法书了。我个人最喜欢的是Cormen等人的书[5]。</p><h2 id="3-1-栈模块的分解">3.1 栈模块的分解</h2><p>在分解栈模块时要问的第一个问题是：“栈应该被划分成多少部分？”用面向对象的说法，我们问：“我们需要多少对象，它们是什么？”在这种情况下，答案相当明显：一个，栈本身。本质上，整个栈模块是单个数据结构的体现，可以很容易地由单个类封装。这个类的公共接口已经在第 2 章中描述过。</p><p>第二个问题可能是：“我是否需要构建一个类，还是只需要直接使用标准模板库(STL)中的栈类？”这实际上是一个非常好的问题。所有的设计书籍都宣扬，当你可以使用库中的数据结构时，永远不要编写自己的数据结构，尤其是当数据结构可以在 STL 中找到时，因为 STL 保证是 C++ 标准分发的一部分。确实，这是明智的建议，我们不应该重写栈数据结构的机制。然而，我们也不应该直接使用 STL 栈作为我们系统中的栈。相反，我们将编写我们自己的栈类，将一个 STL 容器作为私有成员封装。</p><p>如果我们选择使用 STL 栈来实现我们的栈模块，有几个原因可以解释为什么封装一个 STL 容器（或任何供应商的数据结构）比直接使用更好。首先，通过包装 STL 栈，我们为计算器的其他部分设置了一个接口保护。也就是说，我们通过将栈的接口与其实现分离（记得封装吗？）来保护其他计算器模块免受潜在的栈实现更改的影响。当使用供应商软件时，这种预防措施尤为重要，因为这种设计决策使更改局限于包装器的实现，而不是栈模块的接口。如果供应商修改其产品的接口（供应商就是这么狡猾）或者你决定将一个供应商的产品换成另一个供应商的产品，这些更改只会在局部影响你的栈模块的实现，而不会影响栈模块的调用者。即使底层实现是标准化的，如 ISO 标准化的 STL 栈，接口保护也使您可以更改底层实现而不影响依赖模块。例如，如果您改变主意，后来决定用向量而不是栈重新实现栈模块怎么办。</p><p>将 STL 容器封装而不是直接使用的第二个原因是，这样可以让我们限制接口以精确符合我们的需求。在第 2 章中，我们花费了大量的精力设计一个有限的、最小的栈模块接口，能够满足所有 pdCalc 的用例。通常情况下，底层实现可能提供的功能比你实际希望暴露的要多。如果我们选择直接将 STL 栈作为我们的栈模块，这个问题不会很严重，因为 STL 栈的接口，不出所料，与我们为计算器的栈定义的接口非常相似。然而，假设我们选择了 Acme 公司的 RichStack 类，它有 67 个公共成员函数，作为我们的栈模块不加包装地使用。一个没有仔细阅读设计规范的初级开发人员可能在应用程序的上下文中无意中调用了一个不应该公开的 RichStack 函数，从而违反了我们的栈模块的一些隐含的设计约定。尽管这种滥用可能与模块的文档接口不一致，但不应该依赖其他开发人员实际阅读或遵守文档（令人遗憾，但事实就是如此）。</p><p>将 STL 容器封装的第三个原因是扩展或修改底层数据结构的功能。例如，对于 pdCalc，我们需要添加两个在 STL 栈类中不存在的函数（getElements() 和 swapTop()），并将错误处理从标准异常转换为我们自定义的错误事件。因此，包装器类使我们能够修改 STL 的标准容器接口，使其符合我们自己的内部设计的接口，而不是受到 STL 提供给我们的功能的限制。</p><p>正如人们所预料的那样，上述封装场景非常常见，因此已经被编码为一种设计模式，即适配器（包装器）模式[6]。正如 Gamma 等人所描述的，适配器模式用于将一个类的接口转换为客户端期望的另一个接口。通常情况下，适配器提供了某种形式的转换能力，从而也充当了不兼容类之间的代理。</p><p>在该模式的原始描述中，适配器被抽象出来，允许单个消息通过使用适配器类层次结构通过多态性包装多个不同的被适配者。对于 pdCalc 的栈模块的需求，一个简单的具体适配器类就足够了。</p><p>请记住，设计模式的存在是为了帮助设计和沟通。尽量不要陷入按照教材中规定的方式完全实现模式的陷阱。使用文献作为指南来帮助澄清您的设计，但最终，选择适合您的应用的最简单的解决方案，而不是最接近学术理想的解决方案。</p><p>最后一个问题是：“我的栈应该是泛型（即模板化）的吗？”这里的答案是一个响亮的也许。从理论上讲，设计一个抽象数据结构来封装任何数据类型是合理的做法。如果数据结构的最终目标是出现在库中或被多个项目共享，那么数据结构应该是通用的。然而，在单个项目的背景下，我不建议将数据结构设为泛型，至少一开始不要这样做。泛型代码更难编写，更难维护，更难测试。除非一开始就存在多种类型的使用场景，否则我发现编写泛型代码并不值得费心。我已经完成了太多的项目，在这些项目中，我花了额外的时间设计、实现和测试一个泛型数据结构，但只是用它来处理一种类型。实际上，如果您有一个非泛型数据结构，突然发现您确实需要将其用于不同的类型，那么所需的重构通常不会比从一开始就设计为泛型的类更难。此外，现有的测试将很容易适应泛型接口，通过单一类型建立正确性的基线。因此，我们将设计我们的栈为特定于 double 类型。</p><h2 id="3-2-Stack类">3.2 Stack类</h2><p>现在我们已经确定了我们的模块将由一个类组成，一个用于底层栈数据结构的适配器，让我们设计它。设计一个类时首先要问的问题之一是：“这个类将如何被使用？”例如，您是否正在设计一个抽象基类以被继承并因此被多态地使用？您是否主要将一个类设计为纯粹的旧数据（POD）存储库？在任何给定时间，这个类的许多不同实例是否存在？任何给定实例的生命周期是多少？谁通常拥有这个类的实例？实例是否共享？这个类是否并发使用？通过询问这些和其他类似的问题，我们发现以下关于我们的栈的功能需求列表：</p><ul class="lvl-0"><li class="lvl-2"><p>系统中应该只有一个栈存在。</p></li><li class="lvl-2"><p>栈的生命周期是应用程序的生命周期。</p></li><li class="lvl-2"><p>UI 和命令调度器都需要访问栈；两者都不应拥有栈。</p></li><li class="lvl-2"><p>栈访问不是并发的。</p></li></ul><p>任何时候满足上述前三个条件，该类都是单例模式 [6] 的绝佳候选者。</p><h3 id="3-2-1-单例模式">3.2.1 单例模式</h3><p>单例模式用于创建一个在系统中只应该存在一个实例的类。单例类不由其任何消费者拥有，但类的单个实例也不是全局变量（然而，有些人认为单例模式实际上是伪装的全局数据）。为了不依赖荣誉制度，我们使用语言机制来确保只能存在一个实例。</p><p>此外，在单例模式中，实例的生命周期通常从第一次实例化到程序终止。根据实现情况，单例可以被创建为线程安全的，也可以仅适用于单线程应用程序。关于不同 C++ 单例实现的优秀讨论可以在 Alexandrescu [2] 中找到。对于我们的计算器，我们将使用满足我们目标的最简单的实现。</p><p>为了得出一个简单的单例实现，我们参考 C++ 语言的知识。首先，如前所述，没有其他类拥有单例实例，也不是单例的实例是全局对象。这意味着单例类需要拥有它的单一实例，所有权访问应该是私有的。为了防止其他类实例化我们的单例，我们还需要使其构造函数和赋值运算符私有或删除。其次，知道系统中只有一个单例实例存在，立即意味着我们的类应该静态地持有它的实例。最后，其他类将需要访问这个单一实例，我们可以通过一个公共静态函数提供。将上述要点结合起来，我们构建了如清单 3-1 所示的单例类的框架。</p><p>清单 3-1 单例类的框架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> Singleton&amp; Instance</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123; <span class="comment">/* does foo things */</span> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// prevent public instantiation, copying, assignment, movement,</span></span><br><span class="line">  <span class="comment">// &amp; destruction</span></span><br><span class="line">  <span class="built_in">Singleton</span>() &#123; <span class="comment">/* constructor */</span> &#125;</span><br><span class="line">  <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">Singleton</span>(Singleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Singleton&amp;&amp; <span class="keyword">operator</span>=(Singleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  ~<span class="built_in">Singleton</span>() &#123; <span class="comment">/* destructor */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Singleton 类的静态实例以函数作用域而不是类作用域来保存，以防止在一个单例类的构造函数依赖于另一个单例时出现不可控的实例化顺序冲突。C++ 的实例化顺序规则的细节超出了本书的范围，但在 Alexandrescu [2] 中可以找到关于单例的详细讨论。</p><p>请注意，由于缺少对一个实例访问的锁定，我们的模型单例目前仅适用于单线程环境。在多核处理器的时代，这种限制明智吗？对于 pdCalc，绝对是！我们的简单计算器不需要多线程。编程是困难的。多线程编程要困难得多。除非绝对必要，永远不要把一个简单的设计问题变成一个更难的问题。</p><p>现在我们有了 Singleton 类的框架，让我们看看如何使用它。为了访问实例并调用 foo() 函数，我们只需使用以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton::<span class="built_in">Instance</span>().<span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure><p>在第一次调用 Instance() 函数时，实例变量被静态实例化，并返回对该对象的引用。由于在函数作用域静态分配的对象在内存中保持到程序终止，因此在 Instance() 函数作用域结束时，实例对象不会被析构。在后续对 Instance() 的调用中，跳过实例变量的实例化（它已经从之前的函数调用中构造并存储在内存中），并简单地返回对实例变量的引用。请注意，虽然底层单例实例是静态持有的，但 foo() 函数本身不是静态的。</p><p>好奇的读者现在可能会问：“为什么要费心持有一个类的实例？为什么不干脆把 Singleton 类的所有数据和所有函数都设为静态？”原因是因为单例模式允许我们在需要实例语义的地方使用 Singleton 类。这些语义的一个特别重要的用途是在回调的实现中。例如，考虑 Qt 的信号和插槽机制（在第 6 章中你会遇到信号和插槽），它可以被大致理解为一个强大的回调系统。为了将一个类中的信号连接到另一个类中的插槽，我们必须为这两个类实例提供指针。如果我们在没有私有实例化 Singleton 类的情况下实现了我们的单例（即，仅使用静态数据和静态函数），那么在 Qt 的信号和插槽中使用我们的 Singleton 类将是不可能的。</p><h3 id="3-2-2-堆栈模块作为单例类">3.2.2 堆栈模块作为单例类</h3><p>我们现在拥有了堆栈模块的基本设计。我们已经决定整个模块将被封装在一个类中，这个类实际上充当一个STL容器的适配器。我们已经决定，我们的这个类符合单例模式的模型标准，这个单例类将拥有第2章设计的公共接口。将这些设计元素结合起来，我们得到了类的初始声明，如Listing 3-2所示。</p><p>Listing 3-2 堆栈作为单例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">StackImpl</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Stack&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getElements</span><span class="params">(<span class="type">int</span>, vector&lt;<span class="type">double</span>&gt;&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swapTop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Stack</span>();</span><br><span class="line">  ~<span class="built_in">Stack</span>();</span><br><span class="line">  <span class="comment">// appropriate blocking of copying, assigning, moving...</span></span><br><span class="line">  unique_ptr&lt;StackImpl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于本书的重点是设计，除非细节特别有启发性或者突显设计的关键元素，否则文本中不会提供每个成员函数的实现。请记住，pdCalc的完整实现可以从GitHub仓库下载。有时，仓库源代码将是文本中理想化接口的一个更复杂的变体。这将是本书剩余部分的通用格式。</p><p>对于那些不熟悉pimpl惯用法（将一个类的实现放在一个单独的私有实现类中）的读者，pimpl成员变量可能看起来很神秘。不用担心。你将在下面的一个部分回顾这个原则。</p><p>在暂时离开Stack类设计的讨论之前，让我们稍作分析，并讨论一个相关的实现细节。我们花了很多时间回顾在Stack设计中使用适配器模式来隐藏底层数据结构的重要性。这个决定的一个理由是，它提供了在不影响依赖于Stack接口的类的情况下，无缝地改变底层实现的能力。问题是：“为什么Stack的底层实现可能会改变？”</p><p>在实现 Stack 的第一个版本中，我选择了一个显而易见的底层数据结构，即 STL 栈。然而，我很快就遇到了使用 STL 栈的效率问题。我们的 Stack 类接口提供了一个 getElements() 函数，使用户界面能够查看计算器堆栈的内容。不幸的是，STL 栈的接口没有提供类似的功能。查看除顶部元素以外的 STL 栈中的元素的唯一方法是连续弹出栈，直到到达感兴趣的元素。显然，因为我们只是尝试查看堆栈的元素，而不是修改堆栈本身，我们需要立即将所有条目重新压回堆栈。有趣的是，对于我们的目的，STL 栈居然是实现堆栈的不适当的数据结构！一定有更好的解决方案。</p><p>幸运的是，STL 为我们的任务提供了另一种适合的数据结构，即双端队列或 deque。deque 是一个类似于向量的 STL 数据结构，只是 deque 允许将元素推到其前端和后端。向量在保持连续性保证的同时进行优化以增长，而 deque 通过牺牲连续性来快速增长和收缩进行优化。这个特性正是高效实现堆栈所需的设计权衡。实际上，实现 STL 栈的最常见方法就是简单地包装一个 STL deque（是的，就像我们的 Stack，STL 的栈也是适配器模式的一个例子）。幸运的是，STL deque 还允许非破坏性迭代，这是我们需要实现 Stack 的 getElements() 方法时，从 STL 栈中缺少的额外要求。我使用封装来隐藏 Stack 的实现对其接口很有好处。在意识到查看 STL 栈的局限性后，我能够将 Stack 类的实现更改为使用 STL deque，而不对 pdCalc 的任何其他模块产生影响。</p><h4 id="3-2-2-1-Pimpl-习语">3.2.2.1 Pimpl 习语</h4><p>如果你选择查看 pdCalc 实现的 GitHub 存储库版本，你会注意到许多实际类实现都被 pimpl 习语（桥接模式的 C++ 专用化）隐藏起来。对于不熟悉这个术语的人，它是指针到实现的简写。在实践中，你不是在头文件中声明一个类的所有实现，而是前向声明一个指向“隐藏”的实现类的指针，并在实现文件中完全声明和定义这个“隐藏”的类。只要在包含其完整声明的源文件中对 pimpl 变量进行解引用，包含和使用不完整类型（pimpl 变量）是允许的。例如，考虑下面的类 A，其公共接口由函数 f() 和 g() 组成；私有实现包含函数 u()、v() 和 w()；私有数据 v_ 和 m_：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">u</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">v</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">w</span><span class="params">()</span></span>;</span><br><span class="line">  vector&lt;<span class="type">double</span>&gt; v_;</span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt; m_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 pimpl 习语，我们可以将 A 的私有接口从消费者类中隐藏起来，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">AImpl</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unique_ptr&lt;AImpl&gt; pimpl_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 u、v、w、v_ 和 m_ 现在都是类 AImpl 的一部分，这个类只在与类 A 关联的实现文件中声明和定义。为确保 AImpl 不能被其他类访问，我们将这个实现类声明为一个完全在 A 内部定义的私有类。Sutter 和 Alexandrescu [27] 对 pimpl 习语的优点做了简要的解释。主要优点之一是，通过将 A 类的私有接口从 A.h 移动到 A.cpp，我们在只更改 A 的私有接口时不再需要重新编译使用 A 类的代码。对于大型软件项目，编译过程中节省的时间可能很显著。</p><p>就我个人而言，我在编写的大部分代码中都使用 pimpl 习语。我普遍规则的例外是具有非常有限的私有接口或计算密集型代码（即 pimpl 的间接开销很大的代码）。除了在只更改 AImpl 类时不必重新编译包含 A.h 的文件的编译优势外，我发现 pimpl 习语为代码增加了很大的清晰度。这种清晰度来自于能够在实现文件中隐藏帮助函数和类，而不是将它们列在头文件中。通过这种方式，头文件真正只反映了接口的基本要素，</p><p>在继续完成 Stack 的接口之前，请注意，在这里使用 pimpl 惯用法完全隐藏了 Stack 类用户对底层堆栈数据结构的选择。这个选择是一个实现细节，应该对用户隐藏。pimpl 惯用法使我们能够完全隐藏它，甚至从视觉上也无法检查到。pimpl 惯用法确实是封装的典范。</p><h2 id="3-3-添加事件">3.3 添加事件</h2><p>为了构建符合第 2 章堆栈接口的堆栈，最后需要实现事件。事件是一种弱耦合形式，允许一个对象（通知器或发布者）向任意数量的其他对象（监听器或订阅者）发出信号，表示有趣的事情发生了。耦合是弱的，因为通知器和监听器都不需要直接了解对方的接口。事件的实现取决于语言和库，甚至在给定的语言中，可能存在多个选项。例如，在 C# 中，事件是核心语言的一部分，事件处理相对容易。在 C++ 中，我们没有那么幸运，必须实现我们自己的事件系统或依赖提供此功能的库。</p><p>C++ 程序员有几个已发布的库选项来处理事件；其中最突出的选择是 boost 和 Qt。boost 库支持信号和插槽，这是一种静态类型的机制，供发布者通过回调向订阅者发出事件信号。另一方面，Qt 既提供了完整的事件系统，又提供了动态类型的事件回调机制，巧合的是，这也被称为信号和插槽。这两个库都有详细的文档、经过充分测试、受到尊重，可用于开源和商业用途。任何一个库都是在我们的计算器中实现事件的可行选项。然而，为了教学目的，也为了尽量减少我们计算器后端对外部库的依赖，我们将实现我们自己的事件系统。在设计自己的软件时，做出适当的决策非常依赖于具体情况，你应该权衡使用库与为你的单独应用程序构建自定义事件处理的利弊。也就是说，默认的立场是，除非你有令人信服的理由做其他事情，否则应该使用库。</p><h3 id="3-3-1-观察者模式">3.3.1 观察者模式</h3><p>因为事件处理是 C++ 中如此常见的功能，你可以确信存在一个描述事件处理的设计模式；这个模式就是观察者模式。观察者模式是实现发布者和监听者的抽象实现的标准方法。顾名思义，这里的监听者被称为观察者。</p><p>在 Gamma 等人 [6] 描述的模式中，具体的发布者实现了一个抽象的发布者接口，具体的观察者实现了一个抽象的观察者接口。从概念上讲，实现是通过公共继承进行的。每个发布者都拥有一个观察者容器，发布者的接口允许附加和分离观察者。当事件发生（被引发）时，发布者遍历其观察者集合，并通知每个观察者事件已发生。通过虚拟分派，每个具体观察者根据自己的实现处理此通知消息。</p><p>观察者可以通过两种方式从发布者接收状态信息。首先，具体观察者可以具有指向其正在观察的具体发布者的指针。通过这个指针，观察者可以在事件发生时查询发布者的状态。这种机制称为拉取语义。或者，可以实现推送语义，其中发布者将状态信息与事件通知一起推送给观察者。图 3-1 中展示了展示推送语义的观察者模式的简化类图。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/A454125_1_En_3_Fig1_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图 3-1 为 pdCalc 实现的观察者模式的简化版本的类图。该图说明了事件数据的推送语义。  </div></center><h4 id="3-3-1-1-改进观察者模式实现">3.3.1.1 改进观察者模式实现</h4><p>在我们的计算器的实际实现中，在图 3-1 中描绘的抽象之外添加了一些额外的功能。首先，在图中，每个发布者拥有一个观察者列表，当事件发生时，所有观察者都会收到通知。然而，这种实现意味着发布者要么只有一个事件，要么有多个事件，但是没有办法区分哪些观察者在每个事件中被调用。一个更好的发布者实现方法是持有一个观察者列表的关联数组。这样，每个发布者可以有多个不同的事件，每个事件只通知对观察该特定事件感兴趣的观察者。虽然关联数组中的键在技术上可以是设计者选择的任何合适数据类型，但我选择在计算器中使用字符串。也就是说，发布者通过名称来区分各个事件。这个选择增强了可读性，并允许在运行时灵活地添加事件（相对于，例如，选择枚举值作为键）。</p><p>一旦发布者类可以包含多个事件，程序员需要在调用 attach() 或 detach() 时通过名称指定事件。因此，需要适当地修改这些方法在图 3-1 中出现的签名，以包含事件名称。对于附件，通过添加事件名称来完成方法签名。调用者只需用具体观察者实例和观察者要附加的事件名称调用 attach() 方法即可。然而，从发布者中分离观察者需要稍微复杂一些的机制。由于发布者中的每个事件都可以包含多个观察者，程序员需要有区分观察者以进行分离的能力。自然地，这种需求也导致了观察者的命名，以及 detach() 函数签名必须修改以适应观察者和事件的名称。</p><p>为了方便分离观察者，在每个事件上的观察者应该间接存储并通过其名称引用。因此，我们选择使用观察者的关联数组的关联数组，而不是存储关联数组的观察者列表。</p><p>在现代 C++ 中，程序员可以选择使用 map 或 unordered_map 作为关联数组的标准库实现。这两种数据结构的规范实现分别是红黑树和哈希表。由于关联数组中元素的顺序并不重要，因此我选择了 unordered_map 作为 pdCalc 的 Publisher 类。然而，对于每个事件可能有的少量观察者来说，这两种数据结构都是同样有效的选择。</p><p>到目前为止，我们还没有明确指出观察者在发布者中是如何存储的，只是说它们以某种方式存储在关联数组中。因为观察者是多态的，语言规则要求它们由指针或引用持有。问题变成，发布者应该拥有观察者还是仅引用其他类拥有的观察者？如果我们选择引用途径（通过引用或原始指针），除了发布者之外的其他类需要拥有观察者的内存。这种情况是有问题的，因为在任何特定实例中，谁应该拥有观察者并不清楚。因此，每个开发者可能会选择不同的选项，长期维护观察者会陷入混乱。更糟糕的是，如果观察者的所有者在没有将观察者从发布者分离的情况下释放了观察者的内存，触发发布者的事件会导致崩溃，因为发布者将持有对观察者的无效引用。基于这些原因，我更倾向于让发布者拥有其观察者的内存。</p><p>避免使用引用，我们必须使用拥有语义，由于C<ins>多态性的机制，我们必须通过指针实现所有权。在现代C</ins>中，通过unique_ptr实现指针类型的唯一所有权（请参阅“现代C++设计注意事项”侧边栏中关于拥有语义的部分，以了解设计影响）。将上述所有建议结合起来，我们可以设计出发布者类的最终公共接口，如列表3-3所示。</p><p>列表3-3 发布者类的最终公共接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Publisher.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">PublisherImpl</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(<span class="type">const</span> string&amp; eventName,</span></span></span><br><span class="line"><span class="params"><span class="function">              unique_ptr&lt;Observer&gt; observer)</span></span>;</span><br><span class="line">  <span class="function">unique_ptr&lt;Observer&gt; <span class="title">detach</span><span class="params">(<span class="type">const</span> string&amp; eventName,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> string&amp; observerName)</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unique_ptr&lt;PublisherImpl&gt; publisherImpl_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>事件存储的实现细节如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Publisher.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Publisher</span>::PublisherImpl</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">  <span class="keyword">using</span> ObserversList = unordered_map&lt;string, unique_ptr&lt;Observer&gt;&gt;;</span><br><span class="line">  <span class="keyword">using</span> Events = unordered_map&lt;string, ObserversList&gt;;</span><br><span class="line">  Events events_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>观察者类的接口比发布者类的接口简单得多。然而，由于我还没有描述如何处理事件数据，我们还没有准备好设计观察者的接口。在下面的3.3.1.2节中，我将讨论事件数据和观察者类的接口。</p><hr><p>现代C++设计注意事项：拥有语义和unique_ptr</p><p>在C<ins>中，拥有一个对象的概念意味着在不再需要对象时负责删除其内存。在C</ins>11之前，尽管任何人都可以实现自己的智能指针（很多人都这么做了），但语言本身没有表达标准的指针所有权语义（除了已被弃用的auto_ptr）。通过原生指针传递内存更像是一个信任问题。也就是说，如果你使用“new”创建一个指针，并通过原始指针将其传递给一个库，你希望该库在使用完它后删除内存。或者，库的文档可能会告诉你在执行某些操作后删除内存。在没有标准智能指针的情况下，在最糟糕的情况下，你的程序会泄露内存。在最好的情况下，你必须使用非标准智能指针来与库进行接口。</p><p>C++11通过标准化一组主要来自Boost库的智能指针来解决未知指针所有权的问题。unique_ptr终于允许程序员正确地实现唯一所有权（因此弃用了auto_ptr）。本质上，unique_ptr确保在任何时候只有一个指针实例存在。为了让语言实现这些规则，unique_ptr不实现拷贝和非移动赋值。相反，采用移动语义来确保所有权的转移（也可以使用显式函数调用手动管理内存）。Josuttis[8]提供了一个关于使用unique_ptr机制的详细描述。一个重要的要点是不要在unique_ptr和原始指针之间混合使用指针类型。</p><p>从设计的角度来看，unique_ptr意味着我们可以使用标准C++编写接口，明确地表达唯一所有权语义。正如在观察者模式的讨论中所看到的，唯一所有权语义在任何一个类创建内存供另一个类拥有的设计中都是很重要的。例如，在计算器的事件系统中，虽然事件的发布者应该拥有其观察者，但发布者很少有足够的信息来创建其观察者。因此，能够在一个位置创建观察者的内存，但能够将内存的所有权传递给另一个位置，即发布者，是很重要的。unique_ptr提供了这项服务。因为观察者是通过unique_ptr传递给发布者的，所有权转移到发布者，当发布者不再需要观察者时，智能指针会删除观察者的内存。另外，任何类都可以从发布者那里收回一个观察者。因为detach()方法将观察者以unique_ptr的形式返回，发布者通过将其转移回调用者显然放弃了观察者内存的所有权。</p><hr><p>上述观察者模式的实现明确强制执行发布者拥有其观察者的设计。使用这个实现的最自然方式涉及创建小型的、专用的、中介观察者类，这些类本身持有指向应响应事件的实际类的指针或引用。例如，从第2章我们知道，pdCalc的用户界面是Stack类的观察者。然而，我们真的希望用户界面成为一个由Stack拥有的（公共继承自）观察者，如图3-2a所示吗？不。图3-2c展示了一个更好的解决方案。在这里，Stack拥有一个stack ChangeEvent观察者，当堆栈发生变化时，它会通知UserInterface。这种模式使Stack和UserInterface保持真正的独立性。在第5章学习我们的第一个用户界面时，将对此主题进行更多讨论。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/3.Stack/A454125_1_En_3_Fig2_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图3-2 观察者模式的不同所有权策略  </div></center><p>现代C++确实提供了观察者模式所有权语义的另一个合理选择：共享所有权。如上所述，让Stack拥有用户界面是不合理的。然而，有些人可能认为，与其直接使用户界面成为观察者，不如创建一个额外的ChangeEvent中介类同样不合理。唯一可用的折中选择似乎是让Stack引用用户界面。不过，之前我提到，让发布者引用其观察者是不安全的，因为观察者可能会在发布者下方消失，留下一个悬空的引用。这个悬空引用问题能解决吗？</p><p>幸运的是，现代C++再次解决了这个问题，引入了共享语义（如图3-2b所示）。在这个情况下，观察者使用shared_ptr（参见下面的shared_ptr边栏）共享，而发布者使用weak_ptr（shared_ptr的亲戚）保留对观察者的引用。weak_ptr专门设计用于缓解对共享对象的悬空引用问题。这种发布者共享观察者所有权的设计</p><h4 id="3-3-1-2-处理事件数据">3.3.1.2 处理事件数据</h4><p>在描述观察者模式时，我提到了处理事件数据的两种不同范式：拉取语义和推送语义。在拉取语义中，观察者只被通知事件发生了。然后观察者有责任获取可能需要的任何额外数据。实现非常简单。观察者维护对可能需要获取状态信息的任何对象的引用，并在响应事件时调用成员函数来获取此状态。</p><p>拉取语义有几个优点。首先，观察者在处理事件时可以选择要获取的状态。其次，不会在将可能未使用的参数传递给观察者时消耗不必要的资源。第三，拉取语义易于实现，因为事件不需要携带数据。然而，拉取语义也有缺点。首先，拉取语义增加了耦合，因为观察者需要持有发布者的引用并了解发布者的状态获取接口。其次，观察者只能访问发布者的公共接口。这种访问限制使观察者无法从发布者那里获取私有数据。</p><p>与拉取语义相反，推送语义是通过让发布者在引发事件时发送与事件相关的状态数据来实现的。然后观察者将此状态数据作为通知回调的参数接收。接口通过在抽象Observer基类中将notify函数设为纯虚函数来强制执行推送语义。</p><p>事件处理的推送语义也有优点和缺点。第一个优点是推送语义降低了耦合。发布者和观察者都不需要了解对方的接口。他们只需要遵循抽象的事件处理接口。第二，当发布者推送状态时，可以将私有信息发送给观察者。第三，作为引发事件的对象，发布者可以发送处理事件所需的精确数据。推送语义的主要缺点是实现起来稍微困难，而且在观察者不需要发布者推送的状态数据的情况下可能会产生不必要的开销。最后，请注意，使用推送语义的设计可以通过在推送数据中添加回调引用，总是可以用拉取语义来简单地扩展特殊情况。反之则不然，因为推送语义需要在事件处理机制中专用的基础设施。</p><p>基于上述推送和拉取语义之间的权衡，我选择为pdCalc的事件处理实现推送语义。推送语义的主要缺点是实现的潜在计算开销。然而，由于我们的应用程序不是性能密集型的，这种模式表现出的耦合降低以及发布者维护的参数控制优于轻微的性能开销。我们现在的任务是设计一个通过推送语义传递事件数据的实现。</p><p>为了实现事件处理的推送语义，必须在引发事件时从发布者到观察者传递参数的接口进行标准化。理想情况下，每个发布者/观察者对都会同意要传递的参数类型，当事件被引发时，发布者将调用观察者上的适当成员函数。然而，在我们的发布者/观察者类层次结构中，这种理想情况实际上是不可能的，因为具体发布者不了解具体观察者的接口。具体发布者只能通过在发布者基类中调用raise()函数来通用地引发事件。raise()函数反过来通过观察者基类的虚拟notify()函数多态地通知具体观察者。因此，我们寻求一种通过抽象raise/notify接口传递定制数据的通用技术。</p><p>我们的困境的解决方案相当简单。我们为事件数据创建一个并行的对象层次结构，并通过这个抽象状态接口从发布者传递事件数据到观察者。这个层次结构中的基类，EventData，是一个空类，只包含一个虚拟析构函数。每个需要参数的事件都继承这个基类，并实现适当的数据处理方案。当事件被引发时，发布者通过一个EventData基类指针将数据传递给观察者。在收到数据后，具体观察者将状态数据向下转换为具体数据类，然后通过派生类的具体接口提取所需数据。虽然具体发布者和具体观察者确实需要在数据对象的接口上达成一致，但具体发布者和具体观察者都不需要知道对方的接口。因此，我们保持了松散的耦合。</p><p>为了巩固上述观点，让我们来看一下计算器的 Stack 如何实现状态数据。回想一下第2章，Stack 实现了两个事件，stackChanged() 事件和 error(string) 事件。在这个上下文中，stackChanged() 事件并不有趣，因为该事件没有携带数据。然而，错误事件确实携带了数据。考虑一下 Stack 错误条件的类层次结构，如列表3-4所示。</p><p>列表3-4 事件数据层次结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Publisher.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">EventData</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Stack.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackEventData</span> : <span class="keyword">public</span> EventData</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum class</span> <span class="title class_">ErrorConditions</span> &#123; Empty, TooFewArguments &#125;;</span><br><span class="line">  <span class="built_in">StackEventData</span>(ErrorConditions e) : <span class="built_in">err_</span>(e) &#123; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">Message</span><span class="params">(ErrorConditions ec)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">message</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">ErrorConditions <span class="title">error</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> err_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ErrorConditions err_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>StackEventData 类定义了 Stack 的事件数据如何封装并发送给观察 Stack 的类。当 Stack 模块内发生错误时，Stack 类引发一个事件，并将有关该事件的信息推送给它的观察者。在这种情况下，Stack 创建一个 StackEventData 实例，在构造函数中指定错误类型。这个包含有限错误条件集合的枚举类型可以使用 message() 函数转换为字符串。当观察者被通知事件发生时，他们可以自由地使用或忽略这些信息。如果你注意到了，是的，我微妙地将 error() 接口的签名从 string 更改为了 EventData。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent_.<span class="built_in">raise</span>(Stack::StackError, <span class="built_in">make_shared</span>&lt;StackEventData&gt;(</span><br><span class="line">  StackEventData::ErrorConditions::Empty));</span><br></pre></td></tr></table></figure><p>作为一个具体的例子，假设因为弹出一个空栈而触发错误。为了引发这个事件，Stack 调用以下代码（实际实现略有不同，因为 Stack 被封装在 pimpl 中）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent_.<span class="built_in">raise</span>(Stack::StackError, <span class="built_in">make_shared</span>&lt;StackEventData&gt;(</span><br><span class="line">  StackEventData::ErrorConditions::Empty));</span><br></pre></td></tr></table></figure><p>第一个传递给 raise() 函数的参数是一个解析为 “error” 的静态字符串。回想一下，为了处理多个事件，发布者为每个事件命名。在这里，Stack::StackError 静态变量保存了此事件的名称。使用变量而不是直接使用字符串是为了防止因输入错误的事件名称而导致的运行时错误。raise() 函数的第二个参数创建了 StackEventData 实例，并用空栈错误条件对其进行初始化。注意，实现通过 shared_ptr 传递事件数据。这个决定在下面关于共享语义的侧边栏中进行讨论。尽管 StackObserver 类尚未被介绍，但为了完整起见，我注意到一个事件可以通过以下典型代码进行解释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StackObserver::<span class="built_in">notify</span>(shared_ptr&lt;EventData&gt; d)</span><br><span class="line">&#123;</span><br><span class="line">  shared_ptr&lt;StackEventData&gt; p = <span class="built_in">dynamic_pointer_cast</span>&lt;StackEventData&gt;(d);</span><br><span class="line">  <span class="keyword">if</span>(p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// do something with the data</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// uh oh, what event did we just catch?!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>现代 C++ 设计注意事项：共享语义和 shared_ptr</p><p>shared_ptr 让程序员可以安全地表达共享所有权，而 unique_ptr 让程序员可以安全地表达独占所有权。在 C<ins>11 标准之前，C</ins> 通过原始指针或引用来实现数据共享。因为类数据的引用只能在构造期间初始化，对于延迟绑定数据，只能使用原始指针。因此，通常两个类通过各自包含一个指向公共对象的原始指针来共享单个数据。当然，这种情况的问题是不清楚哪个对象拥有共享对象。特别是，这种模糊意味着不确定何时可以安全地删除这样的共享对象，以及哪个拥有对象最终应该释放内存。shared_ptrs 在标准库级别解决了这个困境。</p><p>shared_ptr 通过引用计数实现共享语义。随着新对象指向 shared_ptr，内部引用计数增加（通过构造函数和赋值实施）。当 shared_ptr 超出范围时，调用其析构函数，从而减少内部引用计数。当计数减少到零时，最后一个 shared_ptr 的销毁触发底层内存的回收。与 unique_ptr 一样，也可以使用显式成员函数调用来手动管理内存。Josuttis [8] 提供了关于使用 shared_ptr 的机制的详细描述。与 unique_ptr 一样，必须小心不要混用指针类型。当然，除了与 weak_ptr 混合使用之外，还有这个规则的例外。此外，引用计数会带来时间和空间开销，因此在部署共享指针之前，读者应该熟悉这些权衡。</p><p>在设计考虑方面，shared_ptr 构造允许程序员在不直接跟踪对象所有权的情况下共享堆内存。对于计算器，按值传递事件数据并不是一个选择。因为事件数据对象存在于一个层次结构中，按值传递事件数据对象会导致切片。然而，使用原始指针（或引用）传递事件数据也会有问题，因为这些数据对象的生命周期在共享它们的类之间无法知晓。自然地，当发布者引发事件时，会分配内存。由于观察者可能希望在事件处理完成后保留内存，发布者不能在事件处理完成后简单地释放内存。此外，由于任何给定事件都可以调用多个观察者，因此发布者也不能将数据的唯一所有权转移给任何给定的观察者。因此，C++11 中标准化的 shared_ptr 提供了处理这种情况的理想语义。</p><hr><p>现在您了解了事件数据，让我们最后编写抽象观察者接口。不出所料，这正是您可能期望的。请参见清单 3-5。</p><p>清单 3-5 抽象观察者接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Observer</span><span class="params">(<span class="type">const</span> string&amp; name)</span></span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">(shared_ptr&lt;EventData&gt;)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-栈作为事件">3.3.2 栈作为事件</h3><p>构建栈的最后一步只是将所有的部分放在一起。清单 3-1 显示了栈作为单例。为了实现事件，我们只需修改这段代码，使其从 Publisher 基类继承。我们现在必须问自己，这种继承应该是公共的还是私有的？</p><p>通常，在面向对象编程中，使用公共继承来表示 is-a 关系。也就是说，公共继承表达了派生类是基类的类型或特化关系。更准确地说，is-a 关系遵循 Liskov 可替换原则（LSP）[29]，该原则规定（通过多态性）一个接受基类指针（引用）作为参数的函数必须能够在不知情的情况下接受派生类指针（引用）。简洁地说，派生类必须能在基类可以使用的地方互换使用。当人们提到继承时，他们通常指的是公共继承。</p><p>私有继承用于表示实现关系。简单地说，私有继承用于将一个类的实现嵌入到另一个类的私有实现中。它不遵循 LSP，实际上，如果继承关系是私有的，C++ 语言不允许将派生类替换为基类。为了完整起见，与私有继承关系密切相关的受保护继承在语义上与私有继承相同。唯一的区别是，在私有继承中，基类实现在派生类中变为私有，而在受保护继承中，基类实现在派生类中变为受保护。</p><p>我们的问题现在已经细化为，栈是发布者还是栈实现了发布者？答案是肯定的，肯定的。这个答案没有帮助，那么我们如何选择呢？</p><p>为了消除这个实例中我们应该使用公共继承还是私有继承的歧义，我们必须深入研究 Stack 类的使用。公共继承，或者说 is-a 关系，表示我们打算将栈多态地作为发布者使用。然而，情况并非如此。虽然 Stack 类是一个发布者，但它不是在可以用 LSP 意义上的发布者替代发布者的上下文中的发布者。因此，我们应该使用私有继承来表明在 Stack 中使用 Publisher 实现的意图。同样地，我们可以说 Stack 提供了 Publisher 服务。如果您一直在关注代码仓库的源代码，您可能已经注意到了私有继承是答案的一个大提示。Publisher 类使用了非虚拟的、受保护的析构函数进行实现，使其无法用于公共继承。</p><p>熟悉面向对象设计的读者可能会想知道为什么我没有问无处不在的 has-a 问题，这表示所有权或聚合关系。也就是说，为什么栈不仅仅拥有一个发布者并重用其实现，而不是从它私下继承呢？许多设计者几乎完全使用聚合来代替私有继承，认为在这两者之间有一个等价的选择时，应该总是优先使用导致松散耦合的语言特性（继承关系比聚合关系更强）。这种观点有一定的道理。不过，就我个人而言，我更愿意接受那种通过较强耦合换取更大清晰度的技术。我认为私有继承比聚合更清楚地表达了实现发布者服务的设计意图。这个决定没有对错之分。在你的代码中，你应该选择符合你口味的风格。</p><p>另一个从发布者类私有继承的结果是，发布者的 attach() 和 detach() 方法变为私有。然而，如果其他类打算订阅栈的事件，它们需要成为栈的公共接口的一部分。因此，实现者必须选择使用 using 语句或转发成员函数将 attach() 和 detach() 提升到栈的公共接口中。在这种情况下，这两种方法都是可以接受的，实现者可以根据自己的个人喜好来选择。</p><h3 id="3-3-3-完整的栈接口">3.3.3 完整的栈接口</h3><p>我们终于准备好编写完整的栈公共接口了。请参见列表 3-6。</p><p>列表 3-6 完整的栈公共接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> : <span class="keyword">private</span> Publisher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Stack&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">double</span>, <span class="type">bool</span> suppressChangeEvent = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">pop</span><span class="params">(<span class="type">bool</span> suppressChangeEvent = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swapTop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">getElements</span><span class="params">(<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">using</span> Publisher::attach;</span><br><span class="line">  <span class="keyword">using</span> Publisher::detach;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如本章所述，栈是一个单例类（注意 Instance() 方法），实现了发布者服务（注意发布者类的私有继承以及将 attach() 和 detach() 方法提升到公共接口中）。栈类的公共部分，结合列表 3-2 中描述的 EventData 类，包含了第二章表 2-2 中介绍的栈模块的完整接口。尽管我还没有描述任何具体的栈观察者，但我们已经为 pdCalc 完全定义了基于经过验证的观察者模式的事件系统。此时，我们准备设计 pdCalc 的下一个组件，命令调度器模块。</p><h2 id="3-4-关于测试的快速说明">3.4 关于测试的快速说明</h2><p>在本章结束介绍 pdCalc 的源代码之前，我应该花一点时间来谈谈测试。尽管测试绝非本书的核心探讨主题，但它仍然是任何高质量实现的一个不可或缺的部分。在 GitHub 上找到的计算器源代码旁边，我还包含了所有的自动化单元测试代码。因为我选择了 Qt 作为 pdCalc 的图形用户界面框架（参见第6章），因此 Qt 测试框架是构建 pdCalc 单元测试套件的自然选择。主要原因是这个选择不会给项目增加任何额外的库依赖，并且测试框架保证能在 Qt 移植的所有平台上工作。话虽如此，许多高质量的 C++ 单元测试框架中的任何一个都同样适用。</p><p>就我个人而言，即使是在编程小项目时，我也认为单元测试是不可或缺的。首先，单元测试为确保代码按预期功能提供了手段。其次，单元测试使你能够在开发用户界面之前就看到模块正确地工作。早期测试使得早期的错误检测成为可能，软件工程的一个众所周知的事实是，越早发现错误，修复错误的成本就越低。我还发现，在开发周期早期看到模块完全工作会产生一种奇怪的动力。最后，单元测试还使你能够知道代码在更改前后的功能是否相同。由于迭代是设计和实现的一个基本要素，你的代码将在你认为已经完成之后多次更改。在每次构建时自动运行全面的单元测试将确保新的更改没有不可预测地破坏任何现有的功能单元。</p><p>因为我非常重视测试（这是我在培训新的专业开发人员时尝试教授的第一课），所以我努力确保 pdCalc 代码的测试完整性。测试代码不仅为读者提供了一个范例（我希望如此），而且还让我确信在编写本书的代码开发部分期间我的代码是正确的。然而，尽管我尽最大努力编写无误的代码，即使在对源代码进行了无数次的审查之后，我仍然确信最终产品中仍然存在错误。请随时给我发送电子邮件报告您发现的任何错误。我将尽最大努力实时将更正内容合并到 GitHub 存储库中的代码，并对首位向我报告错误的读者表示感谢。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Practical C++ Design From Programming to Architecture 1ed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. 分解</title>
      <link href="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/2.Decomposition/"/>
      <url>/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/2.Decomposition/</url>
      
        <content type="html"><![CDATA[<h1>2. 分解</h1><p>软件是复杂的，是人类迄今为止所从事的最复杂的事业之一。当你第一次阅读大型编程项目的需求文档时，你可能会感到不知所措。这是正常的，任务确实很艰巨！正因如此，大型编程项目通常从分析开始。</p><p>项目的分析阶段包括花费时间探索问题领域，以便完全理解问题，澄清需求，并解决客户和开发者领域之间的歧义。如果没有完全理解问题，作为架构师或开发者，你绝对没有机会开发出可维护的设计。然而，对于本书选择的案例研究，领域应该是熟悉的（如果不熟悉，你可能希望在此暂停并进行分析练习）。因此，我们将跳过正式的、独立的分析阶段。话虽如此，分析的某些方面永远不能完全跳过，我们将在设计过程中探讨几种分析技术。这种有意识的分析与设计的结合强调了这两个活动之间的相互作用，以证明即使对于最简单的问题领域，产生一个好的设计也需要一些正式的分析问题的技术。</p><p>我们作为软件设计师解决固有问题复杂性的最重要技术之一是层次分解。大多数人倾向于用两种方式之一来分解问题：自上而下或自下而上。自上而下的方法从整体开始，然后逐步细分问题，直到达到最底层。在软件设计中，绝对的底层是单个功能的实现。然而，自上而下的设计可能会在实现之前停止，最后设计对象及其公共接口。自下而上的方法从单个功能或对象级别开始，反复组合组件，直到最终涵盖整个设计。</p><p>对于我们的案例研究，在设计的各个阶段都将使用自上而下和自下而上的方法。我发现从自上而下的方式开始分解，直到定义了大量模块及其接口为止，然后从自下而上的方式实际设计这些模块是实际的。在解决我们的计算器的分解之前，让我们首先了解一下好的分解的元素。</p><h2 id="2-1-优秀分解的要素">2.1 优秀分解的要素</h2><p>什么使得分解优秀？显然，我们可以随意地将功能拆分到不同的模块中，并将完全不相关的组件进行分组。以计算器为例，我们可以将算术运算符和图形用户界面（GUI）放在一个模块中，而将三角函数、堆栈和错误处理放在另一个模块中。这是一种分解，只是不是非常有用的一种。</p><p>总的来说，一个好的设计会显示出模块化、封装、内聚和低耦合等特点。许多开发人员已经在面向对象设计的背景下看到了许多优秀分解的原则。毕竟，将代码拆分为对象本身就是一个分解过程。让我们首先在抽象的背景下研究这些原则。接下来，我将通过将这些原则应用到pdCalc来让讨论更具体。</p><p>模块化，即将组件拆分为独立互动的部分（模块），有几个重要原因。首先，它立即使人们能够将一个大型、复杂的问题划分为多个更小、更易处理的组件。一次性尝试为整个计算器实现代码可能很困难，但实现一个独立运行的堆栈是相当合理的。其次，一旦组件被拆分成不同的模块，可以定义单元测试来验证单个模块，而无需在测试开始之前完成整个程序。第三，对于大型项目，如果定义了具有清晰边界和接口的模块，开发工作就可以在多个程序员之间进行分配，防止他们因需要修改相同的源文件而不断干扰彼此的进展。</p><p>良好设计的其余原则，封装、内聚和低耦合，都描述了模块应具备的特征。基本上，它们可以防止出现“意大利面条式”代码。封装，或信息隐藏，是指一旦定义了一个模块，其内部实现（数据结构和算法）就对其他模块保持隐藏。相应地，一个模块不应使用任何其他模块的私有实现。这并不是说模块之间不应互相交互。相反，封装坚持模块之间只通过明确定义的、最好是有限的接口进行交互。这种明确的分离确保了内部模块实现可以独立修改，而不必担心破坏外部依赖代码，前提是接口保持固定并且接口保证的契约得到满足。</p><p>内聚是指模块内部的代码应该是自洽的，或者如其名字所暗示的，具有内聚性。也就是说，一个模块内的所有代码应该在逻辑上是协同的。回到我们糟糕的计算器设计示例，一个将算术代码与用户界面代码混合在一起的模块会缺乏内聚性。除了它们都是计算器的组件之外，这两个概念之间没有逻辑联系。虽然像我们的计算器这样的小代码即使缺乏内聚性也不会完全难以理解，但总的来说，一个庞大的、非内聚的代码库非常难以理解、维护和扩展。</p><p>内聚性差可以以两种方式之一表现：要么本不应该放在一起的代码被塞在一起，要么本应该放在一起的代码被分开。在第一种情况下，代码功能几乎无法分解为在心智上可以管理的抽象，因为在逻辑子组件之间没有明确的边界。在后一种情况下，阅读或调试不熟悉的代码（尤其是第一次）可能会非常令人沮丧，因为代码的典型执行路径似乎是以随机的方式从一个文件跳到另一个文件。这两种表现都是逆作用的，因此我更喜欢内聚的代码。</p><p>最后，我们来研究耦合。耦合表示组件之间的相互连接，可以是功能耦合或数据耦合。功能耦合发生在一个模块的逻辑流程需要调用另一个模块来完成其操作。相反，数据耦合是指模块之间通过直接共享（例如，一个或多个模块指向一组共享数据）或通过传递数据（例如，一个模块将内部数据结构的指针返回给另一个模块）来共享数据。主张零耦合显然是荒谬的，因为这种状态意味着一个模块无法与其他任何模块进行任何形式的通信。然而，在良好的设计中，我们确实努力实现低耦合。低应该有多低？轻率的回答是尽可能低，同时仍保持必要的功能。现实是，在不过分复杂化代码的情况下最小化耦合是一种随着经验积累而获得的技能。与封装一样，低耦合是通过确保模块之间只通过清晰定义的、有限的接口进行通信来实现的。高耦合的代码难以维护，因为一个模块设计上的小改动可能会导致许多无法预见的、级联式的变化，穿过看似无关的模块。请注意，封装保护模块A免受模块B内部实现变化的影响，而低耦合保护模块A免受模块B接口变化的影响。</p><h2 id="2-2-选择架构">2.2 选择架构</h2><p>虽然现在我们很想遵循上述指南，将计算器分解成看似合理的组成部分，但最好先看看别人是否已经解决了我们的问题。因为在编程中类似的问题经常出现，软件架构师已经创建了一个解决这些问题的模板目录；这些原型被称为模式。模式通常有多种形式。本书将研究的两类模式是设计模式[6]和架构模式。</p><p>设计模式是用于解决软件设计过程中出现的类似问题的概念模板；它们通常应用于局部决策。在本书中，我们将在计算器的详细设计过程中反复遇到设计模式。然而，我们的第一层次分解需要一个全局范围的模式，来定义整个设计策略，即软件架构。这类模式自然被称为架构模式。</p><p>架构模式在概念上类似于设计模式；两者主要在适用领域上有所不同。设计模式通常应用于特定类或相关类集合，而架构模式通常概述整个软件系统的设计。请注意，我提到的是软件系统而不是程序，因为架构模式可以超越简单的程序边界，包括硬件接口或多个独立程序的耦合。对我们的案例研究特别感兴趣的两种架构模式是多层架构和模型-视图-控制器（MVC）架构。在将它们应用于pdCalc之前，我们将抽象地研究这两种模式。成功将架构模式应用于我们的案例研究将代表计算器的第一层分解。</p><h3 id="2-2-1-多层架构">2.2.1 多层架构</h3><p>在多层（或 n 层）架构中，组件按层次顺序排列。通信是通过相邻层次的双向的，但不允许非相邻层次直接通信。n 层架构如图 2-1 所示。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/2.Decomposition/A454125_1_En_2_Fig1_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图 2-1 多层架构，箭头表示通信  </div></center><p>多层架构的最常见形式是三层架构。第一层是表示层，包括所有用户界面代码。第二层是逻辑层，捕获所谓的应用程序的“业务逻辑”。第三层是数据层，顾名思义，封装了系统的数据。很多时候，三层架构被应用为企业级平台，其中每个层次不仅可以表示不同的本地过程，还可能表示在不同机器上运行的不同过程。在这样的系统中，表示层将是客户端界面，无论是传统的桌面应用程序还是基于浏览器的界面。程序的逻辑层可以在应用程序的客户端或服务器端运行，或者可能在两者之间运行。最后，数据层将由可能在本地或远程运行的数据库表示。然而，正如您将在 pdCalc 中看到的，三层架构也可以应用于单个桌面应用程序。</p><p>让我们来看一下三层架构如何遵循我们的一般分解原则。首先，在最高层次的分解中，该架构是模块化的。至少存在三个模块，每层一个。然而，三层架构并不排除每层存在多个模块。如果系统足够大，每个主要模块都需要细分。其次，这种架构鼓励封装，至少在层之间。虽然人们可能愚蠢地设计一个三层架构，其中相邻层访问相邻层的私有方法，但这种设计是违背直觉的，也非常脆弱。也就是说，在层共存于同一个进程空间的应用程序中，层之间的交织是非常容易的，必须小心确保这种情况不会发生。这种分离是通过明确划定每个层次的界限并通过明确的接口来实现的。第三，三层架构是有凝聚力的。架构的每个层次都有一个明确的任务，这些任务与其他层次的任务没有混合在一起。最后，三层架构在有限耦合方面表现得非常出色。通过将每个层次通过清晰定义的接口进行分离，每个层次都可以独立于其他层次进行更改。这一特性对于必须在多个平台上执行的应用程序（仅表示层在平台间发生变化）或在其生命周期中经历特定层次意外替换的应用程序（例如，由于可扩展性问题，需要更改数据库）尤为重要。</p><p>2.2.2 模型-视图-控制器（MVC）架构</p><p>在模型-视图-控制器架构中，组件被分解为三个不同的元素，分别是模型、视图和控制器。模型抽象了领域数据，视图抽象了用户界面，控制器管理模型和视图之间的交互。通常，MVC模式被应用于框架级别的单独GUI小部件，设计目标是在可能与相同数据关联的多个不同视图的情况下将数据与用户界面分离。例如，考虑一个日程安排应用程序，要求该应用程序必须能够存储约会的日期和时间，但用户可以按日、周或月查看这些约会的日历。应用MVC，约会数据由模型模块（可能是面向对象框架中的一个类）抽象，每种日历样式由一个独立的视图（可能是三个单独的类）抽象。引入控制器来处理视图生成的用户事件并操作模型中的数据。</p><p>乍一看，MVC似乎与三层架构没有什么不同，模型替换了数据层，视图替换了表示层，控制器替换了业务逻辑层。然而，这两种架构模式在交互模式上有所不同。在三层架构中，层之间的通信是严格线性的。也就是说，表示层和数据层只与逻辑层双向通信，而不是彼此通信。在MVC中，通信是三角形的。虽然不同的MVC实现在确切的通信模式上有所不同，但典型的实现如图2-2所示。在这个图中，视图既可以生成由控制器处理的事件，也可以直接从模型中获取要显示的数据。控制器处理来自视图的事件，但它也可以直接操作模型或控制器。最后，模型可以直接由视图或控制器操作，但它也可以生成由视图处理的事件。一个典型的这样的事件是状态更改事件，这将导致视图更新向用户的呈现。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/2.Decomposition/A454125_1_En_2_Fig2_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图2-2 带有指示通信箭头的MVC架构。实线表示直接通信。虚线表示间接通信（例如，通过事件处理）[30]。  </div></center><p>正如我们在分析三层架构时所做的那样，现在让我们检查MVC如何遵循一般的分解原则。首先，一个MVC架构通常会被分解成至少三个模块：模型、视图和控制器。然而，与三层架构一样，一个更大的系统将允许更多的模块，因为每个模型、视图和控制器都需要细分。第二，这种架构也鼓励封装。模型、视图和控制器只应通过清晰定义的接口相互交互，事件和事件处理被定义为接口的一部分。第三，MVC架构是有凝聚力的。每个组件都有一个明确、定义明确的任务。最后，我们要问MVC架构是否松散耦合。通过检查，这种架构模式比三层架构更紧密耦合，因为表示层和数据层被允许具有直接依赖关系。在实践中，这些依赖关系通常通过松散耦合的事件处理或通过抽象基类的多态性来限制。然而，典型地，这种额外的耦合通常将MVC模式限制在一个内存空间中的应用程序。这种限制与三层架构的灵活性形成鲜明对比，后者可以跨多个内存空间扩展应用程序。</p><h3 id="2-2-3-将架构模式应用于计算器">2.2.3 将架构模式应用于计算器</h3><p>现在让我们回到我们的案例研究，并将上述讨论的两种架构模式应用于pdCalc。最终，我们将选择一个作为我们应用程序的架构。如前所述，三层架构包括表示层、逻辑层和数据层。对于计算器，这些层分别明确地被定义为输入命令和查看结果（通过图形或命令行用户界面）、命令的执行以及栈。对于MVC架构，我们有栈作为模型，用户界面作为视图，命令调度器作为控制器。两种计算器架构都在图2-3中描述。请注意，在三层和MVC架构中，表示层或视图的输入方面只负责接受命令，而不是解释或执行它们。实施这种区分可以缓解开发人员为自己制造的一个常见问题：将表示层与逻辑层混合。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="300" height="200" src="/2023/03/26/Practical-Cpp-Design-From-Programming-to-Architecture/2.Decomposition/A454125_1_En_2_Fig3_HTML.gif" alt>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block; color: #999; padding: 2px;">        图2-3 计算器架构选项  </div></center><h3 id="2-2-4-选择计算器的架构">2.2.4 选择计算器的架构</h3><p>从图2-3中，我们很快可以看出这两种架构将计算器划分为相同的模块。事实上，在架构层面上，这两种竞争架构之间的差异仅在于它们的耦合。因此，在这两种架构之间进行选择时，我们只需要考虑它们两种通信模式之间的设计权衡。</p><p>显然，三层架构和MVC架构之间的主要区别是用户界面（UI）与堆栈之间的通信模式。在三层架构中，UI和堆栈只允许通过命令调度器间接通信。这种分离的最大好处是系统耦合性的降低。UI和堆栈不需要了解对方的接口。当然，缺点是，如果程序需要大量的UI和堆栈直接通信，命令调度器将被要求进行此通信的调解，这将降低命令调度器模块的内聚性。MVC架构有完全相反的权衡。也就是说，以增加耦合为代价，UI可以直接与堆栈交换消息，避免命令调度器执行与其主要功能无关的附加功能的尴尬。因此，架构决策归结为检查UI是否经常需要与堆栈直接连接。</p><p>在一个RPN计算器中，堆栈充当程序输入和输出的存储库。用户通常希望看到堆栈上的输入和输出完全相同。这种情况更倾向于使用MVC架构，因为它直接在视图和数据之间进行交互。也就是说，计算器的视图不需要命令调度器来翻译数据和用户之间的通信，因为不需要对数据进行转换。因此，我选择了模型-视图-控制器作为pdCalc的架构。诚然，对于我们的案例研究来说，MVC架构相对于三层架构的优势很小。如果我选择使用三层架构，pdCalc仍然会有一个完全有效的设计。</p><h2 id="2-3-接口">2.3 接口</h2><p>尽管在选择了MVC架构之后，我们可能会很想立即宣布第一层分解完成，但我们还不能宣布胜利。虽然我们已经定义了我们的三个最高级别的模块，但我们还必须定义它们的公共接口。然而，在没有利用一些正式方法来捕捉我们问题中的所有数据流的情况下，我们很可能会遗漏接口中关键的必要元素。因此，我们转向一种面向对象的分析技术：用例。</p><p>用例是一种分析技术，生成一个用户与系统进行特定操作的描述。本质上，用例定义了一个工作流。重要的是，用例不指定实现。在生成用例时，应咨询客户，特别是在用例揭示需求模糊的情况下。有关用例和用例图的详细信息可以在Booch等文献中找到[4]。</p><p>为了设计pdCalc高级模块的接口，我们首先定义与计算器互动的最终用户的用例。每个用例应定义一个单独的工作流，我们应提供足够的用例来满足计算器的所有技术要求。然后，可以研究这些用例，以发现模块之间所需的最小交互。这些通信模式将定义模块的公共接口。这种用例分析的附加好处是，如果我们现有的模块不足以实现所有工作流程，我们将发现了在顶层设计中需要额外模块的需求。</p><h3 id="2-3-1-计算器用例">2.3.1 计算器用例</h3><p>让我们为需求创建用例。为保持一致性，按照需求中的顺序创建用例。</p><h4 id="2-3-1-1-用例：用户输入浮点数到栈中">2.3.1.1 用例：用户输入浮点数到栈中</h4><p>场景：用户将一个浮点数输入到栈中。输入后，用户可以看到栈上的数字。</p><p>异常：用户输入无效的浮点数。显示错误状态。</p><h4 id="2-3-1-2-用例：用户撤销上一个操作">2.3.1.2 用例：用户撤销上一个操作</h4><p>场景：用户输入撤销上一个操作的命令。系统撤销上一个操作并显示之前的栈。</p><p>异常：没有可撤销的命令。显示错误状态。</p><h4 id="2-3-1-3-用例：用户重做上一个操作">2.3.1.3 用例：用户重做上一个操作</h4><p>场景：用户输入重做上一个操作的命令。系统重做上一个操作并显示新的栈。</p><p>异常：没有可重做的命令。显示错误状态。</p><h4 id="2-3-1-4-用例：用户交换栈顶元素">2.3.1.4 用例：用户交换栈顶元素</h4><p>场景：用户输入交换栈顶两个元素的命令。系统交换栈顶两个元素并显示新的栈。</p><p>异常：栈中至少没有两个数字。显示错误状态。</p><h4 id="2-3-1-5-用例：用户删除栈顶元素">2.3.1.5 用例：用户删除栈顶元素</h4><p>场景：用户输入删除栈顶元素的命令。系统删除栈顶元素并显示新的栈。</p><p>异常：栈为空。显示错误状态。</p><h4 id="2-3-1-6-用例：用户清空栈">2.3.1.6 用例：用户清空栈</h4><p>场景：用户输入清空栈的命令。系统清空栈并显示空栈。</p><p>异常：无。即使对空栈执行清空操作也会成功（不执行任何操作）。</p><h4 id="2-3-1-7-用例：用户复制栈顶元素">2.3.1.7 用例：用户复制栈顶元素</h4><p>场景：用户输入复制栈顶元素的命令。系统复制栈顶元素并显示新的栈。</p><p>异常：栈为空。显示错误状态。</p><h4 id="2-3-1-8-用例：用户对栈顶元素取反">2.3.1.8 用例：用户对栈顶元素取反</h4><p>场景：用户输入对栈顶元素取反的命令。系统对栈顶元素取反并显示新的栈。</p><p>异常：栈为空。显示错误状态。</p><h4 id="2-3-1-9-用例：用户执行算术运算">2.3.1.9 用例：用户执行算术运算</h4><p>场景：用户输入加、减、乘、除的命令。系统执行操作并显示新的栈。</p><p>异常：栈的大小不足以支持操作。显示错误状态。</p><p>异常：检测到除以零。显示错误状态。</p><h4 id="2-3-1-10-用例：用户执行三角运算">2.3.1.10 用例：用户执行三角运算</h4><p>场景：用户输入sin、cos、tan、arcsin、arccos或arctan的命令。系统执行操作并显示新的栈。</p><p>异常：栈的大小不足以支持操作。显示错误状态。</p><p>异常：操作的输入无效（例如，arctan(−50)产生一个虚数结果）。显示错误状态。</p><h4 id="2-3-1-11-用例：用户执行-y-x">2.3.1.11 用例：用户执行 y^x</h4><p>场景：用户输入执行 y^x 的命令。系统执行操作并显示新的栈。</p><p>异常：栈的大小不足以支持操作。显示错误状态。</p><p>异常：操作的输入无效（例如，−10.5产生一个虚数结果）。显示错误状态。</p><h4 id="2-3-1-12-用例：用户执行-sqrt-x-y">2.3.1.12 用例：用户执行 $ \sqrt[x]{y} $</h4><p>场景：用户输入执行 $ \sqrt[x]{y} $ 的命令。系统执行操作并显示新的栈。</p><p>异常：栈的大小不足以支持操作。显示错误状态。</p><p>异常：操作的输入无效（例如，$ \sqrt[4]{-1} $ 产生一个虚数结果）。显示错误状态。</p><h4 id="2-3-1-13-用例：用户加载插件">2.3.1.13 用例：用户加载插件</h4><p>场景：用户将插件放入插件目录。系统在启动时加载插件，使插件功能可用。</p><p>异常：插件无法加载。显示错误状态。</p><h3 id="2-3-2-用例分析">2.3.2 用例分析</h3><p>我们现在将分析用例，以便为 pdCalc 的模块开发 C++ 接口。请记住，C++ 语言没有正式定义模块概念。因此，请将接口在概念上视为面向一组逻辑上分组以定义模块的类和函数的公共函数签名。为了简洁起见，在文本中省略了 std 命名空间前缀。</p><p>让我们按顺序检查用例。在开发公共接口时，将其输入到表 2-2 中。对于第一个用例，其接口将在表 2-1 中描述。通过为第一个用例使用单独的表，我们将能够保留我们在第一次尝试时所犯的错误，以便与我们最终的产品进行比较。到本节结束时，所有模块的整个公共接口都将被开发和编录。</p><p>我们从第一个用例开始：输入一个浮点数。用户界面的实现将负责将用户的数字输入到计算器中。这里，我们关心的是将数字从UI传递到堆栈所需的接口。</p><p>无论数字从UI到堆栈走的路径如何，我们最终都必须有一个用于将数字压入堆栈的函数调用。因此，我们接口的第一部分只是堆栈模块上的一个函数push()，用于将双精度数字压入堆栈。我们将这个函数输入到表2-1中。请注意，表中包含完整的函数签名，而文本中省略了返回类型和参数类型。</p><p>现在，我们必须探讨从用户界面模块到堆栈模块的数字传递选项。从图2-3b中，我们可以看到UI与堆栈之间有直接的链接。因此，最简单的选择是将浮点数直接从UI使用我们刚刚定义的push()函数压入堆栈。这是个好主意吗？</p><p>根据定义，命令分发器模块，即控制器，用于处理用户输入的命令。输入一个数字应该与例如加法命令有什么不同吗？让UI绕过命令分发器，直接将一个数字输入到堆栈模块，违反了最小惊讶原则（也称为最小惊异原则）。从本质上讲，这一原则指出，当一个设计者面临多个有效的设计选项时，正确的选择是符合用户直觉的那个。在接口设计的背景下，用户是另一个程序员或设计师。在这里，我们系统上的任何程序员都会期望所有命令被相同地处理，因此一个好的设计将遵循这一原则。</p><p>为了避免违反最小惊讶原则，我们必须构建一个接口，将新输入的数字从UI通过命令分发器进行路由。我们再次参考图2-3b。不幸的是，UI与命令分发器之间没有直接连接，使得直接通信变得不可能。然而，它确实具有一个间接的通道。因此，我们唯一的选择是让UI触发一个事件（在第3章中，您将详细研究事件）。具体来说，UI必须触发一个表明输入了一个数字的事件，命令分发器必须能够接收到这个事件（最终通过其公共接口中的函数调用）。让我们在表2-1中添加两个函数，一个是UI引发的numberEntered()事件，另一个是命令分发器中的numberEntered()事件处理函数。</p><p>一旦数字被接受，UI必须显示更新后的堆栈。这是通过堆栈发出已更改的信号来实现的，视图请求堆栈中的n个元素并将它们显示给用户。我们必须使用这条路径，因为堆栈与UI之间只有间接的通信渠道。我们在表2-1中添加三个函数：堆栈模块上的stackChanged()事件，UI上的stackChanged()事件处理程序，以及堆栈模块上的getElements()函数（关于getElements()函数签名的选项，请参阅“现代C++设计”侧边栏上关于移动语义的部分）。与输入数字本身不同，让UI在响应stackChanged()事件时直接调用堆栈的获取元素函数是合理的。实际上，这正是我们希望视图与其数据在MVC模式中进行交互的方式。</p><p>当然，前述工作流程假设用户输入了一个有效的数字。然而，为了完整性，用例还规定必须对数字输入进行错误检查。因此，命令调度器实际上应该在将数字推入堆栈之前检查数字的有效性，并在发生错误时向用户界面发出信号。UI相应地应该能够处理错误事件。这就是表2-1中的另外两个函数：命令调度器上的 error() 事件，以及 UI 上的处理错误事件的函数 displayError()。请注意，我们本可以选择一种备选的错误处理设计，让 UI 执行自己的错误检查，并仅为有效数字引发已输入数字事件。然而，为了提高内聚性，我更喜欢将错误检查的“业务逻辑”放在控制器而不是界面中。</p><p>唉！这完成了我们对第一个用例的分析。以防你迷失了方向，请记住刚刚描述的所有函数和事件都汇总在表2-1中。现在还有12个激动人心的用例要完成我们的接口分析！别担心，这种单调乏味的工作很快就会结束。我们很快就会得出一个设计，可以将几乎所有用例整合到一个统一的接口中。</p><p>表 2-1 从输入浮点数到栈的用例分析中得到的公共接口</p><table><thead><tr><th></th><th>Functions</th><th>Events</th></tr></thead><tbody><tr><td>User Interface</td><td>void displayError(const string&amp;)</td><td>numberEntered(double)</td></tr><tr><td></td><td>void stackChanged()</td><td></td></tr><tr><td>Command Dispatcher</td><td>void numberEntered(double)</td><td>error(string)</td></tr><tr><td>Stack</td><td></td><td></td></tr><tr><td></td><td>void push(double)</td><td>stackChanged()</td></tr><tr><td></td><td>stackChanged()</td><td></td></tr></tbody></table><p>在立即进行下一个用例之前，让我们先暂停一下，讨论一下我们刚刚在错误处理方面隐含做出的两个决策。首先，用户界面通过捕获事件而不是捕获异常来处理错误。由于用户界面无法直接向命令调度器发送消息，因此 UI 永远无法在 try 块中包装对命令调度器的调用。这种通信模式立即排除了使用 C++ 异常进行模块间错误处理（注意，这并不排除在单个模块内部使用异常）。在这种情况下，由于数字输入错误是在命令调度器中捕获的，我们本可以使用回调直接通知 UI。然而，这种惯例不够通用，因为它会在堆栈中检测到错误时崩溃，因为堆栈与 UI 之间没有直接通信。其次，我们决定将所有错误（无论原因如何）通过将描述错误的字符串传递给 UI 来处理，而不是创建错误类型的类层次结构。这个决定是有道理的，因为 UI 从不尝试区分错误。相反，UI 只是充当从其他模块直接显示错误消息的通道。</p><hr><p>现代 C++ 设计笔记：移动语义</p><p>在表2-1中，堆栈有一个函数 void getElements(n, vector<double>&amp;)，允许调用者用堆栈顶部的前n个元素填充一个向量。然而，函数的接口没有告诉我们元素实际是如何添加到向量中的。它们是添加在前面吗？它们是添加在后面吗？是否假设向量已经正确调整大小，并使用 operator[] 输入新元素？在添加新元素之前，旧元素是否从向量中擦除？希望这种模糊性可以通过开发者文档得到解决（祝你好运）。在没有进一步信息的情况下，人们可能会得出这样的结论：新元素只是被推到向量的后面。</double></p><p>然而，从C++11开始，上述接口歧义可以通过语言本身在语义上得到解决。右值引用和移动语义允许我们明确地进行这个接口决策。我们现在可以高效地（即，不复制向量或依赖编译器实现返回值优化）实现函数 vector<double> getElements(n)。在函数内部创建一个临时向量，然后将其内容移动到函数返回时的调用者。接口契约现在是明确的：将返回一个大小为 n 的新向量，并用堆栈顶部的前 n 个元素填充它。</double></p><p>为了不使文本中的接口过于臃肿，定义接口的表格中两种函数变体都没有明确地出现。然而，两种变体都出现在源代码中。这本书经常使用这种约定。在实现中，有多个执行相同操作的辅助调用是有用的，它们都出现在那里，但文本中只出现一种变体。这种省略对于本书的说明目的是可以接受的，但对于一个真实项目的详细设计规范来说，这种省略是不可接受的。</p><hr><p>下一个用例是撤销和重做操作，它们足够相似，可以同时分析。首先，我们需要为用户界面添加两个新事件：一个用于撤销，一个用于重做。相应地，我们必须在命令调度器中分别为撤销和重做添加两个事件处理函数。在将这些函数简单地添加到表2-2之前，让我们后退一步，看看是否可以简化。</p><p>表 2-2 整个第一级分解的公共接口</p><table><thead><tr><th></th><th>Functions</th><th>Events</th></tr></thead><tbody><tr><td>User Interface</td><td>void postMessage(const string&amp;)</td><td>numberEntered(double)</td></tr><tr><td></td><td>void stackChanged()</td><td></td></tr><tr><td>Command Dispatcher</td><td>void commandEntered(const string&amp;)</td><td>error(string)</td></tr><tr><td>Stack</td><td>void push(double)</td><td>stackChanged()</td></tr><tr><td></td><td>void getElements(n, vector<double>&amp;)</double></td><td>error(string)</td></tr><tr><td></td><td>double pop()</td><td></td></tr><tr><td></td><td>void swapTop()</td><td></td></tr></tbody></table><p>此时，您应该从表格中添加的用户界面事件中看到一个模式。每个用例都添加了一个形式为commandEntered()的新事件，其中command到目前为止已被替换为number、undo或redo。在后续用例中，命令可能会被替换为诸如swap、add、sin、exp等操作。与其继续通过为每个命令在用户界面和命令调度器中提供新的事件来使界面变得臃肿，我们可以用一个通用 sounding UI事件commandEntered()和命令调度器中的伙伴事件处理器commandEntered()来替换这个命令族。这个事件/处理器对的单一参数是一个字符串，它编码了给定的命令。对于输入的数字，参数是数字的ASCII表示。</p><p>将所有UI命令事件合并为一个带有字符串参数的事件，而不是将每个命令作为单独的事件发布，可以实现多个设计目的。首先，最直接的是，这个选择使界面更简洁。我们现在只需要一对函数来处理来自所有命令的事件，包括来自需求的已知命令和可能来自未来扩展的未知命令。然而，更重要的是，这种设计提高了内聚性，因为现在用户界面无需了解它触发的任何事件。相反，将命令事件的解析放在命令调度器中，这是这个逻辑自然属于的地方。为命令创建一个commandEntered()事件甚至直接影响到命令、图形用户界面按钮和插件的实现。关于这些主题的讨论，我将保留到第4章、第6章和第7章。</p><p>现在我们回到撤销和重做用例的分析。如前所述，我们将放弃在表2-2中为我们遇到的每个新命令添加新的命令事件。相反，我们将commandEntered()事件添加到UI，将commandEntered()事件处理器添加到命令调度器。这个事件/处理器对将适用于所有用例中的所有命令。然而，堆栈尚未具备实现所有命令所需的全部功能。例如，为了撤销对堆栈的压入，我们需要能够从堆栈中弹出数字。让我们在表2-2中为堆栈添加一个pop()函数。最后，我们注意到，如果我们试图弹出一个空堆栈，可能会发生堆栈错误。因此，我们为堆栈添加一个通用的error()事件，以反映命令调度器上的错误事件。</p><p>我们接着分析下一个用例，交换堆栈顶部。显然，这个命令将重用前面用例中的commandEntered()和error()模式，所以我们只需要确定是否需要向堆栈的接口添加一个新函数。显然，交换堆栈顶部的两个元素可以通过在堆栈上实现一个swapTop()函数或通过现有的push()和pop()函数来实现。我有点武断地选择实现一个单独的swapTop()函数，所以我将其添加到表2-2中。这个决定可能是潜意识里植根于我追求效率的自然设计倾向（我大部分的专业项目都是高性能数值模拟），以重用为代价。事后来看，这可能不是更好的设计决策，但这个例子说明，有时设计决策仅仅基于设计者的直觉，这些直觉受到他或她个人经验的影响。</p><p>此时，快速浏览剩下的用例表明，除了加载插件外，表2-2定义的现有模块接口足以处理计算器的所有用户交互。每个新命令仅向命令调度器添加内部功能，其中逻辑将在第4章详述。因此，唯一剩下的要检查的用例涉及加载pdCalc的插件。虽然加载插件很复杂，但它对计算器的其他模块的影响很小。除了命令和用户界面注入（你将在第7章遇到这些主题），插件加载器是一个独立的组件。因此，我们推迟其接口的设计（以及对其他接口的必要相应更改），直到我们准备实现插件。</p><p>推迟设计顶层接口的重要部分是一个有些冒险的主意，设计纯粹主义者可能会反对。然而，在实践中，我发现当大部分主要元素已经设计好时，你需要开始编码。无论如何，设计在实现过程中都会发生变化，所以过度努力追求最初设计的完美主要是徒劳的。当然，一个人也不应该在敏捷狂热中完全放弃所有的预先设计！</p><p>然而，采用推迟设计主要组件策略存在一些警告。首先，如果延迟的设计部分会对架构产生实质性影响，那么延迟可能会导致以后的重大返工。其次，推迟设计的部分会延长接口的稳定化。这种延迟可能会对独立开发相互连接的组件的大团队产生问题。了解哪些可以推迟，哪些不能推迟的知识只有通过经验才能获得。如果你不确定一个组件的设计是否可以安全地推迟，最好谨慎行事，提前进行一些额外的设计和分析工作，以尽量减少对整体架构的影响。影响程序架构的糟糕设计将在项目期间影响开发。它们比糟糕的实现造成更多的重大返工，在最糟糕的情况下，糟糕的设计决策变得无法用经济手段解决。有时候，它们只能在一次重大的重写中得到解决，而这可能永远都不会发生。</p><p>在完成用例分析之前，让我们比较一下表2-1中为第一个用例开发的接口与表2-2中涵盖所有用例的接口。令人惊讶的是，表2-2仅比表2-1稍长一些。这证明了将命令抽象为一个通用函数而不是为每个命令设计单独函数的设计决策。简化模块间的通信模式是设计代码而不仅仅是瞎编乱写的众多节省时间优势之一。第一个接口和完整接口之间的唯一其他区别是添加了一些堆栈函数和修改了一些函数名（例如，将displayError()函数重命名为postMessage()以增加操作的通用性）。</p><h3 id="2-3-3-关于实际实现的简要说明">2.3.3 关于实际实现的简要说明</h3><p>对于本文而言，如表2-2所示的开发接口代表了实际部署在代码中的接口的理想化。实际代码在语法上可能略有不同，但接口的语义意图将始终保持一致。例如，在表2-2中，我们定义了获取n个元素的接口为 void getElements(n, vector<double>&amp;)，这是一个完全可行的接口。然而，使用现代C++的新特性（参见移动语义的侧边栏），实现利用右值引用和移动构造，同时提供了vector<double> getElements(n)作为逻辑等价的重载接口。</double></double></p><p>定义良好的C<ins>接口是一项非常复杂的任务；我知道至少有一本专门讲述这个主题的优秀书籍[20]。在这本书中，我只提供了足够的关于所需接口的细节，以清晰地解释设计。可用的源代码展示了开发高效C</ins>接口所需的复杂性。在一个非常小的项目中，允许开发人员在调整接口方面有一定的自主权通常是可以容忍的，而且通常是有益的，因为它允许实现细节延迟到可以实际确定的时候。然而，在大规模开发中，为了防止独立团队之间的绝对混乱，最好在实现开始之前尽早确定接口。</p><h2 id="2-4-对我们当前设计的评估">2.4 对我们当前设计的评估</h2><p>在开始详细设计我们的三个主要组件之前，让我们停下来根据本章开始时确定的标准评估我们当前的设计。首先，我们已经定义了三个不同的模块，所以我们的设计显然是模块化的。其次，每个模块都作为一个有凝聚力的单元，每个模块专注于一个特定的任务。用户界面代码属于一个模块，操作逻辑属于另一个模块，而数据管理属于另一个单独的模块。此外，每个模块都封装了自己的所有功能。最后，这些模块之间的耦合程度较低，且在需要耦合的地方，都通过一组清晰定义、简洁的公共接口进行耦合。我们的顶层架构不仅满足了良好设计的标准，而且符合一个已经成功应用了数十年的众所周知且被广泛研究的架构设计模式。在这一点上，我们已经重新确认了设计的质量，应该非常自信地进行下一步分解，即设计各个组件。</p><h2 id="2-5-下一步">2.5 下一步</h2><p>接下来我们该怎么做呢？我们现在已经建立了计算器的整体架构，但是我们如何应对选择首先设计和实现哪个组件的任务呢？在公司环境中，对于大型项目来说，很可能许多模块会同时进行设计和编码。毕竟，这不正是创建清晰界定的不同模块并通过接口分离它们的主要原因之一吗？当然，对于我们的项目，这些模块将按顺序处理，进行一定程度的迭代以进行事后改进。因此，我们必须选择一个模块先进行设计和构建。</p><p>在这三个模块中，最合理的起点是与其他模块关系最少的模块。从图2-3中，我们可以看到，实际上，栈是唯一一个不依赖于其他模块接口的模块。从栈中指出的唯一一支箭头是虚线，这意味着通过事件驱动进行间接通信。尽管这个图形使得这个决策在视觉上显而易见，但即使没有架构图，我们也可能会得出相同的结论。栈本质上是一个独立的数据结构，易于独立实现和测试。一旦栈完成并经过测试，就可以将其整合到剩余模块的设计和测试中。因此，我们通过设计和实现栈来开始下一层次的分解。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Practical C++ Design From Programming to Architecture 1ed </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
